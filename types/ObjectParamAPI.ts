import { HttpFile, RequestContext, ResponseContext } from "../http/http.ts";
import * as models from "../models/all.ts";
import { Configuration } from "../configuration.ts";

import { IoK8sApiAdmissionregistrationV1MutatingWebhook } from "../models/IoK8sApiAdmissionregistrationV1MutatingWebhook.ts";
import { IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration } from "../models/IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration.ts";
import { IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList } from "../models/IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList.ts";
import { IoK8sApiAdmissionregistrationV1RuleWithOperations } from "../models/IoK8sApiAdmissionregistrationV1RuleWithOperations.ts";
import { IoK8sApiAdmissionregistrationV1ServiceReference } from "../models/IoK8sApiAdmissionregistrationV1ServiceReference.ts";
import { IoK8sApiAdmissionregistrationV1ValidatingWebhook } from "../models/IoK8sApiAdmissionregistrationV1ValidatingWebhook.ts";
import { IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration } from "../models/IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration.ts";
import { IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList } from "../models/IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList.ts";
import { IoK8sApiAdmissionregistrationV1WebhookClientConfig } from "../models/IoK8sApiAdmissionregistrationV1WebhookClientConfig.ts";
import { IoK8sApiAdmissionregistrationV1beta1MutatingWebhook } from "../models/IoK8sApiAdmissionregistrationV1beta1MutatingWebhook.ts";
import { IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration } from "../models/IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration.ts";
import { IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfigurationList } from "../models/IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfigurationList.ts";
import { IoK8sApiAdmissionregistrationV1beta1RuleWithOperations } from "../models/IoK8sApiAdmissionregistrationV1beta1RuleWithOperations.ts";
import { IoK8sApiAdmissionregistrationV1beta1ServiceReference } from "../models/IoK8sApiAdmissionregistrationV1beta1ServiceReference.ts";
import { IoK8sApiAdmissionregistrationV1beta1ValidatingWebhook } from "../models/IoK8sApiAdmissionregistrationV1beta1ValidatingWebhook.ts";
import { IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration } from "../models/IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration.ts";
import { IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfigurationList } from "../models/IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfigurationList.ts";
import { IoK8sApiAdmissionregistrationV1beta1WebhookClientConfig } from "../models/IoK8sApiAdmissionregistrationV1beta1WebhookClientConfig.ts";
import { IoK8sApiAppsV1ControllerRevision } from "../models/IoK8sApiAppsV1ControllerRevision.ts";
import { IoK8sApiAppsV1ControllerRevisionList } from "../models/IoK8sApiAppsV1ControllerRevisionList.ts";
import { IoK8sApiAppsV1DaemonSet } from "../models/IoK8sApiAppsV1DaemonSet.ts";
import { IoK8sApiAppsV1DaemonSetCondition } from "../models/IoK8sApiAppsV1DaemonSetCondition.ts";
import { IoK8sApiAppsV1DaemonSetList } from "../models/IoK8sApiAppsV1DaemonSetList.ts";
import { IoK8sApiAppsV1DaemonSetSpec } from "../models/IoK8sApiAppsV1DaemonSetSpec.ts";
import { IoK8sApiAppsV1DaemonSetStatus } from "../models/IoK8sApiAppsV1DaemonSetStatus.ts";
import { IoK8sApiAppsV1DaemonSetUpdateStrategy } from "../models/IoK8sApiAppsV1DaemonSetUpdateStrategy.ts";
import { IoK8sApiAppsV1Deployment } from "../models/IoK8sApiAppsV1Deployment.ts";
import { IoK8sApiAppsV1DeploymentCondition } from "../models/IoK8sApiAppsV1DeploymentCondition.ts";
import { IoK8sApiAppsV1DeploymentList } from "../models/IoK8sApiAppsV1DeploymentList.ts";
import { IoK8sApiAppsV1DeploymentSpec } from "../models/IoK8sApiAppsV1DeploymentSpec.ts";
import { IoK8sApiAppsV1DeploymentStatus } from "../models/IoK8sApiAppsV1DeploymentStatus.ts";
import { IoK8sApiAppsV1DeploymentStrategy } from "../models/IoK8sApiAppsV1DeploymentStrategy.ts";
import { IoK8sApiAppsV1ReplicaSet } from "../models/IoK8sApiAppsV1ReplicaSet.ts";
import { IoK8sApiAppsV1ReplicaSetCondition } from "../models/IoK8sApiAppsV1ReplicaSetCondition.ts";
import { IoK8sApiAppsV1ReplicaSetList } from "../models/IoK8sApiAppsV1ReplicaSetList.ts";
import { IoK8sApiAppsV1ReplicaSetSpec } from "../models/IoK8sApiAppsV1ReplicaSetSpec.ts";
import { IoK8sApiAppsV1ReplicaSetStatus } from "../models/IoK8sApiAppsV1ReplicaSetStatus.ts";
import { IoK8sApiAppsV1RollingUpdateDaemonSet } from "../models/IoK8sApiAppsV1RollingUpdateDaemonSet.ts";
import { IoK8sApiAppsV1RollingUpdateDeployment } from "../models/IoK8sApiAppsV1RollingUpdateDeployment.ts";
import { IoK8sApiAppsV1RollingUpdateStatefulSetStrategy } from "../models/IoK8sApiAppsV1RollingUpdateStatefulSetStrategy.ts";
import { IoK8sApiAppsV1StatefulSet } from "../models/IoK8sApiAppsV1StatefulSet.ts";
import { IoK8sApiAppsV1StatefulSetCondition } from "../models/IoK8sApiAppsV1StatefulSetCondition.ts";
import { IoK8sApiAppsV1StatefulSetList } from "../models/IoK8sApiAppsV1StatefulSetList.ts";
import { IoK8sApiAppsV1StatefulSetSpec } from "../models/IoK8sApiAppsV1StatefulSetSpec.ts";
import { IoK8sApiAppsV1StatefulSetStatus } from "../models/IoK8sApiAppsV1StatefulSetStatus.ts";
import { IoK8sApiAppsV1StatefulSetUpdateStrategy } from "../models/IoK8sApiAppsV1StatefulSetUpdateStrategy.ts";
import { IoK8sApiAuthenticationV1BoundObjectReference } from "../models/IoK8sApiAuthenticationV1BoundObjectReference.ts";
import { IoK8sApiAuthenticationV1TokenRequest } from "../models/IoK8sApiAuthenticationV1TokenRequest.ts";
import { IoK8sApiAuthenticationV1TokenRequestSpec } from "../models/IoK8sApiAuthenticationV1TokenRequestSpec.ts";
import { IoK8sApiAuthenticationV1TokenRequestStatus } from "../models/IoK8sApiAuthenticationV1TokenRequestStatus.ts";
import { IoK8sApiAuthenticationV1TokenReview } from "../models/IoK8sApiAuthenticationV1TokenReview.ts";
import { IoK8sApiAuthenticationV1TokenReviewSpec } from "../models/IoK8sApiAuthenticationV1TokenReviewSpec.ts";
import { IoK8sApiAuthenticationV1TokenReviewStatus } from "../models/IoK8sApiAuthenticationV1TokenReviewStatus.ts";
import { IoK8sApiAuthenticationV1UserInfo } from "../models/IoK8sApiAuthenticationV1UserInfo.ts";
import { IoK8sApiAuthenticationV1beta1TokenReview } from "../models/IoK8sApiAuthenticationV1beta1TokenReview.ts";
import { IoK8sApiAuthenticationV1beta1TokenReviewSpec } from "../models/IoK8sApiAuthenticationV1beta1TokenReviewSpec.ts";
import { IoK8sApiAuthenticationV1beta1TokenReviewStatus } from "../models/IoK8sApiAuthenticationV1beta1TokenReviewStatus.ts";
import { IoK8sApiAuthenticationV1beta1UserInfo } from "../models/IoK8sApiAuthenticationV1beta1UserInfo.ts";
import { IoK8sApiAuthorizationV1LocalSubjectAccessReview } from "../models/IoK8sApiAuthorizationV1LocalSubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1NonResourceAttributes } from "../models/IoK8sApiAuthorizationV1NonResourceAttributes.ts";
import { IoK8sApiAuthorizationV1NonResourceRule } from "../models/IoK8sApiAuthorizationV1NonResourceRule.ts";
import { IoK8sApiAuthorizationV1ResourceAttributes } from "../models/IoK8sApiAuthorizationV1ResourceAttributes.ts";
import { IoK8sApiAuthorizationV1ResourceRule } from "../models/IoK8sApiAuthorizationV1ResourceRule.ts";
import { IoK8sApiAuthorizationV1SelfSubjectAccessReview } from "../models/IoK8sApiAuthorizationV1SelfSubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1SelfSubjectAccessReviewSpec } from "../models/IoK8sApiAuthorizationV1SelfSubjectAccessReviewSpec.ts";
import { IoK8sApiAuthorizationV1SelfSubjectRulesReview } from "../models/IoK8sApiAuthorizationV1SelfSubjectRulesReview.ts";
import { IoK8sApiAuthorizationV1SelfSubjectRulesReviewSpec } from "../models/IoK8sApiAuthorizationV1SelfSubjectRulesReviewSpec.ts";
import { IoK8sApiAuthorizationV1SubjectAccessReview } from "../models/IoK8sApiAuthorizationV1SubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1SubjectAccessReviewSpec } from "../models/IoK8sApiAuthorizationV1SubjectAccessReviewSpec.ts";
import { IoK8sApiAuthorizationV1SubjectAccessReviewStatus } from "../models/IoK8sApiAuthorizationV1SubjectAccessReviewStatus.ts";
import { IoK8sApiAuthorizationV1SubjectRulesReviewStatus } from "../models/IoK8sApiAuthorizationV1SubjectRulesReviewStatus.ts";
import { IoK8sApiAuthorizationV1beta1LocalSubjectAccessReview } from "../models/IoK8sApiAuthorizationV1beta1LocalSubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1beta1NonResourceAttributes } from "../models/IoK8sApiAuthorizationV1beta1NonResourceAttributes.ts";
import { IoK8sApiAuthorizationV1beta1NonResourceRule } from "../models/IoK8sApiAuthorizationV1beta1NonResourceRule.ts";
import { IoK8sApiAuthorizationV1beta1ResourceAttributes } from "../models/IoK8sApiAuthorizationV1beta1ResourceAttributes.ts";
import { IoK8sApiAuthorizationV1beta1ResourceRule } from "../models/IoK8sApiAuthorizationV1beta1ResourceRule.ts";
import { IoK8sApiAuthorizationV1beta1SelfSubjectAccessReview } from "../models/IoK8sApiAuthorizationV1beta1SelfSubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1beta1SelfSubjectAccessReviewSpec } from "../models/IoK8sApiAuthorizationV1beta1SelfSubjectAccessReviewSpec.ts";
import { IoK8sApiAuthorizationV1beta1SelfSubjectRulesReview } from "../models/IoK8sApiAuthorizationV1beta1SelfSubjectRulesReview.ts";
import { IoK8sApiAuthorizationV1beta1SelfSubjectRulesReviewSpec } from "../models/IoK8sApiAuthorizationV1beta1SelfSubjectRulesReviewSpec.ts";
import { IoK8sApiAuthorizationV1beta1SubjectAccessReview } from "../models/IoK8sApiAuthorizationV1beta1SubjectAccessReview.ts";
import { IoK8sApiAuthorizationV1beta1SubjectAccessReviewSpec } from "../models/IoK8sApiAuthorizationV1beta1SubjectAccessReviewSpec.ts";
import { IoK8sApiAuthorizationV1beta1SubjectAccessReviewStatus } from "../models/IoK8sApiAuthorizationV1beta1SubjectAccessReviewStatus.ts";
import { IoK8sApiAuthorizationV1beta1SubjectRulesReviewStatus } from "../models/IoK8sApiAuthorizationV1beta1SubjectRulesReviewStatus.ts";
import { IoK8sApiAutoscalingV1CrossVersionObjectReference } from "../models/IoK8sApiAutoscalingV1CrossVersionObjectReference.ts";
import { IoK8sApiAutoscalingV1HorizontalPodAutoscaler } from "../models/IoK8sApiAutoscalingV1HorizontalPodAutoscaler.ts";
import { IoK8sApiAutoscalingV1HorizontalPodAutoscalerList } from "../models/IoK8sApiAutoscalingV1HorizontalPodAutoscalerList.ts";
import { IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec } from "../models/IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec.ts";
import { IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus } from "../models/IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus.ts";
import { IoK8sApiAutoscalingV1Scale } from "../models/IoK8sApiAutoscalingV1Scale.ts";
import { IoK8sApiAutoscalingV1ScaleSpec } from "../models/IoK8sApiAutoscalingV1ScaleSpec.ts";
import { IoK8sApiAutoscalingV1ScaleStatus } from "../models/IoK8sApiAutoscalingV1ScaleStatus.ts";
import { IoK8sApiAutoscalingV2beta1CrossVersionObjectReference } from "../models/IoK8sApiAutoscalingV2beta1CrossVersionObjectReference.ts";
import { IoK8sApiAutoscalingV2beta1ExternalMetricSource } from "../models/IoK8sApiAutoscalingV2beta1ExternalMetricSource.ts";
import { IoK8sApiAutoscalingV2beta1ExternalMetricStatus } from "../models/IoK8sApiAutoscalingV2beta1ExternalMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler } from "../models/IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler.ts";
import { IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerCondition } from "../models/IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerCondition.ts";
import { IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerList } from "../models/IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerList.ts";
import { IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerSpec } from "../models/IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerSpec.ts";
import { IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerStatus } from "../models/IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerStatus.ts";
import { IoK8sApiAutoscalingV2beta1MetricSpec } from "../models/IoK8sApiAutoscalingV2beta1MetricSpec.ts";
import { IoK8sApiAutoscalingV2beta1MetricStatus } from "../models/IoK8sApiAutoscalingV2beta1MetricStatus.ts";
import { IoK8sApiAutoscalingV2beta1ObjectMetricSource } from "../models/IoK8sApiAutoscalingV2beta1ObjectMetricSource.ts";
import { IoK8sApiAutoscalingV2beta1ObjectMetricStatus } from "../models/IoK8sApiAutoscalingV2beta1ObjectMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta1PodsMetricSource } from "../models/IoK8sApiAutoscalingV2beta1PodsMetricSource.ts";
import { IoK8sApiAutoscalingV2beta1PodsMetricStatus } from "../models/IoK8sApiAutoscalingV2beta1PodsMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta1ResourceMetricSource } from "../models/IoK8sApiAutoscalingV2beta1ResourceMetricSource.ts";
import { IoK8sApiAutoscalingV2beta1ResourceMetricStatus } from "../models/IoK8sApiAutoscalingV2beta1ResourceMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta2CrossVersionObjectReference } from "../models/IoK8sApiAutoscalingV2beta2CrossVersionObjectReference.ts";
import { IoK8sApiAutoscalingV2beta2ExternalMetricSource } from "../models/IoK8sApiAutoscalingV2beta2ExternalMetricSource.ts";
import { IoK8sApiAutoscalingV2beta2ExternalMetricStatus } from "../models/IoK8sApiAutoscalingV2beta2ExternalMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta2HPAScalingPolicy } from "../models/IoK8sApiAutoscalingV2beta2HPAScalingPolicy.ts";
import { IoK8sApiAutoscalingV2beta2HPAScalingRules } from "../models/IoK8sApiAutoscalingV2beta2HPAScalingRules.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerBehavior } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerBehavior.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerCondition } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerCondition.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerList } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerList.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerSpec } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerSpec.ts";
import { IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerStatus } from "../models/IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerStatus.ts";
import { IoK8sApiAutoscalingV2beta2MetricIdentifier } from "../models/IoK8sApiAutoscalingV2beta2MetricIdentifier.ts";
import { IoK8sApiAutoscalingV2beta2MetricSpec } from "../models/IoK8sApiAutoscalingV2beta2MetricSpec.ts";
import { IoK8sApiAutoscalingV2beta2MetricStatus } from "../models/IoK8sApiAutoscalingV2beta2MetricStatus.ts";
import { IoK8sApiAutoscalingV2beta2MetricTarget } from "../models/IoK8sApiAutoscalingV2beta2MetricTarget.ts";
import { IoK8sApiAutoscalingV2beta2MetricValueStatus } from "../models/IoK8sApiAutoscalingV2beta2MetricValueStatus.ts";
import { IoK8sApiAutoscalingV2beta2ObjectMetricSource } from "../models/IoK8sApiAutoscalingV2beta2ObjectMetricSource.ts";
import { IoK8sApiAutoscalingV2beta2ObjectMetricStatus } from "../models/IoK8sApiAutoscalingV2beta2ObjectMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta2PodsMetricSource } from "../models/IoK8sApiAutoscalingV2beta2PodsMetricSource.ts";
import { IoK8sApiAutoscalingV2beta2PodsMetricStatus } from "../models/IoK8sApiAutoscalingV2beta2PodsMetricStatus.ts";
import { IoK8sApiAutoscalingV2beta2ResourceMetricSource } from "../models/IoK8sApiAutoscalingV2beta2ResourceMetricSource.ts";
import { IoK8sApiAutoscalingV2beta2ResourceMetricStatus } from "../models/IoK8sApiAutoscalingV2beta2ResourceMetricStatus.ts";
import { IoK8sApiBatchV1Job } from "../models/IoK8sApiBatchV1Job.ts";
import { IoK8sApiBatchV1JobCondition } from "../models/IoK8sApiBatchV1JobCondition.ts";
import { IoK8sApiBatchV1JobList } from "../models/IoK8sApiBatchV1JobList.ts";
import { IoK8sApiBatchV1JobSpec } from "../models/IoK8sApiBatchV1JobSpec.ts";
import { IoK8sApiBatchV1JobStatus } from "../models/IoK8sApiBatchV1JobStatus.ts";
import { IoK8sApiBatchV1beta1CronJob } from "../models/IoK8sApiBatchV1beta1CronJob.ts";
import { IoK8sApiBatchV1beta1CronJobList } from "../models/IoK8sApiBatchV1beta1CronJobList.ts";
import { IoK8sApiBatchV1beta1CronJobSpec } from "../models/IoK8sApiBatchV1beta1CronJobSpec.ts";
import { IoK8sApiBatchV1beta1CronJobStatus } from "../models/IoK8sApiBatchV1beta1CronJobStatus.ts";
import { IoK8sApiBatchV1beta1JobTemplateSpec } from "../models/IoK8sApiBatchV1beta1JobTemplateSpec.ts";
import { IoK8sApiBatchV2alpha1CronJob } from "../models/IoK8sApiBatchV2alpha1CronJob.ts";
import { IoK8sApiBatchV2alpha1CronJobList } from "../models/IoK8sApiBatchV2alpha1CronJobList.ts";
import { IoK8sApiBatchV2alpha1CronJobSpec } from "../models/IoK8sApiBatchV2alpha1CronJobSpec.ts";
import { IoK8sApiBatchV2alpha1CronJobStatus } from "../models/IoK8sApiBatchV2alpha1CronJobStatus.ts";
import { IoK8sApiBatchV2alpha1JobTemplateSpec } from "../models/IoK8sApiBatchV2alpha1JobTemplateSpec.ts";
import { IoK8sApiCertificatesV1CertificateSigningRequest } from "../models/IoK8sApiCertificatesV1CertificateSigningRequest.ts";
import { IoK8sApiCertificatesV1CertificateSigningRequestCondition } from "../models/IoK8sApiCertificatesV1CertificateSigningRequestCondition.ts";
import { IoK8sApiCertificatesV1CertificateSigningRequestList } from "../models/IoK8sApiCertificatesV1CertificateSigningRequestList.ts";
import { IoK8sApiCertificatesV1CertificateSigningRequestSpec } from "../models/IoK8sApiCertificatesV1CertificateSigningRequestSpec.ts";
import { IoK8sApiCertificatesV1CertificateSigningRequestStatus } from "../models/IoK8sApiCertificatesV1CertificateSigningRequestStatus.ts";
import { IoK8sApiCertificatesV1beta1CertificateSigningRequest } from "../models/IoK8sApiCertificatesV1beta1CertificateSigningRequest.ts";
import { IoK8sApiCertificatesV1beta1CertificateSigningRequestCondition } from "../models/IoK8sApiCertificatesV1beta1CertificateSigningRequestCondition.ts";
import { IoK8sApiCertificatesV1beta1CertificateSigningRequestList } from "../models/IoK8sApiCertificatesV1beta1CertificateSigningRequestList.ts";
import { IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec } from "../models/IoK8sApiCertificatesV1beta1CertificateSigningRequestSpec.ts";
import { IoK8sApiCertificatesV1beta1CertificateSigningRequestStatus } from "../models/IoK8sApiCertificatesV1beta1CertificateSigningRequestStatus.ts";
import { IoK8sApiCoordinationV1Lease } from "../models/IoK8sApiCoordinationV1Lease.ts";
import { IoK8sApiCoordinationV1LeaseList } from "../models/IoK8sApiCoordinationV1LeaseList.ts";
import { IoK8sApiCoordinationV1LeaseSpec } from "../models/IoK8sApiCoordinationV1LeaseSpec.ts";
import { IoK8sApiCoordinationV1beta1Lease } from "../models/IoK8sApiCoordinationV1beta1Lease.ts";
import { IoK8sApiCoordinationV1beta1LeaseList } from "../models/IoK8sApiCoordinationV1beta1LeaseList.ts";
import { IoK8sApiCoordinationV1beta1LeaseSpec } from "../models/IoK8sApiCoordinationV1beta1LeaseSpec.ts";
import { IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource } from "../models/IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource.ts";
import { IoK8sApiCoreV1Affinity } from "../models/IoK8sApiCoreV1Affinity.ts";
import { IoK8sApiCoreV1AttachedVolume } from "../models/IoK8sApiCoreV1AttachedVolume.ts";
import { IoK8sApiCoreV1AzureDiskVolumeSource } from "../models/IoK8sApiCoreV1AzureDiskVolumeSource.ts";
import { IoK8sApiCoreV1AzureFilePersistentVolumeSource } from "../models/IoK8sApiCoreV1AzureFilePersistentVolumeSource.ts";
import { IoK8sApiCoreV1AzureFileVolumeSource } from "../models/IoK8sApiCoreV1AzureFileVolumeSource.ts";
import { IoK8sApiCoreV1Binding } from "../models/IoK8sApiCoreV1Binding.ts";
import { IoK8sApiCoreV1CSIPersistentVolumeSource } from "../models/IoK8sApiCoreV1CSIPersistentVolumeSource.ts";
import { IoK8sApiCoreV1CSIVolumeSource } from "../models/IoK8sApiCoreV1CSIVolumeSource.ts";
import { IoK8sApiCoreV1Capabilities } from "../models/IoK8sApiCoreV1Capabilities.ts";
import { IoK8sApiCoreV1CephFSPersistentVolumeSource } from "../models/IoK8sApiCoreV1CephFSPersistentVolumeSource.ts";
import { IoK8sApiCoreV1CephFSVolumeSource } from "../models/IoK8sApiCoreV1CephFSVolumeSource.ts";
import { IoK8sApiCoreV1CinderPersistentVolumeSource } from "../models/IoK8sApiCoreV1CinderPersistentVolumeSource.ts";
import { IoK8sApiCoreV1CinderVolumeSource } from "../models/IoK8sApiCoreV1CinderVolumeSource.ts";
import { IoK8sApiCoreV1ClientIPConfig } from "../models/IoK8sApiCoreV1ClientIPConfig.ts";
import { IoK8sApiCoreV1ComponentCondition } from "../models/IoK8sApiCoreV1ComponentCondition.ts";
import { IoK8sApiCoreV1ComponentStatus } from "../models/IoK8sApiCoreV1ComponentStatus.ts";
import { IoK8sApiCoreV1ComponentStatusList } from "../models/IoK8sApiCoreV1ComponentStatusList.ts";
import { IoK8sApiCoreV1ConfigMap } from "../models/IoK8sApiCoreV1ConfigMap.ts";
import { IoK8sApiCoreV1ConfigMapEnvSource } from "../models/IoK8sApiCoreV1ConfigMapEnvSource.ts";
import { IoK8sApiCoreV1ConfigMapKeySelector } from "../models/IoK8sApiCoreV1ConfigMapKeySelector.ts";
import { IoK8sApiCoreV1ConfigMapList } from "../models/IoK8sApiCoreV1ConfigMapList.ts";
import { IoK8sApiCoreV1ConfigMapNodeConfigSource } from "../models/IoK8sApiCoreV1ConfigMapNodeConfigSource.ts";
import { IoK8sApiCoreV1ConfigMapProjection } from "../models/IoK8sApiCoreV1ConfigMapProjection.ts";
import { IoK8sApiCoreV1ConfigMapVolumeSource } from "../models/IoK8sApiCoreV1ConfigMapVolumeSource.ts";
import { IoK8sApiCoreV1Container } from "../models/IoK8sApiCoreV1Container.ts";
import { IoK8sApiCoreV1ContainerImage } from "../models/IoK8sApiCoreV1ContainerImage.ts";
import { IoK8sApiCoreV1ContainerPort } from "../models/IoK8sApiCoreV1ContainerPort.ts";
import { IoK8sApiCoreV1ContainerState } from "../models/IoK8sApiCoreV1ContainerState.ts";
import { IoK8sApiCoreV1ContainerStateRunning } from "../models/IoK8sApiCoreV1ContainerStateRunning.ts";
import { IoK8sApiCoreV1ContainerStateTerminated } from "../models/IoK8sApiCoreV1ContainerStateTerminated.ts";
import { IoK8sApiCoreV1ContainerStateWaiting } from "../models/IoK8sApiCoreV1ContainerStateWaiting.ts";
import { IoK8sApiCoreV1ContainerStatus } from "../models/IoK8sApiCoreV1ContainerStatus.ts";
import { IoK8sApiCoreV1DaemonEndpoint } from "../models/IoK8sApiCoreV1DaemonEndpoint.ts";
import { IoK8sApiCoreV1DownwardAPIProjection } from "../models/IoK8sApiCoreV1DownwardAPIProjection.ts";
import { IoK8sApiCoreV1DownwardAPIVolumeFile } from "../models/IoK8sApiCoreV1DownwardAPIVolumeFile.ts";
import { IoK8sApiCoreV1DownwardAPIVolumeSource } from "../models/IoK8sApiCoreV1DownwardAPIVolumeSource.ts";
import { IoK8sApiCoreV1EmptyDirVolumeSource } from "../models/IoK8sApiCoreV1EmptyDirVolumeSource.ts";
import { IoK8sApiCoreV1EndpointAddress } from "../models/IoK8sApiCoreV1EndpointAddress.ts";
import { IoK8sApiCoreV1EndpointPort } from "../models/IoK8sApiCoreV1EndpointPort.ts";
import { IoK8sApiCoreV1EndpointSubset } from "../models/IoK8sApiCoreV1EndpointSubset.ts";
import { IoK8sApiCoreV1Endpoints } from "../models/IoK8sApiCoreV1Endpoints.ts";
import { IoK8sApiCoreV1EndpointsList } from "../models/IoK8sApiCoreV1EndpointsList.ts";
import { IoK8sApiCoreV1EnvFromSource } from "../models/IoK8sApiCoreV1EnvFromSource.ts";
import { IoK8sApiCoreV1EnvVar } from "../models/IoK8sApiCoreV1EnvVar.ts";
import { IoK8sApiCoreV1EnvVarSource } from "../models/IoK8sApiCoreV1EnvVarSource.ts";
import { IoK8sApiCoreV1EphemeralContainer } from "../models/IoK8sApiCoreV1EphemeralContainer.ts";
import { IoK8sApiCoreV1EphemeralVolumeSource } from "../models/IoK8sApiCoreV1EphemeralVolumeSource.ts";
import { IoK8sApiCoreV1Event } from "../models/IoK8sApiCoreV1Event.ts";
import { IoK8sApiCoreV1EventList } from "../models/IoK8sApiCoreV1EventList.ts";
import { IoK8sApiCoreV1EventSeries } from "../models/IoK8sApiCoreV1EventSeries.ts";
import { IoK8sApiCoreV1EventSource } from "../models/IoK8sApiCoreV1EventSource.ts";
import { IoK8sApiCoreV1ExecAction } from "../models/IoK8sApiCoreV1ExecAction.ts";
import { IoK8sApiCoreV1FCVolumeSource } from "../models/IoK8sApiCoreV1FCVolumeSource.ts";
import { IoK8sApiCoreV1FlexPersistentVolumeSource } from "../models/IoK8sApiCoreV1FlexPersistentVolumeSource.ts";
import { IoK8sApiCoreV1FlexVolumeSource } from "../models/IoK8sApiCoreV1FlexVolumeSource.ts";
import { IoK8sApiCoreV1FlockerVolumeSource } from "../models/IoK8sApiCoreV1FlockerVolumeSource.ts";
import { IoK8sApiCoreV1GCEPersistentDiskVolumeSource } from "../models/IoK8sApiCoreV1GCEPersistentDiskVolumeSource.ts";
import { IoK8sApiCoreV1GitRepoVolumeSource } from "../models/IoK8sApiCoreV1GitRepoVolumeSource.ts";
import { IoK8sApiCoreV1GlusterfsPersistentVolumeSource } from "../models/IoK8sApiCoreV1GlusterfsPersistentVolumeSource.ts";
import { IoK8sApiCoreV1GlusterfsVolumeSource } from "../models/IoK8sApiCoreV1GlusterfsVolumeSource.ts";
import { IoK8sApiCoreV1HTTPGetAction } from "../models/IoK8sApiCoreV1HTTPGetAction.ts";
import { IoK8sApiCoreV1HTTPHeader } from "../models/IoK8sApiCoreV1HTTPHeader.ts";
import { IoK8sApiCoreV1Handler } from "../models/IoK8sApiCoreV1Handler.ts";
import { IoK8sApiCoreV1HostAlias } from "../models/IoK8sApiCoreV1HostAlias.ts";
import { IoK8sApiCoreV1HostPathVolumeSource } from "../models/IoK8sApiCoreV1HostPathVolumeSource.ts";
import { IoK8sApiCoreV1ISCSIPersistentVolumeSource } from "../models/IoK8sApiCoreV1ISCSIPersistentVolumeSource.ts";
import { IoK8sApiCoreV1ISCSIVolumeSource } from "../models/IoK8sApiCoreV1ISCSIVolumeSource.ts";
import { IoK8sApiCoreV1KeyToPath } from "../models/IoK8sApiCoreV1KeyToPath.ts";
import { IoK8sApiCoreV1Lifecycle } from "../models/IoK8sApiCoreV1Lifecycle.ts";
import { IoK8sApiCoreV1LimitRange } from "../models/IoK8sApiCoreV1LimitRange.ts";
import { IoK8sApiCoreV1LimitRangeItem } from "../models/IoK8sApiCoreV1LimitRangeItem.ts";
import { IoK8sApiCoreV1LimitRangeList } from "../models/IoK8sApiCoreV1LimitRangeList.ts";
import { IoK8sApiCoreV1LimitRangeSpec } from "../models/IoK8sApiCoreV1LimitRangeSpec.ts";
import { IoK8sApiCoreV1LoadBalancerIngress } from "../models/IoK8sApiCoreV1LoadBalancerIngress.ts";
import { IoK8sApiCoreV1LoadBalancerStatus } from "../models/IoK8sApiCoreV1LoadBalancerStatus.ts";
import { IoK8sApiCoreV1LocalObjectReference } from "../models/IoK8sApiCoreV1LocalObjectReference.ts";
import { IoK8sApiCoreV1LocalVolumeSource } from "../models/IoK8sApiCoreV1LocalVolumeSource.ts";
import { IoK8sApiCoreV1NFSVolumeSource } from "../models/IoK8sApiCoreV1NFSVolumeSource.ts";
import { IoK8sApiCoreV1Namespace } from "../models/IoK8sApiCoreV1Namespace.ts";
import { IoK8sApiCoreV1NamespaceCondition } from "../models/IoK8sApiCoreV1NamespaceCondition.ts";
import { IoK8sApiCoreV1NamespaceList } from "../models/IoK8sApiCoreV1NamespaceList.ts";
import { IoK8sApiCoreV1NamespaceSpec } from "../models/IoK8sApiCoreV1NamespaceSpec.ts";
import { IoK8sApiCoreV1NamespaceStatus } from "../models/IoK8sApiCoreV1NamespaceStatus.ts";
import { IoK8sApiCoreV1Node } from "../models/IoK8sApiCoreV1Node.ts";
import { IoK8sApiCoreV1NodeAddress } from "../models/IoK8sApiCoreV1NodeAddress.ts";
import { IoK8sApiCoreV1NodeAffinity } from "../models/IoK8sApiCoreV1NodeAffinity.ts";
import { IoK8sApiCoreV1NodeCondition } from "../models/IoK8sApiCoreV1NodeCondition.ts";
import { IoK8sApiCoreV1NodeConfigSource } from "../models/IoK8sApiCoreV1NodeConfigSource.ts";
import { IoK8sApiCoreV1NodeConfigStatus } from "../models/IoK8sApiCoreV1NodeConfigStatus.ts";
import { IoK8sApiCoreV1NodeDaemonEndpoints } from "../models/IoK8sApiCoreV1NodeDaemonEndpoints.ts";
import { IoK8sApiCoreV1NodeList } from "../models/IoK8sApiCoreV1NodeList.ts";
import { IoK8sApiCoreV1NodeSelector } from "../models/IoK8sApiCoreV1NodeSelector.ts";
import { IoK8sApiCoreV1NodeSelectorRequirement } from "../models/IoK8sApiCoreV1NodeSelectorRequirement.ts";
import { IoK8sApiCoreV1NodeSelectorTerm } from "../models/IoK8sApiCoreV1NodeSelectorTerm.ts";
import { IoK8sApiCoreV1NodeSpec } from "../models/IoK8sApiCoreV1NodeSpec.ts";
import { IoK8sApiCoreV1NodeStatus } from "../models/IoK8sApiCoreV1NodeStatus.ts";
import { IoK8sApiCoreV1NodeSystemInfo } from "../models/IoK8sApiCoreV1NodeSystemInfo.ts";
import { IoK8sApiCoreV1ObjectFieldSelector } from "../models/IoK8sApiCoreV1ObjectFieldSelector.ts";
import { IoK8sApiCoreV1ObjectReference } from "../models/IoK8sApiCoreV1ObjectReference.ts";
import { IoK8sApiCoreV1PersistentVolume } from "../models/IoK8sApiCoreV1PersistentVolume.ts";
import { IoK8sApiCoreV1PersistentVolumeClaim } from "../models/IoK8sApiCoreV1PersistentVolumeClaim.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimCondition } from "../models/IoK8sApiCoreV1PersistentVolumeClaimCondition.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimList } from "../models/IoK8sApiCoreV1PersistentVolumeClaimList.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimSpec } from "../models/IoK8sApiCoreV1PersistentVolumeClaimSpec.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimStatus } from "../models/IoK8sApiCoreV1PersistentVolumeClaimStatus.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimTemplate } from "../models/IoK8sApiCoreV1PersistentVolumeClaimTemplate.ts";
import { IoK8sApiCoreV1PersistentVolumeClaimVolumeSource } from "../models/IoK8sApiCoreV1PersistentVolumeClaimVolumeSource.ts";
import { IoK8sApiCoreV1PersistentVolumeList } from "../models/IoK8sApiCoreV1PersistentVolumeList.ts";
import { IoK8sApiCoreV1PersistentVolumeSpec } from "../models/IoK8sApiCoreV1PersistentVolumeSpec.ts";
import { IoK8sApiCoreV1PersistentVolumeStatus } from "../models/IoK8sApiCoreV1PersistentVolumeStatus.ts";
import { IoK8sApiCoreV1PhotonPersistentDiskVolumeSource } from "../models/IoK8sApiCoreV1PhotonPersistentDiskVolumeSource.ts";
import { IoK8sApiCoreV1Pod } from "../models/IoK8sApiCoreV1Pod.ts";
import { IoK8sApiCoreV1PodAffinity } from "../models/IoK8sApiCoreV1PodAffinity.ts";
import { IoK8sApiCoreV1PodAffinityTerm } from "../models/IoK8sApiCoreV1PodAffinityTerm.ts";
import { IoK8sApiCoreV1PodAntiAffinity } from "../models/IoK8sApiCoreV1PodAntiAffinity.ts";
import { IoK8sApiCoreV1PodCondition } from "../models/IoK8sApiCoreV1PodCondition.ts";
import { IoK8sApiCoreV1PodDNSConfig } from "../models/IoK8sApiCoreV1PodDNSConfig.ts";
import { IoK8sApiCoreV1PodDNSConfigOption } from "../models/IoK8sApiCoreV1PodDNSConfigOption.ts";
import { IoK8sApiCoreV1PodIP } from "../models/IoK8sApiCoreV1PodIP.ts";
import { IoK8sApiCoreV1PodList } from "../models/IoK8sApiCoreV1PodList.ts";
import { IoK8sApiCoreV1PodReadinessGate } from "../models/IoK8sApiCoreV1PodReadinessGate.ts";
import { IoK8sApiCoreV1PodSecurityContext } from "../models/IoK8sApiCoreV1PodSecurityContext.ts";
import { IoK8sApiCoreV1PodSpec } from "../models/IoK8sApiCoreV1PodSpec.ts";
import { IoK8sApiCoreV1PodStatus } from "../models/IoK8sApiCoreV1PodStatus.ts";
import { IoK8sApiCoreV1PodTemplate } from "../models/IoK8sApiCoreV1PodTemplate.ts";
import { IoK8sApiCoreV1PodTemplateList } from "../models/IoK8sApiCoreV1PodTemplateList.ts";
import { IoK8sApiCoreV1PodTemplateSpec } from "../models/IoK8sApiCoreV1PodTemplateSpec.ts";
import { IoK8sApiCoreV1PortworxVolumeSource } from "../models/IoK8sApiCoreV1PortworxVolumeSource.ts";
import { IoK8sApiCoreV1PreferredSchedulingTerm } from "../models/IoK8sApiCoreV1PreferredSchedulingTerm.ts";
import { IoK8sApiCoreV1Probe } from "../models/IoK8sApiCoreV1Probe.ts";
import { IoK8sApiCoreV1ProjectedVolumeSource } from "../models/IoK8sApiCoreV1ProjectedVolumeSource.ts";
import { IoK8sApiCoreV1QuobyteVolumeSource } from "../models/IoK8sApiCoreV1QuobyteVolumeSource.ts";
import { IoK8sApiCoreV1RBDPersistentVolumeSource } from "../models/IoK8sApiCoreV1RBDPersistentVolumeSource.ts";
import { IoK8sApiCoreV1RBDVolumeSource } from "../models/IoK8sApiCoreV1RBDVolumeSource.ts";
import { IoK8sApiCoreV1ReplicationController } from "../models/IoK8sApiCoreV1ReplicationController.ts";
import { IoK8sApiCoreV1ReplicationControllerCondition } from "../models/IoK8sApiCoreV1ReplicationControllerCondition.ts";
import { IoK8sApiCoreV1ReplicationControllerList } from "../models/IoK8sApiCoreV1ReplicationControllerList.ts";
import { IoK8sApiCoreV1ReplicationControllerSpec } from "../models/IoK8sApiCoreV1ReplicationControllerSpec.ts";
import { IoK8sApiCoreV1ReplicationControllerStatus } from "../models/IoK8sApiCoreV1ReplicationControllerStatus.ts";
import { IoK8sApiCoreV1ResourceFieldSelector } from "../models/IoK8sApiCoreV1ResourceFieldSelector.ts";
import { IoK8sApiCoreV1ResourceQuota } from "../models/IoK8sApiCoreV1ResourceQuota.ts";
import { IoK8sApiCoreV1ResourceQuotaList } from "../models/IoK8sApiCoreV1ResourceQuotaList.ts";
import { IoK8sApiCoreV1ResourceQuotaSpec } from "../models/IoK8sApiCoreV1ResourceQuotaSpec.ts";
import { IoK8sApiCoreV1ResourceQuotaStatus } from "../models/IoK8sApiCoreV1ResourceQuotaStatus.ts";
import { IoK8sApiCoreV1ResourceRequirements } from "../models/IoK8sApiCoreV1ResourceRequirements.ts";
import { IoK8sApiCoreV1SELinuxOptions } from "../models/IoK8sApiCoreV1SELinuxOptions.ts";
import { IoK8sApiCoreV1ScaleIOPersistentVolumeSource } from "../models/IoK8sApiCoreV1ScaleIOPersistentVolumeSource.ts";
import { IoK8sApiCoreV1ScaleIOVolumeSource } from "../models/IoK8sApiCoreV1ScaleIOVolumeSource.ts";
import { IoK8sApiCoreV1ScopeSelector } from "../models/IoK8sApiCoreV1ScopeSelector.ts";
import { IoK8sApiCoreV1ScopedResourceSelectorRequirement } from "../models/IoK8sApiCoreV1ScopedResourceSelectorRequirement.ts";
import { IoK8sApiCoreV1SeccompProfile } from "../models/IoK8sApiCoreV1SeccompProfile.ts";
import { IoK8sApiCoreV1Secret } from "../models/IoK8sApiCoreV1Secret.ts";
import { IoK8sApiCoreV1SecretEnvSource } from "../models/IoK8sApiCoreV1SecretEnvSource.ts";
import { IoK8sApiCoreV1SecretKeySelector } from "../models/IoK8sApiCoreV1SecretKeySelector.ts";
import { IoK8sApiCoreV1SecretList } from "../models/IoK8sApiCoreV1SecretList.ts";
import { IoK8sApiCoreV1SecretProjection } from "../models/IoK8sApiCoreV1SecretProjection.ts";
import { IoK8sApiCoreV1SecretReference } from "../models/IoK8sApiCoreV1SecretReference.ts";
import { IoK8sApiCoreV1SecretVolumeSource } from "../models/IoK8sApiCoreV1SecretVolumeSource.ts";
import { IoK8sApiCoreV1SecurityContext } from "../models/IoK8sApiCoreV1SecurityContext.ts";
import { IoK8sApiCoreV1Service } from "../models/IoK8sApiCoreV1Service.ts";
import { IoK8sApiCoreV1ServiceAccount } from "../models/IoK8sApiCoreV1ServiceAccount.ts";
import { IoK8sApiCoreV1ServiceAccountList } from "../models/IoK8sApiCoreV1ServiceAccountList.ts";
import { IoK8sApiCoreV1ServiceAccountTokenProjection } from "../models/IoK8sApiCoreV1ServiceAccountTokenProjection.ts";
import { IoK8sApiCoreV1ServiceList } from "../models/IoK8sApiCoreV1ServiceList.ts";
import { IoK8sApiCoreV1ServicePort } from "../models/IoK8sApiCoreV1ServicePort.ts";
import { IoK8sApiCoreV1ServiceSpec } from "../models/IoK8sApiCoreV1ServiceSpec.ts";
import { IoK8sApiCoreV1ServiceStatus } from "../models/IoK8sApiCoreV1ServiceStatus.ts";
import { IoK8sApiCoreV1SessionAffinityConfig } from "../models/IoK8sApiCoreV1SessionAffinityConfig.ts";
import { IoK8sApiCoreV1StorageOSPersistentVolumeSource } from "../models/IoK8sApiCoreV1StorageOSPersistentVolumeSource.ts";
import { IoK8sApiCoreV1StorageOSVolumeSource } from "../models/IoK8sApiCoreV1StorageOSVolumeSource.ts";
import { IoK8sApiCoreV1Sysctl } from "../models/IoK8sApiCoreV1Sysctl.ts";
import { IoK8sApiCoreV1TCPSocketAction } from "../models/IoK8sApiCoreV1TCPSocketAction.ts";
import { IoK8sApiCoreV1Taint } from "../models/IoK8sApiCoreV1Taint.ts";
import { IoK8sApiCoreV1Toleration } from "../models/IoK8sApiCoreV1Toleration.ts";
import { IoK8sApiCoreV1TopologySelectorLabelRequirement } from "../models/IoK8sApiCoreV1TopologySelectorLabelRequirement.ts";
import { IoK8sApiCoreV1TopologySelectorTerm } from "../models/IoK8sApiCoreV1TopologySelectorTerm.ts";
import { IoK8sApiCoreV1TopologySpreadConstraint } from "../models/IoK8sApiCoreV1TopologySpreadConstraint.ts";
import { IoK8sApiCoreV1TypedLocalObjectReference } from "../models/IoK8sApiCoreV1TypedLocalObjectReference.ts";
import { IoK8sApiCoreV1Volume } from "../models/IoK8sApiCoreV1Volume.ts";
import { IoK8sApiCoreV1VolumeDevice } from "../models/IoK8sApiCoreV1VolumeDevice.ts";
import { IoK8sApiCoreV1VolumeMount } from "../models/IoK8sApiCoreV1VolumeMount.ts";
import { IoK8sApiCoreV1VolumeNodeAffinity } from "../models/IoK8sApiCoreV1VolumeNodeAffinity.ts";
import { IoK8sApiCoreV1VolumeProjection } from "../models/IoK8sApiCoreV1VolumeProjection.ts";
import { IoK8sApiCoreV1VsphereVirtualDiskVolumeSource } from "../models/IoK8sApiCoreV1VsphereVirtualDiskVolumeSource.ts";
import { IoK8sApiCoreV1WeightedPodAffinityTerm } from "../models/IoK8sApiCoreV1WeightedPodAffinityTerm.ts";
import { IoK8sApiCoreV1WindowsSecurityContextOptions } from "../models/IoK8sApiCoreV1WindowsSecurityContextOptions.ts";
import { IoK8sApiDiscoveryV1beta1Endpoint } from "../models/IoK8sApiDiscoveryV1beta1Endpoint.ts";
import { IoK8sApiDiscoveryV1beta1EndpointConditions } from "../models/IoK8sApiDiscoveryV1beta1EndpointConditions.ts";
import { IoK8sApiDiscoveryV1beta1EndpointPort } from "../models/IoK8sApiDiscoveryV1beta1EndpointPort.ts";
import { IoK8sApiDiscoveryV1beta1EndpointSlice } from "../models/IoK8sApiDiscoveryV1beta1EndpointSlice.ts";
import { IoK8sApiDiscoveryV1beta1EndpointSliceList } from "../models/IoK8sApiDiscoveryV1beta1EndpointSliceList.ts";
import { IoK8sApiEventsV1Event } from "../models/IoK8sApiEventsV1Event.ts";
import { IoK8sApiEventsV1EventList } from "../models/IoK8sApiEventsV1EventList.ts";
import { IoK8sApiEventsV1EventSeries } from "../models/IoK8sApiEventsV1EventSeries.ts";
import { IoK8sApiEventsV1beta1Event } from "../models/IoK8sApiEventsV1beta1Event.ts";
import { IoK8sApiEventsV1beta1EventList } from "../models/IoK8sApiEventsV1beta1EventList.ts";
import { IoK8sApiEventsV1beta1EventSeries } from "../models/IoK8sApiEventsV1beta1EventSeries.ts";
import { IoK8sApiExtensionsV1beta1HTTPIngressPath } from "../models/IoK8sApiExtensionsV1beta1HTTPIngressPath.ts";
import { IoK8sApiExtensionsV1beta1HTTPIngressRuleValue } from "../models/IoK8sApiExtensionsV1beta1HTTPIngressRuleValue.ts";
import { IoK8sApiExtensionsV1beta1Ingress } from "../models/IoK8sApiExtensionsV1beta1Ingress.ts";
import { IoK8sApiExtensionsV1beta1IngressBackend } from "../models/IoK8sApiExtensionsV1beta1IngressBackend.ts";
import { IoK8sApiExtensionsV1beta1IngressList } from "../models/IoK8sApiExtensionsV1beta1IngressList.ts";
import { IoK8sApiExtensionsV1beta1IngressRule } from "../models/IoK8sApiExtensionsV1beta1IngressRule.ts";
import { IoK8sApiExtensionsV1beta1IngressSpec } from "../models/IoK8sApiExtensionsV1beta1IngressSpec.ts";
import { IoK8sApiExtensionsV1beta1IngressStatus } from "../models/IoK8sApiExtensionsV1beta1IngressStatus.ts";
import { IoK8sApiExtensionsV1beta1IngressTLS } from "../models/IoK8sApiExtensionsV1beta1IngressTLS.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowDistinguisherMethod } from "../models/IoK8sApiFlowcontrolV1alpha1FlowDistinguisherMethod.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowSchema } from "../models/IoK8sApiFlowcontrolV1alpha1FlowSchema.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowSchemaCondition } from "../models/IoK8sApiFlowcontrolV1alpha1FlowSchemaCondition.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowSchemaList } from "../models/IoK8sApiFlowcontrolV1alpha1FlowSchemaList.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowSchemaSpec } from "../models/IoK8sApiFlowcontrolV1alpha1FlowSchemaSpec.ts";
import { IoK8sApiFlowcontrolV1alpha1FlowSchemaStatus } from "../models/IoK8sApiFlowcontrolV1alpha1FlowSchemaStatus.ts";
import { IoK8sApiFlowcontrolV1alpha1GroupSubject } from "../models/IoK8sApiFlowcontrolV1alpha1GroupSubject.ts";
import { IoK8sApiFlowcontrolV1alpha1LimitResponse } from "../models/IoK8sApiFlowcontrolV1alpha1LimitResponse.ts";
import { IoK8sApiFlowcontrolV1alpha1LimitedPriorityLevelConfiguration } from "../models/IoK8sApiFlowcontrolV1alpha1LimitedPriorityLevelConfiguration.ts";
import { IoK8sApiFlowcontrolV1alpha1NonResourcePolicyRule } from "../models/IoK8sApiFlowcontrolV1alpha1NonResourcePolicyRule.ts";
import { IoK8sApiFlowcontrolV1alpha1PolicyRulesWithSubjects } from "../models/IoK8sApiFlowcontrolV1alpha1PolicyRulesWithSubjects.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationCondition } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationCondition.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationList } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationList.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationReference } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationReference.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationSpec } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationSpec.ts";
import { IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationStatus } from "../models/IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationStatus.ts";
import { IoK8sApiFlowcontrolV1alpha1QueuingConfiguration } from "../models/IoK8sApiFlowcontrolV1alpha1QueuingConfiguration.ts";
import { IoK8sApiFlowcontrolV1alpha1ResourcePolicyRule } from "../models/IoK8sApiFlowcontrolV1alpha1ResourcePolicyRule.ts";
import { IoK8sApiFlowcontrolV1alpha1ServiceAccountSubject } from "../models/IoK8sApiFlowcontrolV1alpha1ServiceAccountSubject.ts";
import { IoK8sApiFlowcontrolV1alpha1Subject } from "../models/IoK8sApiFlowcontrolV1alpha1Subject.ts";
import { IoK8sApiFlowcontrolV1alpha1UserSubject } from "../models/IoK8sApiFlowcontrolV1alpha1UserSubject.ts";
import { IoK8sApiNetworkingV1HTTPIngressPath } from "../models/IoK8sApiNetworkingV1HTTPIngressPath.ts";
import { IoK8sApiNetworkingV1HTTPIngressRuleValue } from "../models/IoK8sApiNetworkingV1HTTPIngressRuleValue.ts";
import { IoK8sApiNetworkingV1IPBlock } from "../models/IoK8sApiNetworkingV1IPBlock.ts";
import { IoK8sApiNetworkingV1Ingress } from "../models/IoK8sApiNetworkingV1Ingress.ts";
import { IoK8sApiNetworkingV1IngressBackend } from "../models/IoK8sApiNetworkingV1IngressBackend.ts";
import { IoK8sApiNetworkingV1IngressClass } from "../models/IoK8sApiNetworkingV1IngressClass.ts";
import { IoK8sApiNetworkingV1IngressClassList } from "../models/IoK8sApiNetworkingV1IngressClassList.ts";
import { IoK8sApiNetworkingV1IngressClassSpec } from "../models/IoK8sApiNetworkingV1IngressClassSpec.ts";
import { IoK8sApiNetworkingV1IngressList } from "../models/IoK8sApiNetworkingV1IngressList.ts";
import { IoK8sApiNetworkingV1IngressRule } from "../models/IoK8sApiNetworkingV1IngressRule.ts";
import { IoK8sApiNetworkingV1IngressServiceBackend } from "../models/IoK8sApiNetworkingV1IngressServiceBackend.ts";
import { IoK8sApiNetworkingV1IngressSpec } from "../models/IoK8sApiNetworkingV1IngressSpec.ts";
import { IoK8sApiNetworkingV1IngressStatus } from "../models/IoK8sApiNetworkingV1IngressStatus.ts";
import { IoK8sApiNetworkingV1IngressTLS } from "../models/IoK8sApiNetworkingV1IngressTLS.ts";
import { IoK8sApiNetworkingV1NetworkPolicy } from "../models/IoK8sApiNetworkingV1NetworkPolicy.ts";
import { IoK8sApiNetworkingV1NetworkPolicyEgressRule } from "../models/IoK8sApiNetworkingV1NetworkPolicyEgressRule.ts";
import { IoK8sApiNetworkingV1NetworkPolicyIngressRule } from "../models/IoK8sApiNetworkingV1NetworkPolicyIngressRule.ts";
import { IoK8sApiNetworkingV1NetworkPolicyList } from "../models/IoK8sApiNetworkingV1NetworkPolicyList.ts";
import { IoK8sApiNetworkingV1NetworkPolicyPeer } from "../models/IoK8sApiNetworkingV1NetworkPolicyPeer.ts";
import { IoK8sApiNetworkingV1NetworkPolicyPort } from "../models/IoK8sApiNetworkingV1NetworkPolicyPort.ts";
import { IoK8sApiNetworkingV1NetworkPolicySpec } from "../models/IoK8sApiNetworkingV1NetworkPolicySpec.ts";
import { IoK8sApiNetworkingV1ServiceBackendPort } from "../models/IoK8sApiNetworkingV1ServiceBackendPort.ts";
import { IoK8sApiNetworkingV1beta1HTTPIngressPath } from "../models/IoK8sApiNetworkingV1beta1HTTPIngressPath.ts";
import { IoK8sApiNetworkingV1beta1HTTPIngressRuleValue } from "../models/IoK8sApiNetworkingV1beta1HTTPIngressRuleValue.ts";
import { IoK8sApiNetworkingV1beta1Ingress } from "../models/IoK8sApiNetworkingV1beta1Ingress.ts";
import { IoK8sApiNetworkingV1beta1IngressBackend } from "../models/IoK8sApiNetworkingV1beta1IngressBackend.ts";
import { IoK8sApiNetworkingV1beta1IngressClass } from "../models/IoK8sApiNetworkingV1beta1IngressClass.ts";
import { IoK8sApiNetworkingV1beta1IngressClassList } from "../models/IoK8sApiNetworkingV1beta1IngressClassList.ts";
import { IoK8sApiNetworkingV1beta1IngressClassSpec } from "../models/IoK8sApiNetworkingV1beta1IngressClassSpec.ts";
import { IoK8sApiNetworkingV1beta1IngressList } from "../models/IoK8sApiNetworkingV1beta1IngressList.ts";
import { IoK8sApiNetworkingV1beta1IngressRule } from "../models/IoK8sApiNetworkingV1beta1IngressRule.ts";
import { IoK8sApiNetworkingV1beta1IngressSpec } from "../models/IoK8sApiNetworkingV1beta1IngressSpec.ts";
import { IoK8sApiNetworkingV1beta1IngressStatus } from "../models/IoK8sApiNetworkingV1beta1IngressStatus.ts";
import { IoK8sApiNetworkingV1beta1IngressTLS } from "../models/IoK8sApiNetworkingV1beta1IngressTLS.ts";
import { IoK8sApiNodeV1alpha1Overhead } from "../models/IoK8sApiNodeV1alpha1Overhead.ts";
import { IoK8sApiNodeV1alpha1RuntimeClass } from "../models/IoK8sApiNodeV1alpha1RuntimeClass.ts";
import { IoK8sApiNodeV1alpha1RuntimeClassList } from "../models/IoK8sApiNodeV1alpha1RuntimeClassList.ts";
import { IoK8sApiNodeV1alpha1RuntimeClassSpec } from "../models/IoK8sApiNodeV1alpha1RuntimeClassSpec.ts";
import { IoK8sApiNodeV1alpha1Scheduling } from "../models/IoK8sApiNodeV1alpha1Scheduling.ts";
import { IoK8sApiNodeV1beta1Overhead } from "../models/IoK8sApiNodeV1beta1Overhead.ts";
import { IoK8sApiNodeV1beta1RuntimeClass } from "../models/IoK8sApiNodeV1beta1RuntimeClass.ts";
import { IoK8sApiNodeV1beta1RuntimeClassList } from "../models/IoK8sApiNodeV1beta1RuntimeClassList.ts";
import { IoK8sApiNodeV1beta1Scheduling } from "../models/IoK8sApiNodeV1beta1Scheduling.ts";
import { IoK8sApiPolicyV1beta1AllowedCSIDriver } from "../models/IoK8sApiPolicyV1beta1AllowedCSIDriver.ts";
import { IoK8sApiPolicyV1beta1AllowedFlexVolume } from "../models/IoK8sApiPolicyV1beta1AllowedFlexVolume.ts";
import { IoK8sApiPolicyV1beta1AllowedHostPath } from "../models/IoK8sApiPolicyV1beta1AllowedHostPath.ts";
import { IoK8sApiPolicyV1beta1Eviction } from "../models/IoK8sApiPolicyV1beta1Eviction.ts";
import { IoK8sApiPolicyV1beta1FSGroupStrategyOptions } from "../models/IoK8sApiPolicyV1beta1FSGroupStrategyOptions.ts";
import { IoK8sApiPolicyV1beta1HostPortRange } from "../models/IoK8sApiPolicyV1beta1HostPortRange.ts";
import { IoK8sApiPolicyV1beta1IDRange } from "../models/IoK8sApiPolicyV1beta1IDRange.ts";
import { IoK8sApiPolicyV1beta1PodDisruptionBudget } from "../models/IoK8sApiPolicyV1beta1PodDisruptionBudget.ts";
import { IoK8sApiPolicyV1beta1PodDisruptionBudgetList } from "../models/IoK8sApiPolicyV1beta1PodDisruptionBudgetList.ts";
import { IoK8sApiPolicyV1beta1PodDisruptionBudgetSpec } from "../models/IoK8sApiPolicyV1beta1PodDisruptionBudgetSpec.ts";
import { IoK8sApiPolicyV1beta1PodDisruptionBudgetStatus } from "../models/IoK8sApiPolicyV1beta1PodDisruptionBudgetStatus.ts";
import { IoK8sApiPolicyV1beta1PodSecurityPolicy } from "../models/IoK8sApiPolicyV1beta1PodSecurityPolicy.ts";
import { IoK8sApiPolicyV1beta1PodSecurityPolicyList } from "../models/IoK8sApiPolicyV1beta1PodSecurityPolicyList.ts";
import { IoK8sApiPolicyV1beta1PodSecurityPolicySpec } from "../models/IoK8sApiPolicyV1beta1PodSecurityPolicySpec.ts";
import { IoK8sApiPolicyV1beta1RunAsGroupStrategyOptions } from "../models/IoK8sApiPolicyV1beta1RunAsGroupStrategyOptions.ts";
import { IoK8sApiPolicyV1beta1RunAsUserStrategyOptions } from "../models/IoK8sApiPolicyV1beta1RunAsUserStrategyOptions.ts";
import { IoK8sApiPolicyV1beta1RuntimeClassStrategyOptions } from "../models/IoK8sApiPolicyV1beta1RuntimeClassStrategyOptions.ts";
import { IoK8sApiPolicyV1beta1SELinuxStrategyOptions } from "../models/IoK8sApiPolicyV1beta1SELinuxStrategyOptions.ts";
import { IoK8sApiPolicyV1beta1SupplementalGroupsStrategyOptions } from "../models/IoK8sApiPolicyV1beta1SupplementalGroupsStrategyOptions.ts";
import { IoK8sApiRbacV1AggregationRule } from "../models/IoK8sApiRbacV1AggregationRule.ts";
import { IoK8sApiRbacV1ClusterRole } from "../models/IoK8sApiRbacV1ClusterRole.ts";
import { IoK8sApiRbacV1ClusterRoleBinding } from "../models/IoK8sApiRbacV1ClusterRoleBinding.ts";
import { IoK8sApiRbacV1ClusterRoleBindingList } from "../models/IoK8sApiRbacV1ClusterRoleBindingList.ts";
import { IoK8sApiRbacV1ClusterRoleList } from "../models/IoK8sApiRbacV1ClusterRoleList.ts";
import { IoK8sApiRbacV1PolicyRule } from "../models/IoK8sApiRbacV1PolicyRule.ts";
import { IoK8sApiRbacV1Role } from "../models/IoK8sApiRbacV1Role.ts";
import { IoK8sApiRbacV1RoleBinding } from "../models/IoK8sApiRbacV1RoleBinding.ts";
import { IoK8sApiRbacV1RoleBindingList } from "../models/IoK8sApiRbacV1RoleBindingList.ts";
import { IoK8sApiRbacV1RoleList } from "../models/IoK8sApiRbacV1RoleList.ts";
import { IoK8sApiRbacV1RoleRef } from "../models/IoK8sApiRbacV1RoleRef.ts";
import { IoK8sApiRbacV1Subject } from "../models/IoK8sApiRbacV1Subject.ts";
import { IoK8sApiRbacV1alpha1AggregationRule } from "../models/IoK8sApiRbacV1alpha1AggregationRule.ts";
import { IoK8sApiRbacV1alpha1ClusterRole } from "../models/IoK8sApiRbacV1alpha1ClusterRole.ts";
import { IoK8sApiRbacV1alpha1ClusterRoleBinding } from "../models/IoK8sApiRbacV1alpha1ClusterRoleBinding.ts";
import { IoK8sApiRbacV1alpha1ClusterRoleBindingList } from "../models/IoK8sApiRbacV1alpha1ClusterRoleBindingList.ts";
import { IoK8sApiRbacV1alpha1ClusterRoleList } from "../models/IoK8sApiRbacV1alpha1ClusterRoleList.ts";
import { IoK8sApiRbacV1alpha1PolicyRule } from "../models/IoK8sApiRbacV1alpha1PolicyRule.ts";
import { IoK8sApiRbacV1alpha1Role } from "../models/IoK8sApiRbacV1alpha1Role.ts";
import { IoK8sApiRbacV1alpha1RoleBinding } from "../models/IoK8sApiRbacV1alpha1RoleBinding.ts";
import { IoK8sApiRbacV1alpha1RoleBindingList } from "../models/IoK8sApiRbacV1alpha1RoleBindingList.ts";
import { IoK8sApiRbacV1alpha1RoleList } from "../models/IoK8sApiRbacV1alpha1RoleList.ts";
import { IoK8sApiRbacV1alpha1RoleRef } from "../models/IoK8sApiRbacV1alpha1RoleRef.ts";
import { IoK8sApiRbacV1alpha1Subject } from "../models/IoK8sApiRbacV1alpha1Subject.ts";
import { IoK8sApiRbacV1beta1AggregationRule } from "../models/IoK8sApiRbacV1beta1AggregationRule.ts";
import { IoK8sApiRbacV1beta1ClusterRole } from "../models/IoK8sApiRbacV1beta1ClusterRole.ts";
import { IoK8sApiRbacV1beta1ClusterRoleBinding } from "../models/IoK8sApiRbacV1beta1ClusterRoleBinding.ts";
import { IoK8sApiRbacV1beta1ClusterRoleBindingList } from "../models/IoK8sApiRbacV1beta1ClusterRoleBindingList.ts";
import { IoK8sApiRbacV1beta1ClusterRoleList } from "../models/IoK8sApiRbacV1beta1ClusterRoleList.ts";
import { IoK8sApiRbacV1beta1PolicyRule } from "../models/IoK8sApiRbacV1beta1PolicyRule.ts";
import { IoK8sApiRbacV1beta1Role } from "../models/IoK8sApiRbacV1beta1Role.ts";
import { IoK8sApiRbacV1beta1RoleBinding } from "../models/IoK8sApiRbacV1beta1RoleBinding.ts";
import { IoK8sApiRbacV1beta1RoleBindingList } from "../models/IoK8sApiRbacV1beta1RoleBindingList.ts";
import { IoK8sApiRbacV1beta1RoleList } from "../models/IoK8sApiRbacV1beta1RoleList.ts";
import { IoK8sApiRbacV1beta1RoleRef } from "../models/IoK8sApiRbacV1beta1RoleRef.ts";
import { IoK8sApiRbacV1beta1Subject } from "../models/IoK8sApiRbacV1beta1Subject.ts";
import { IoK8sApiSchedulingV1PriorityClass } from "../models/IoK8sApiSchedulingV1PriorityClass.ts";
import { IoK8sApiSchedulingV1PriorityClassList } from "../models/IoK8sApiSchedulingV1PriorityClassList.ts";
import { IoK8sApiSchedulingV1alpha1PriorityClass } from "../models/IoK8sApiSchedulingV1alpha1PriorityClass.ts";
import { IoK8sApiSchedulingV1alpha1PriorityClassList } from "../models/IoK8sApiSchedulingV1alpha1PriorityClassList.ts";
import { IoK8sApiSchedulingV1beta1PriorityClass } from "../models/IoK8sApiSchedulingV1beta1PriorityClass.ts";
import { IoK8sApiSchedulingV1beta1PriorityClassList } from "../models/IoK8sApiSchedulingV1beta1PriorityClassList.ts";
import { IoK8sApiSettingsV1alpha1PodPreset } from "../models/IoK8sApiSettingsV1alpha1PodPreset.ts";
import { IoK8sApiSettingsV1alpha1PodPresetList } from "../models/IoK8sApiSettingsV1alpha1PodPresetList.ts";
import { IoK8sApiSettingsV1alpha1PodPresetSpec } from "../models/IoK8sApiSettingsV1alpha1PodPresetSpec.ts";
import { IoK8sApiStorageV1CSIDriver } from "../models/IoK8sApiStorageV1CSIDriver.ts";
import { IoK8sApiStorageV1CSIDriverList } from "../models/IoK8sApiStorageV1CSIDriverList.ts";
import { IoK8sApiStorageV1CSIDriverSpec } from "../models/IoK8sApiStorageV1CSIDriverSpec.ts";
import { IoK8sApiStorageV1CSINode } from "../models/IoK8sApiStorageV1CSINode.ts";
import { IoK8sApiStorageV1CSINodeDriver } from "../models/IoK8sApiStorageV1CSINodeDriver.ts";
import { IoK8sApiStorageV1CSINodeList } from "../models/IoK8sApiStorageV1CSINodeList.ts";
import { IoK8sApiStorageV1CSINodeSpec } from "../models/IoK8sApiStorageV1CSINodeSpec.ts";
import { IoK8sApiStorageV1StorageClass } from "../models/IoK8sApiStorageV1StorageClass.ts";
import { IoK8sApiStorageV1StorageClassList } from "../models/IoK8sApiStorageV1StorageClassList.ts";
import { IoK8sApiStorageV1VolumeAttachment } from "../models/IoK8sApiStorageV1VolumeAttachment.ts";
import { IoK8sApiStorageV1VolumeAttachmentList } from "../models/IoK8sApiStorageV1VolumeAttachmentList.ts";
import { IoK8sApiStorageV1VolumeAttachmentSource } from "../models/IoK8sApiStorageV1VolumeAttachmentSource.ts";
import { IoK8sApiStorageV1VolumeAttachmentSpec } from "../models/IoK8sApiStorageV1VolumeAttachmentSpec.ts";
import { IoK8sApiStorageV1VolumeAttachmentStatus } from "../models/IoK8sApiStorageV1VolumeAttachmentStatus.ts";
import { IoK8sApiStorageV1VolumeError } from "../models/IoK8sApiStorageV1VolumeError.ts";
import { IoK8sApiStorageV1VolumeNodeResources } from "../models/IoK8sApiStorageV1VolumeNodeResources.ts";
import { IoK8sApiStorageV1alpha1VolumeAttachment } from "../models/IoK8sApiStorageV1alpha1VolumeAttachment.ts";
import { IoK8sApiStorageV1alpha1VolumeAttachmentList } from "../models/IoK8sApiStorageV1alpha1VolumeAttachmentList.ts";
import { IoK8sApiStorageV1alpha1VolumeAttachmentSource } from "../models/IoK8sApiStorageV1alpha1VolumeAttachmentSource.ts";
import { IoK8sApiStorageV1alpha1VolumeAttachmentSpec } from "../models/IoK8sApiStorageV1alpha1VolumeAttachmentSpec.ts";
import { IoK8sApiStorageV1alpha1VolumeAttachmentStatus } from "../models/IoK8sApiStorageV1alpha1VolumeAttachmentStatus.ts";
import { IoK8sApiStorageV1alpha1VolumeError } from "../models/IoK8sApiStorageV1alpha1VolumeError.ts";
import { IoK8sApiStorageV1beta1CSIDriver } from "../models/IoK8sApiStorageV1beta1CSIDriver.ts";
import { IoK8sApiStorageV1beta1CSIDriverList } from "../models/IoK8sApiStorageV1beta1CSIDriverList.ts";
import { IoK8sApiStorageV1beta1CSIDriverSpec } from "../models/IoK8sApiStorageV1beta1CSIDriverSpec.ts";
import { IoK8sApiStorageV1beta1CSINode } from "../models/IoK8sApiStorageV1beta1CSINode.ts";
import { IoK8sApiStorageV1beta1CSINodeDriver } from "../models/IoK8sApiStorageV1beta1CSINodeDriver.ts";
import { IoK8sApiStorageV1beta1CSINodeList } from "../models/IoK8sApiStorageV1beta1CSINodeList.ts";
import { IoK8sApiStorageV1beta1CSINodeSpec } from "../models/IoK8sApiStorageV1beta1CSINodeSpec.ts";
import { IoK8sApiStorageV1beta1StorageClass } from "../models/IoK8sApiStorageV1beta1StorageClass.ts";
import { IoK8sApiStorageV1beta1StorageClassList } from "../models/IoK8sApiStorageV1beta1StorageClassList.ts";
import { IoK8sApiStorageV1beta1VolumeAttachment } from "../models/IoK8sApiStorageV1beta1VolumeAttachment.ts";
import { IoK8sApiStorageV1beta1VolumeAttachmentList } from "../models/IoK8sApiStorageV1beta1VolumeAttachmentList.ts";
import { IoK8sApiStorageV1beta1VolumeAttachmentSource } from "../models/IoK8sApiStorageV1beta1VolumeAttachmentSource.ts";
import { IoK8sApiStorageV1beta1VolumeAttachmentSpec } from "../models/IoK8sApiStorageV1beta1VolumeAttachmentSpec.ts";
import { IoK8sApiStorageV1beta1VolumeAttachmentStatus } from "../models/IoK8sApiStorageV1beta1VolumeAttachmentStatus.ts";
import { IoK8sApiStorageV1beta1VolumeError } from "../models/IoK8sApiStorageV1beta1VolumeError.ts";
import { IoK8sApiStorageV1beta1VolumeNodeResources } from "../models/IoK8sApiStorageV1beta1VolumeNodeResources.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceColumnDefinition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceColumnDefinition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceConversion } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceConversion.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionCondition } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionCondition.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionList } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionList.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionNames } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionNames.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionSpec } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionSpec.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionStatus } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionStatus.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionVersion } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionVersion.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceSubresourceScale } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceSubresourceScale.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceSubresources } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceSubresources.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceValidation } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceValidation.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1ExternalDocumentation } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1ExternalDocumentation.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1JSONSchemaProps } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1JSONSchemaProps.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1ServiceReference } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1ServiceReference.ts";
import { IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1WebhookClientConfig } from "../models/IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1WebhookClientConfig.ts";
import { IoK8sApimachineryPkgApisMetaV1APIGroup } from "../models/IoK8sApimachineryPkgApisMetaV1APIGroup.ts";
import { IoK8sApimachineryPkgApisMetaV1APIGroupList } from "../models/IoK8sApimachineryPkgApisMetaV1APIGroupList.ts";
import { IoK8sApimachineryPkgApisMetaV1APIResource } from "../models/IoK8sApimachineryPkgApisMetaV1APIResource.ts";
import { IoK8sApimachineryPkgApisMetaV1APIResourceList } from "../models/IoK8sApimachineryPkgApisMetaV1APIResourceList.ts";
import { IoK8sApimachineryPkgApisMetaV1APIVersions } from "../models/IoK8sApimachineryPkgApisMetaV1APIVersions.ts";
import { IoK8sApimachineryPkgApisMetaV1DeleteOptions } from "../models/IoK8sApimachineryPkgApisMetaV1DeleteOptions.ts";
import { IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery } from "../models/IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery.ts";
import { IoK8sApimachineryPkgApisMetaV1LabelSelector } from "../models/IoK8sApimachineryPkgApisMetaV1LabelSelector.ts";
import { IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement } from "../models/IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement.ts";
import { IoK8sApimachineryPkgApisMetaV1ListMeta } from "../models/IoK8sApimachineryPkgApisMetaV1ListMeta.ts";
import { IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry } from "../models/IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry.ts";
import { IoK8sApimachineryPkgApisMetaV1ObjectMeta } from "../models/IoK8sApimachineryPkgApisMetaV1ObjectMeta.ts";
import { IoK8sApimachineryPkgApisMetaV1OwnerReference } from "../models/IoK8sApimachineryPkgApisMetaV1OwnerReference.ts";
import { IoK8sApimachineryPkgApisMetaV1Preconditions } from "../models/IoK8sApimachineryPkgApisMetaV1Preconditions.ts";
import { IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR } from "../models/IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR.ts";
import { IoK8sApimachineryPkgApisMetaV1Status } from "../models/IoK8sApimachineryPkgApisMetaV1Status.ts";
import { IoK8sApimachineryPkgApisMetaV1StatusCause } from "../models/IoK8sApimachineryPkgApisMetaV1StatusCause.ts";
import { IoK8sApimachineryPkgApisMetaV1StatusDetails } from "../models/IoK8sApimachineryPkgApisMetaV1StatusDetails.ts";
import { IoK8sApimachineryPkgApisMetaV1WatchEvent } from "../models/IoK8sApimachineryPkgApisMetaV1WatchEvent.ts";
import { IoK8sApimachineryPkgVersionInfo } from "../models/IoK8sApimachineryPkgVersionInfo.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1APIService } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1APIService.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceCondition } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceCondition.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceList } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceList.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceSpec } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceSpec.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceStatus } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceStatus.ts";
import { IoK8sKubeAggregatorPkgApisApiregistrationV1beta1ServiceReference } from "../models/IoK8sKubeAggregatorPkgApisApiregistrationV1beta1ServiceReference.ts";

import { ObservableAdmissionregistrationApi } from "./ObservableAPI.ts";
import {
  AdmissionregistrationApiRequestFactory,
  AdmissionregistrationApiResponseProcessor,
} from "../apis/AdmissionregistrationApi.ts";

export interface AdmissionregistrationApiGetAdmissionregistrationAPIGroupRequest {
}

export class ObjectAdmissionregistrationApi {
  private api: ObservableAdmissionregistrationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: AdmissionregistrationApiRequestFactory,
    responseProcessor?: AdmissionregistrationApiResponseProcessor,
  ) {
    this.api = new ObservableAdmissionregistrationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getAdmissionregistrationAPIGroup(
    param: AdmissionregistrationApiGetAdmissionregistrationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getAdmissionregistrationAPIGroup(options).toPromise();
  }
}

import { ObservableAdmissionregistrationV1Api } from "./ObservableAPI.ts";
import {
  AdmissionregistrationV1ApiRequestFactory,
  AdmissionregistrationV1ApiResponseProcessor,
} from "../apis/AdmissionregistrationV1Api.ts";

export interface AdmissionregistrationV1ApiCreateAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1MutatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1MutatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1ApiCreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApicreateAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1ApiDeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1ApiDeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1ApiDeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1MutatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1ApiDeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1ApiGetAdmissionregistrationV1APIResourcesRequest {
}

export interface AdmissionregistrationV1ApiListAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1MutatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1ApiListAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1ApiPatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  force?: boolean;
}

export interface AdmissionregistrationV1ApiPatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  force?: boolean;
}

export interface AdmissionregistrationV1ApiReadAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1MutatingWebhookConfiguration
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1MutatingWebhookConfiguration
     */
  _export?: boolean;
}

export interface AdmissionregistrationV1ApiReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1ApireadAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  _export?: boolean;
}

export interface AdmissionregistrationV1ApiReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1MutatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1MutatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1ApiReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1ApiWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1ApiWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1MutatingWebhookConfigurationList
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1ApiWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1ApiWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1ApiwatchAdmissionregistrationV1ValidatingWebhookConfigurationList
     */
  watch?: boolean;
}

export class ObjectAdmissionregistrationV1Api {
  private api: ObservableAdmissionregistrationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AdmissionregistrationV1ApiRequestFactory,
    responseProcessor?: AdmissionregistrationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableAdmissionregistrationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
  public createAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiCreateAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration> {
    return this.api.createAdmissionregistrationV1MutatingWebhookConfiguration(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
  public createAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiCreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration> {
    return this.api.createAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiDeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiDeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiDeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAdmissionregistrationV1MutatingWebhookConfiguration(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiDeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAdmissionregistrationV1APIResources(
    param:
      AdmissionregistrationV1ApiGetAdmissionregistrationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAdmissionregistrationV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
  public listAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiListAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList> {
    return this.api.listAdmissionregistrationV1MutatingWebhookConfiguration(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
  public listAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiListAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList
  > {
    return this.api.listAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public patchAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiPatchAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration> {
    return this.api.patchAdmissionregistrationV1MutatingWebhookConfiguration(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public patchAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiPatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration> {
    return this.api.patchAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public readAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiReadAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration> {
    return this.api.readAdmissionregistrationV1MutatingWebhookConfiguration(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public readAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration> {
    return this.api.readAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public replaceAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration> {
    return this.api.replaceAdmissionregistrationV1MutatingWebhookConfiguration(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public replaceAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration> {
    return this.api
      .replaceAdmissionregistrationV1ValidatingWebhookConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAdmissionregistrationV1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAdmissionregistrationV1MutatingWebhookConfiguration(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAdmissionregistrationV1MutatingWebhookConfigurationList(
    param:
      AdmissionregistrationV1ApiWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1MutatingWebhookConfigurationList(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAdmissionregistrationV1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1ApiWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAdmissionregistrationV1ValidatingWebhookConfiguration(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAdmissionregistrationV1ValidatingWebhookConfigurationList(
    param:
      AdmissionregistrationV1ApiWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1ValidatingWebhookConfigurationList(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }
}

import { ObservableAdmissionregistrationV1beta1Api } from "./ObservableAPI.ts";
import {
  AdmissionregistrationV1beta1ApiRequestFactory,
  AdmissionregistrationV1beta1ApiResponseProcessor,
} from "../apis/AdmissionregistrationV1beta1Api.ts";

export interface AdmissionregistrationV1beta1ApiCreateAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1beta1ApiCreateAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AdmissionregistrationV1beta1ApiGetAdmissionregistrationV1beta1APIResourcesRequest {
}

export interface AdmissionregistrationV1beta1ApiListAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1beta1ApiListAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1beta1ApiPatchAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  force?: boolean;
}

export interface AdmissionregistrationV1beta1ApiPatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApipatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  force?: boolean;
}

export interface AdmissionregistrationV1beta1ApiReadAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  _export?: boolean;
}

export interface AdmissionregistrationV1beta1ApiReadAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApireadAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  _export?: boolean;
}

export interface AdmissionregistrationV1beta1ApiReplaceAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1beta1ApiReplaceAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * 
     * @type IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  body: IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  fieldManager?: string;
}

export interface AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest {
  /**
     * name of the MutatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1MutatingWebhookConfigurationListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1MutatingWebhookConfigurationList
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest {
  /**
     * name of the ValidatingWebhookConfiguration
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfiguration
     */
  watch?: boolean;
}

export interface AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApiwatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
     */
  watch?: boolean;
}

export class ObjectAdmissionregistrationV1beta1Api {
  private api: ObservableAdmissionregistrationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AdmissionregistrationV1beta1ApiRequestFactory,
    responseProcessor?: AdmissionregistrationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableAdmissionregistrationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
  public createAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiCreateAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration> {
    return this.api
      .createAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
  public createAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiCreateAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
  > {
    return this.api
      .createAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.name,
        param.pretty,
        param.dryRun,
        param.gracePeriodSeconds,
        param.orphanDependents,
        param.propagationPolicy,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
  public deleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiDeleteAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.name,
        param.pretty,
        param.dryRun,
        param.gracePeriodSeconds,
        param.orphanDependents,
        param.propagationPolicy,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAdmissionregistrationV1beta1APIResources(
    param:
      AdmissionregistrationV1beta1ApiGetAdmissionregistrationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAdmissionregistrationV1beta1APIResources(options)
      .toPromise();
  }

  /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
  public listAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiListAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfigurationList
  > {
    return this.api
      .listAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.pretty,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
  public listAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiListAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfigurationList
  > {
    return this.api
      .listAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.pretty,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public patchAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiPatchAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration> {
    return this.api
      .patchAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        param.force,
        options,
      ).toPromise();
  }

  /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public patchAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiPatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
  > {
    return this.api
      .patchAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        param.force,
        options,
      ).toPromise();
  }

  /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public readAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiReadAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration> {
    return this.api
      .readAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.name,
        param.pretty,
        param.exact,
        param._export,
        options,
      ).toPromise();
  }

  /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public readAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiReadAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
  > {
    return this.api
      .readAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.name,
        param.pretty,
        param.exact,
        param._export,
        options,
      ).toPromise();
  }

  /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
  public replaceAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiReplaceAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAdmissionregistrationV1beta1MutatingWebhookConfiguration> {
    return this.api
      .replaceAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
  public replaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiReplaceAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiAdmissionregistrationV1beta1ValidatingWebhookConfiguration
  > {
    return this.api
      .replaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAdmissionregistrationV1beta1MutatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1MutatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1beta1MutatingWebhookConfiguration(
        param.name,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAdmissionregistrationV1beta1MutatingWebhookConfigurationList(
    param:
      AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1MutatingWebhookConfigurationListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1beta1MutatingWebhookConfigurationList(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
    param:
      AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1beta1ValidatingWebhookConfiguration(
        param.name,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList(
    param:
      AdmissionregistrationV1beta1ApiWatchAdmissionregistrationV1beta1ValidatingWebhookConfigurationListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAdmissionregistrationV1beta1ValidatingWebhookConfigurationList(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }
}

import { ObservableApiextensionsApi } from "./ObservableAPI.ts";
import {
  ApiextensionsApiRequestFactory,
  ApiextensionsApiResponseProcessor,
} from "../apis/ApiextensionsApi.ts";

export interface ApiextensionsApiGetApiextensionsAPIGroupRequest {
}

export class ObjectApiextensionsApi {
  private api: ObservableApiextensionsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiextensionsApiRequestFactory,
    responseProcessor?: ApiextensionsApiResponseProcessor,
  ) {
    this.api = new ObservableApiextensionsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getApiextensionsAPIGroup(
    param: ApiextensionsApiGetApiextensionsAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getApiextensionsAPIGroup(options).toPromise();
  }
}

import { ObservableApiextensionsV1Api } from "./ObservableAPI.ts";
import {
  ApiextensionsV1ApiRequestFactory,
  ApiextensionsV1ApiResponseProcessor,
} from "../apis/ApiextensionsV1Api.ts";

export interface ApiextensionsV1ApiCreateApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
     * @memberof ApiextensionsV1ApicreateApiextensionsV1CustomResourceDefinition
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApicreateApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApicreateApiextensionsV1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApicreateApiextensionsV1CustomResourceDefinition
     */
  fieldManager?: string;
}

export interface ApiextensionsV1ApiDeleteApiextensionsV1CollectionCustomResourceDefinitionRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CollectionCustomResourceDefinition
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiextensionsV1ApiDeleteApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiextensionsV1ApideleteApiextensionsV1CustomResourceDefinition
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiextensionsV1ApiGetApiextensionsV1APIResourcesRequest {
}

export interface ApiextensionsV1ApiListApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1ApilistApiextensionsV1CustomResourceDefinition
     */
  watch?: boolean;
}

export interface ApiextensionsV1ApiPatchApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinition
     */
  force?: boolean;
}

export interface ApiextensionsV1ApiPatchApiextensionsV1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1ApipatchApiextensionsV1CustomResourceDefinitionStatus
     */
  force?: boolean;
}

export interface ApiextensionsV1ApiReadApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinition
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinition
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinition
     */
  _export?: boolean;
}

export interface ApiextensionsV1ApiReadApiextensionsV1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireadApiextensionsV1CustomResourceDefinitionStatus
     */
  pretty?: string;
}

export interface ApiextensionsV1ApiReplaceApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinition
     */
  name: string;
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinition
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinition
     */
  fieldManager?: string;
}

export interface ApiextensionsV1ApiReplaceApiextensionsV1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinitionStatus
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinitionStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinitionStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1ApireplaceApiextensionsV1CustomResourceDefinitionStatus
     */
  fieldManager?: string;
}

export interface ApiextensionsV1ApiWatchApiextensionsV1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinition
     */
  watch?: boolean;
}

export interface ApiextensionsV1ApiWatchApiextensionsV1CustomResourceDefinitionListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1ApiwatchApiextensionsV1CustomResourceDefinitionList
     */
  watch?: boolean;
}

export class ObjectApiextensionsV1Api {
  private api: ObservableApiextensionsV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiextensionsV1ApiRequestFactory,
    responseProcessor?: ApiextensionsV1ApiResponseProcessor,
  ) {
    this.api = new ObservableApiextensionsV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
  public createApiextensionsV1CustomResourceDefinition(
    param:
      ApiextensionsV1ApiCreateApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.createApiextensionsV1CustomResourceDefinition(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
  public deleteApiextensionsV1CollectionCustomResourceDefinition(
    param:
      ApiextensionsV1ApiDeleteApiextensionsV1CollectionCustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiextensionsV1CollectionCustomResourceDefinition(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
  public deleteApiextensionsV1CustomResourceDefinition(
    param:
      ApiextensionsV1ApiDeleteApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiextensionsV1CustomResourceDefinition(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getApiextensionsV1APIResources(
    param: ApiextensionsV1ApiGetApiextensionsV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getApiextensionsV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
  public listApiextensionsV1CustomResourceDefinition(
    param: ApiextensionsV1ApiListApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
  > {
    return this.api.listApiextensionsV1CustomResourceDefinition(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
  public patchApiextensionsV1CustomResourceDefinition(
    param:
      ApiextensionsV1ApiPatchApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.patchApiextensionsV1CustomResourceDefinition(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public patchApiextensionsV1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1ApiPatchApiextensionsV1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.patchApiextensionsV1CustomResourceDefinitionStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
  public readApiextensionsV1CustomResourceDefinition(
    param: ApiextensionsV1ApiReadApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.readApiextensionsV1CustomResourceDefinition(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public readApiextensionsV1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1ApiReadApiextensionsV1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.readApiextensionsV1CustomResourceDefinitionStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
  public replaceApiextensionsV1CustomResourceDefinition(
    param:
      ApiextensionsV1ApiReplaceApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.replaceApiextensionsV1CustomResourceDefinition(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public replaceApiextensionsV1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1ApiReplaceApiextensionsV1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
  > {
    return this.api.replaceApiextensionsV1CustomResourceDefinitionStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchApiextensionsV1CustomResourceDefinition(
    param:
      ApiextensionsV1ApiWatchApiextensionsV1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiextensionsV1CustomResourceDefinition(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchApiextensionsV1CustomResourceDefinitionList(
    param:
      ApiextensionsV1ApiWatchApiextensionsV1CustomResourceDefinitionListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiextensionsV1CustomResourceDefinitionList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableApiextensionsV1beta1Api } from "./ObservableAPI.ts";
import {
  ApiextensionsV1beta1ApiRequestFactory,
  ApiextensionsV1beta1ApiResponseProcessor,
} from "../apis/ApiextensionsV1beta1Api.ts";

export interface ApiextensionsV1beta1ApiCreateApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
     * @memberof ApiextensionsV1beta1ApicreateApiextensionsV1beta1CustomResourceDefinition
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApicreateApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApicreateApiextensionsV1beta1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1beta1ApicreateApiextensionsV1beta1CustomResourceDefinition
     */
  fieldManager?: string;
}

export interface ApiextensionsV1beta1ApiDeleteApiextensionsV1beta1CollectionCustomResourceDefinitionRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CollectionCustomResourceDefinition
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiextensionsV1beta1ApiDeleteApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiextensionsV1beta1ApideleteApiextensionsV1beta1CustomResourceDefinition
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiextensionsV1beta1ApiGetApiextensionsV1beta1APIResourcesRequest {
}

export interface ApiextensionsV1beta1ApiListApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApilistApiextensionsV1beta1CustomResourceDefinition
     */
  watch?: boolean;
}

export interface ApiextensionsV1beta1ApiPatchApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinition
     */
  force?: boolean;
}

export interface ApiextensionsV1beta1ApiPatchApiextensionsV1beta1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApipatchApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  force?: boolean;
}

export interface ApiextensionsV1beta1ApiReadApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinition
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinition
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinition
     */
  _export?: boolean;
}

export interface ApiextensionsV1beta1ApiReadApiextensionsV1beta1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApireadApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  pretty?: string;
}

export interface ApiextensionsV1beta1ApiReplaceApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinition
     */
  name: string;
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinition
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinition
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinition
     */
  fieldManager?: string;
}

export interface ApiextensionsV1beta1ApiReplaceApiextensionsV1beta1CustomResourceDefinitionStatusRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  body:
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiextensionsV1beta1ApireplaceApiextensionsV1beta1CustomResourceDefinitionStatus
     */
  fieldManager?: string;
}

export interface ApiextensionsV1beta1ApiWatchApiextensionsV1beta1CustomResourceDefinitionRequest {
  /**
     * name of the CustomResourceDefinition
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinition
     */
  watch?: boolean;
}

export interface ApiextensionsV1beta1ApiWatchApiextensionsV1beta1CustomResourceDefinitionListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiextensionsV1beta1ApiwatchApiextensionsV1beta1CustomResourceDefinitionList
     */
  watch?: boolean;
}

export class ObjectApiextensionsV1beta1Api {
  private api: ObservableApiextensionsV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiextensionsV1beta1ApiRequestFactory,
    responseProcessor?: ApiextensionsV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableApiextensionsV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
  public createApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiCreateApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.createApiextensionsV1beta1CustomResourceDefinition(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
  public deleteApiextensionsV1beta1CollectionCustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiDeleteApiextensionsV1beta1CollectionCustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteApiextensionsV1beta1CollectionCustomResourceDefinition(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
  public deleteApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiDeleteApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiextensionsV1beta1CustomResourceDefinition(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getApiextensionsV1beta1APIResources(
    param: ApiextensionsV1beta1ApiGetApiextensionsV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getApiextensionsV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
  public listApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiListApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinitionList
  > {
    return this.api.listApiextensionsV1beta1CustomResourceDefinition(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
  public patchApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiPatchApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.patchApiextensionsV1beta1CustomResourceDefinition(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public patchApiextensionsV1beta1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1beta1ApiPatchApiextensionsV1beta1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.patchApiextensionsV1beta1CustomResourceDefinitionStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
  public readApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiReadApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.readApiextensionsV1beta1CustomResourceDefinition(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public readApiextensionsV1beta1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1beta1ApiReadApiextensionsV1beta1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.readApiextensionsV1beta1CustomResourceDefinitionStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
  public replaceApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiReplaceApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.replaceApiextensionsV1beta1CustomResourceDefinition(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
  public replaceApiextensionsV1beta1CustomResourceDefinitionStatus(
    param:
      ApiextensionsV1beta1ApiReplaceApiextensionsV1beta1CustomResourceDefinitionStatusRequest,
    options?: Configuration,
  ): Promise<
    IoK8sApiextensionsApiserverPkgApisApiextensionsV1beta1CustomResourceDefinition
  > {
    return this.api.replaceApiextensionsV1beta1CustomResourceDefinitionStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchApiextensionsV1beta1CustomResourceDefinition(
    param:
      ApiextensionsV1beta1ApiWatchApiextensionsV1beta1CustomResourceDefinitionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiextensionsV1beta1CustomResourceDefinition(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchApiextensionsV1beta1CustomResourceDefinitionList(
    param:
      ApiextensionsV1beta1ApiWatchApiextensionsV1beta1CustomResourceDefinitionListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiextensionsV1beta1CustomResourceDefinitionList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableApiregistrationApi } from "./ObservableAPI.ts";
import {
  ApiregistrationApiRequestFactory,
  ApiregistrationApiResponseProcessor,
} from "../apis/ApiregistrationApi.ts";

export interface ApiregistrationApiGetApiregistrationAPIGroupRequest {
}

export class ObjectApiregistrationApi {
  private api: ObservableApiregistrationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiregistrationApiRequestFactory,
    responseProcessor?: ApiregistrationApiResponseProcessor,
  ) {
    this.api = new ObservableApiregistrationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getApiregistrationAPIGroup(
    param: ApiregistrationApiGetApiregistrationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getApiregistrationAPIGroup(options).toPromise();
  }
}

import { ObservableApiregistrationV1Api } from "./ObservableAPI.ts";
import {
  ApiregistrationV1ApiRequestFactory,
  ApiregistrationV1ApiResponseProcessor,
} from "../apis/ApiregistrationV1Api.ts";

export interface ApiregistrationV1ApiCreateApiregistrationV1APIServiceRequest {
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
     * @memberof ApiregistrationV1ApicreateApiregistrationV1APIService
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApicreateApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApicreateApiregistrationV1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApicreateApiregistrationV1APIService
     */
  fieldManager?: string;
}

export interface ApiregistrationV1ApiDeleteApiregistrationV1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiregistrationV1ApideleteApiregistrationV1APIService
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiregistrationV1ApiDeleteApiregistrationV1CollectionAPIServiceRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiregistrationV1ApideleteApiregistrationV1CollectionAPIService
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiregistrationV1ApiGetApiregistrationV1APIResourcesRequest {
}

export interface ApiregistrationV1ApiListApiregistrationV1APIServiceRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1ApilistApiregistrationV1APIService
     */
  watch?: boolean;
}

export interface ApiregistrationV1ApiPatchApiregistrationV1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIService
     */
  force?: boolean;
}

export interface ApiregistrationV1ApiPatchApiregistrationV1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1ApipatchApiregistrationV1APIServiceStatus
     */
  force?: boolean;
}

export interface ApiregistrationV1ApiReadApiregistrationV1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIService
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIService
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIService
     */
  _export?: boolean;
}

export interface ApiregistrationV1ApiReadApiregistrationV1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIServiceStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireadApiregistrationV1APIServiceStatus
     */
  pretty?: string;
}

export interface ApiregistrationV1ApiReplaceApiregistrationV1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIService
     */
  name: string;
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIService
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIService
     */
  fieldManager?: string;
}

export interface ApiregistrationV1ApiReplaceApiregistrationV1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIServiceStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIServiceStatus
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1ApireplaceApiregistrationV1APIServiceStatus
     */
  fieldManager?: string;
}

export interface ApiregistrationV1ApiWatchApiregistrationV1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIService
     */
  watch?: boolean;
}

export interface ApiregistrationV1ApiWatchApiregistrationV1APIServiceListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1ApiwatchApiregistrationV1APIServiceList
     */
  watch?: boolean;
}

export class ObjectApiregistrationV1Api {
  private api: ObservableApiregistrationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiregistrationV1ApiRequestFactory,
    responseProcessor?: ApiregistrationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableApiregistrationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an APIService
     * @param param the request object
     */
  public createApiregistrationV1APIService(
    param: ApiregistrationV1ApiCreateApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.createApiregistrationV1APIService(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete an APIService
     * @param param the request object
     */
  public deleteApiregistrationV1APIService(
    param: ApiregistrationV1ApiDeleteApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiregistrationV1APIService(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of APIService
     * @param param the request object
     */
  public deleteApiregistrationV1CollectionAPIService(
    param:
      ApiregistrationV1ApiDeleteApiregistrationV1CollectionAPIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiregistrationV1CollectionAPIService(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getApiregistrationV1APIResources(
    param: ApiregistrationV1ApiGetApiregistrationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getApiregistrationV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
  public listApiregistrationV1APIService(
    param: ApiregistrationV1ApiListApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList> {
    return this.api.listApiregistrationV1APIService(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified APIService
     * @param param the request object
     */
  public patchApiregistrationV1APIService(
    param: ApiregistrationV1ApiPatchApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.patchApiregistrationV1APIService(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified APIService
     * @param param the request object
     */
  public patchApiregistrationV1APIServiceStatus(
    param: ApiregistrationV1ApiPatchApiregistrationV1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.patchApiregistrationV1APIServiceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified APIService
     * @param param the request object
     */
  public readApiregistrationV1APIService(
    param: ApiregistrationV1ApiReadApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.readApiregistrationV1APIService(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified APIService
     * @param param the request object
     */
  public readApiregistrationV1APIServiceStatus(
    param: ApiregistrationV1ApiReadApiregistrationV1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.readApiregistrationV1APIServiceStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified APIService
     * @param param the request object
     */
  public replaceApiregistrationV1APIService(
    param: ApiregistrationV1ApiReplaceApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.replaceApiregistrationV1APIService(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified APIService
     * @param param the request object
     */
  public replaceApiregistrationV1APIServiceStatus(
    param: ApiregistrationV1ApiReplaceApiregistrationV1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1APIService> {
    return this.api.replaceApiregistrationV1APIServiceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchApiregistrationV1APIService(
    param: ApiregistrationV1ApiWatchApiregistrationV1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiregistrationV1APIService(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchApiregistrationV1APIServiceList(
    param: ApiregistrationV1ApiWatchApiregistrationV1APIServiceListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiregistrationV1APIServiceList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableApiregistrationV1beta1Api } from "./ObservableAPI.ts";
import {
  ApiregistrationV1beta1ApiRequestFactory,
  ApiregistrationV1beta1ApiResponseProcessor,
} from "../apis/ApiregistrationV1beta1Api.ts";

export interface ApiregistrationV1beta1ApiCreateApiregistrationV1beta1APIServiceRequest {
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService
     * @memberof ApiregistrationV1beta1ApicreateApiregistrationV1beta1APIService
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApicreateApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApicreateApiregistrationV1beta1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1beta1ApicreateApiregistrationV1beta1APIService
     */
  fieldManager?: string;
}

export interface ApiregistrationV1beta1ApiDeleteApiregistrationV1beta1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1APIService
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiregistrationV1beta1ApiDeleteApiregistrationV1beta1CollectionAPIServiceRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ApiregistrationV1beta1ApideleteApiregistrationV1beta1CollectionAPIService
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ApiregistrationV1beta1ApiGetApiregistrationV1beta1APIResourcesRequest {
}

export interface ApiregistrationV1beta1ApiListApiregistrationV1beta1APIServiceRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApilistApiregistrationV1beta1APIService
     */
  watch?: boolean;
}

export interface ApiregistrationV1beta1ApiPatchApiregistrationV1beta1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIService
     */
  force?: boolean;
}

export interface ApiregistrationV1beta1ApiPatchApiregistrationV1beta1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApipatchApiregistrationV1beta1APIServiceStatus
     */
  force?: boolean;
}

export interface ApiregistrationV1beta1ApiReadApiregistrationV1beta1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIService
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIService
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIService
     */
  _export?: boolean;
}

export interface ApiregistrationV1beta1ApiReadApiregistrationV1beta1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIServiceStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApireadApiregistrationV1beta1APIServiceStatus
     */
  pretty?: string;
}

export interface ApiregistrationV1beta1ApiReplaceApiregistrationV1beta1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIService
     */
  name: string;
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIService
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIService
     */
  fieldManager?: string;
}

export interface ApiregistrationV1beta1ApiReplaceApiregistrationV1beta1APIServiceStatusRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIServiceStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIServiceStatus
     */
  body: IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ApiregistrationV1beta1ApireplaceApiregistrationV1beta1APIServiceStatus
     */
  fieldManager?: string;
}

export interface ApiregistrationV1beta1ApiWatchApiregistrationV1beta1APIServiceRequest {
  /**
     * name of the APIService
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIService
     */
  watch?: boolean;
}

export interface ApiregistrationV1beta1ApiWatchApiregistrationV1beta1APIServiceListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ApiregistrationV1beta1ApiwatchApiregistrationV1beta1APIServiceList
     */
  watch?: boolean;
}

export class ObjectApiregistrationV1beta1Api {
  private api: ObservableApiregistrationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApiregistrationV1beta1ApiRequestFactory,
    responseProcessor?: ApiregistrationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableApiregistrationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an APIService
     * @param param the request object
     */
  public createApiregistrationV1beta1APIService(
    param:
      ApiregistrationV1beta1ApiCreateApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.createApiregistrationV1beta1APIService(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete an APIService
     * @param param the request object
     */
  public deleteApiregistrationV1beta1APIService(
    param:
      ApiregistrationV1beta1ApiDeleteApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiregistrationV1beta1APIService(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of APIService
     * @param param the request object
     */
  public deleteApiregistrationV1beta1CollectionAPIService(
    param:
      ApiregistrationV1beta1ApiDeleteApiregistrationV1beta1CollectionAPIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteApiregistrationV1beta1CollectionAPIService(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getApiregistrationV1beta1APIResources(
    param:
      ApiregistrationV1beta1ApiGetApiregistrationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getApiregistrationV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
  public listApiregistrationV1beta1APIService(
    param: ApiregistrationV1beta1ApiListApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIServiceList> {
    return this.api.listApiregistrationV1beta1APIService(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified APIService
     * @param param the request object
     */
  public patchApiregistrationV1beta1APIService(
    param:
      ApiregistrationV1beta1ApiPatchApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.patchApiregistrationV1beta1APIService(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified APIService
     * @param param the request object
     */
  public patchApiregistrationV1beta1APIServiceStatus(
    param:
      ApiregistrationV1beta1ApiPatchApiregistrationV1beta1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.patchApiregistrationV1beta1APIServiceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified APIService
     * @param param the request object
     */
  public readApiregistrationV1beta1APIService(
    param: ApiregistrationV1beta1ApiReadApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.readApiregistrationV1beta1APIService(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified APIService
     * @param param the request object
     */
  public readApiregistrationV1beta1APIServiceStatus(
    param:
      ApiregistrationV1beta1ApiReadApiregistrationV1beta1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.readApiregistrationV1beta1APIServiceStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified APIService
     * @param param the request object
     */
  public replaceApiregistrationV1beta1APIService(
    param:
      ApiregistrationV1beta1ApiReplaceApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.replaceApiregistrationV1beta1APIService(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified APIService
     * @param param the request object
     */
  public replaceApiregistrationV1beta1APIServiceStatus(
    param:
      ApiregistrationV1beta1ApiReplaceApiregistrationV1beta1APIServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sKubeAggregatorPkgApisApiregistrationV1beta1APIService> {
    return this.api.replaceApiregistrationV1beta1APIServiceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchApiregistrationV1beta1APIService(
    param:
      ApiregistrationV1beta1ApiWatchApiregistrationV1beta1APIServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiregistrationV1beta1APIService(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchApiregistrationV1beta1APIServiceList(
    param:
      ApiregistrationV1beta1ApiWatchApiregistrationV1beta1APIServiceListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchApiregistrationV1beta1APIServiceList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableApisApi } from "./ObservableAPI.ts";
import {
  ApisApiRequestFactory,
  ApisApiResponseProcessor,
} from "../apis/ApisApi.ts";

export interface ApisApiGetAPIVersionsRequest {
}

export class ObjectApisApi {
  private api: ObservableApisApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: ApisApiRequestFactory,
    responseProcessor?: ApisApiResponseProcessor,
  ) {
    this.api = new ObservableApisApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get available API versions
     * @param param the request object
     */
  public getAPIVersions(
    param: ApisApiGetAPIVersionsRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroupList> {
    return this.api.getAPIVersions(options).toPromise();
  }
}

import { ObservableAppsApi } from "./ObservableAPI.ts";
import {
  AppsApiRequestFactory,
  AppsApiResponseProcessor,
} from "../apis/AppsApi.ts";

export interface AppsApiGetAppsAPIGroupRequest {
}

export class ObjectAppsApi {
  private api: ObservableAppsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: AppsApiRequestFactory,
    responseProcessor?: AppsApiResponseProcessor,
  ) {
    this.api = new ObservableAppsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getAppsAPIGroup(
    param: AppsApiGetAppsAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getAppsAPIGroup(options).toPromise();
  }
}

import { ObservableAppsV1Api } from "./ObservableAPI.ts";
import {
  AppsV1ApiRequestFactory,
  AppsV1ApiResponseProcessor,
} from "../apis/AppsV1Api.ts";

export interface AppsV1ApiCreateAppsV1NamespacedControllerRevisionRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1ControllerRevision
     * @memberof AppsV1ApicreateAppsV1NamespacedControllerRevision
     */
  body: IoK8sApiAppsV1ControllerRevision;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedControllerRevision
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedControllerRevision
     */
  fieldManager?: string;
}

export interface AppsV1ApiCreateAppsV1NamespacedDaemonSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1DaemonSet
     * @memberof AppsV1ApicreateAppsV1NamespacedDaemonSet
     */
  body: IoK8sApiAppsV1DaemonSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDaemonSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDaemonSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiCreateAppsV1NamespacedDeploymentRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1Deployment
     * @memberof AppsV1ApicreateAppsV1NamespacedDeployment
     */
  body: IoK8sApiAppsV1Deployment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDeployment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedDeployment
     */
  fieldManager?: string;
}

export interface AppsV1ApiCreateAppsV1NamespacedReplicaSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1ReplicaSet
     * @memberof AppsV1ApicreateAppsV1NamespacedReplicaSet
     */
  body: IoK8sApiAppsV1ReplicaSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedReplicaSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedReplicaSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiCreateAppsV1NamespacedStatefulSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1StatefulSet
     * @memberof AppsV1ApicreateAppsV1NamespacedStatefulSet
     */
  body: IoK8sApiAppsV1StatefulSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedStatefulSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApicreateAppsV1NamespacedStatefulSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiDeleteAppsV1CollectionNamespacedControllerRevisionRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedControllerRevision
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1CollectionNamespacedDaemonSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDaemonSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1CollectionNamespacedDeploymentRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedDeployment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1CollectionNamespacedReplicaSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedReplicaSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1CollectionNamespacedStatefulSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1CollectionNamespacedStatefulSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1NamespacedControllerRevisionRequest {
  /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1NamespacedControllerRevision
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1NamespacedDaemonSetRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1NamespacedDaemonSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1NamespacedDeploymentRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1NamespacedDeployment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1NamespacedReplicaSetRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1NamespacedReplicaSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiDeleteAppsV1NamespacedStatefulSetRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AppsV1ApideleteAppsV1NamespacedStatefulSet
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AppsV1ApiGetAppsV1APIResourcesRequest {
}

export interface AppsV1ApiListAppsV1ControllerRevisionForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1ControllerRevisionForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1DaemonSetForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1DaemonSetForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1DeploymentForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1DeploymentForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1NamespacedControllerRevisionRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedControllerRevision
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1NamespacedDaemonSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedDaemonSet
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1NamespacedDeploymentRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedDeployment
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1NamespacedReplicaSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedReplicaSet
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1NamespacedStatefulSetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1NamespacedStatefulSet
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1ReplicaSetForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1ReplicaSetForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiListAppsV1StatefulSetForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApilistAppsV1StatefulSetForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedControllerRevisionRequest {
  /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedControllerRevision
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedDaemonSetRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSet
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedDaemonSetStatusRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedDaemonSetStatus
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedDeploymentRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedDeployment
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedDeploymentScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentScale
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedDeploymentStatusRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedDeploymentStatus
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedReplicaSetRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSet
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedReplicaSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetScale
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedReplicaSetStatusRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedReplicaSetStatus
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedStatefulSetRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSet
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedStatefulSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetScale
     */
  force?: boolean;
}

export interface AppsV1ApiPatchAppsV1NamespacedStatefulSetStatusRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AppsV1ApipatchAppsV1NamespacedStatefulSetStatus
     */
  force?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedControllerRevisionRequest {
  /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedControllerRevision
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedControllerRevision
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedControllerRevision
     */
  _export?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedDaemonSetRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSet
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSet
     */
  _export?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedDaemonSetStatusRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSetStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDaemonSetStatus
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedDeploymentRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeployment
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedDeployment
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedDeployment
     */
  _export?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedDeploymentScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentScale
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentScale
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedDeploymentStatusRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedDeploymentStatus
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedReplicaSetRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSet
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSet
     */
  _export?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedReplicaSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetScale
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetScale
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedReplicaSetStatusRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedReplicaSetStatus
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedStatefulSetRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSet
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSet
     */
  _export?: boolean;
}

export interface AppsV1ApiReadAppsV1NamespacedStatefulSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetScale
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetScale
     */
  pretty?: string;
}

export interface AppsV1ApiReadAppsV1NamespacedStatefulSetStatusRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireadAppsV1NamespacedStatefulSetStatus
     */
  pretty?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedControllerRevisionRequest {
  /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1ControllerRevision
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  body: IoK8sApiAppsV1ControllerRevision;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedControllerRevision
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedDaemonSetRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1DaemonSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  body: IoK8sApiAppsV1DaemonSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedDaemonSetStatusRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1DaemonSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  body: IoK8sApiAppsV1DaemonSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDaemonSetStatus
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedDeploymentRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1Deployment
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  body: IoK8sApiAppsV1Deployment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeployment
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedDeploymentScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1Scale
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  body: IoK8sApiAutoscalingV1Scale;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentScale
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedDeploymentStatusRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1Deployment
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  body: IoK8sApiAppsV1Deployment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedDeploymentStatus
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedReplicaSetRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1ReplicaSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  body: IoK8sApiAppsV1ReplicaSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedReplicaSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1Scale
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  body: IoK8sApiAutoscalingV1Scale;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetScale
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedReplicaSetStatusRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1ReplicaSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  body: IoK8sApiAppsV1ReplicaSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedReplicaSetStatus
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedStatefulSetRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1StatefulSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  body: IoK8sApiAppsV1StatefulSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSet
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedStatefulSetScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1Scale
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  body: IoK8sApiAutoscalingV1Scale;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetScale
     */
  fieldManager?: string;
}

export interface AppsV1ApiReplaceAppsV1NamespacedStatefulSetStatusRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAppsV1StatefulSet
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  body: IoK8sApiAppsV1StatefulSet;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AppsV1ApireplaceAppsV1NamespacedStatefulSetStatus
     */
  fieldManager?: string;
}

export interface AppsV1ApiWatchAppsV1ControllerRevisionListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1ControllerRevisionListForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1DaemonSetListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1DaemonSetListForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1DeploymentListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1DeploymentListForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedControllerRevisionRequest {
  /**
     * name of the ControllerRevision
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevision
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedControllerRevisionListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedControllerRevisionList
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedDaemonSetRequest {
  /**
     * name of the DaemonSet
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSet
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedDaemonSetListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDaemonSetList
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedDeploymentRequest {
  /**
     * name of the Deployment
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeployment
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedDeploymentListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedDeploymentList
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedReplicaSetRequest {
  /**
     * name of the ReplicaSet
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSet
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedReplicaSetListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedReplicaSetList
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedStatefulSetRequest {
  /**
     * name of the StatefulSet
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSet
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1NamespacedStatefulSetListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1NamespacedStatefulSetList
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1ReplicaSetListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1ReplicaSetListForAllNamespaces
     */
  watch?: boolean;
}

export interface AppsV1ApiWatchAppsV1StatefulSetListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AppsV1ApiwatchAppsV1StatefulSetListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectAppsV1Api {
  private api: ObservableAppsV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AppsV1ApiRequestFactory,
    responseProcessor?: AppsV1ApiResponseProcessor,
  ) {
    this.api = new ObservableAppsV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a ControllerRevision
     * @param param the request object
     */
  public createAppsV1NamespacedControllerRevision(
    param: AppsV1ApiCreateAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevision> {
    return this.api.createAppsV1NamespacedControllerRevision(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a DaemonSet
     * @param param the request object
     */
  public createAppsV1NamespacedDaemonSet(
    param: AppsV1ApiCreateAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.createAppsV1NamespacedDaemonSet(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Deployment
     * @param param the request object
     */
  public createAppsV1NamespacedDeployment(
    param: AppsV1ApiCreateAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.createAppsV1NamespacedDeployment(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ReplicaSet
     * @param param the request object
     */
  public createAppsV1NamespacedReplicaSet(
    param: AppsV1ApiCreateAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.createAppsV1NamespacedReplicaSet(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a StatefulSet
     * @param param the request object
     */
  public createAppsV1NamespacedStatefulSet(
    param: AppsV1ApiCreateAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.createAppsV1NamespacedStatefulSet(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ControllerRevision
     * @param param the request object
     */
  public deleteAppsV1CollectionNamespacedControllerRevision(
    param: AppsV1ApiDeleteAppsV1CollectionNamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1CollectionNamespacedControllerRevision(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of DaemonSet
     * @param param the request object
     */
  public deleteAppsV1CollectionNamespacedDaemonSet(
    param: AppsV1ApiDeleteAppsV1CollectionNamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1CollectionNamespacedDaemonSet(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Deployment
     * @param param the request object
     */
  public deleteAppsV1CollectionNamespacedDeployment(
    param: AppsV1ApiDeleteAppsV1CollectionNamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1CollectionNamespacedDeployment(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ReplicaSet
     * @param param the request object
     */
  public deleteAppsV1CollectionNamespacedReplicaSet(
    param: AppsV1ApiDeleteAppsV1CollectionNamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1CollectionNamespacedReplicaSet(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of StatefulSet
     * @param param the request object
     */
  public deleteAppsV1CollectionNamespacedStatefulSet(
    param: AppsV1ApiDeleteAppsV1CollectionNamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1CollectionNamespacedStatefulSet(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ControllerRevision
     * @param param the request object
     */
  public deleteAppsV1NamespacedControllerRevision(
    param: AppsV1ApiDeleteAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1NamespacedControllerRevision(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a DaemonSet
     * @param param the request object
     */
  public deleteAppsV1NamespacedDaemonSet(
    param: AppsV1ApiDeleteAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1NamespacedDaemonSet(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Deployment
     * @param param the request object
     */
  public deleteAppsV1NamespacedDeployment(
    param: AppsV1ApiDeleteAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1NamespacedDeployment(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ReplicaSet
     * @param param the request object
     */
  public deleteAppsV1NamespacedReplicaSet(
    param: AppsV1ApiDeleteAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1NamespacedReplicaSet(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a StatefulSet
     * @param param the request object
     */
  public deleteAppsV1NamespacedStatefulSet(
    param: AppsV1ApiDeleteAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAppsV1NamespacedStatefulSet(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAppsV1APIResources(
    param: AppsV1ApiGetAppsV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAppsV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
  public listAppsV1ControllerRevisionForAllNamespaces(
    param: AppsV1ApiListAppsV1ControllerRevisionForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevisionList> {
    return this.api.listAppsV1ControllerRevisionForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
  public listAppsV1DaemonSetForAllNamespaces(
    param: AppsV1ApiListAppsV1DaemonSetForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSetList> {
    return this.api.listAppsV1DaemonSetForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
  public listAppsV1DeploymentForAllNamespaces(
    param: AppsV1ApiListAppsV1DeploymentForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DeploymentList> {
    return this.api.listAppsV1DeploymentForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
  public listAppsV1NamespacedControllerRevision(
    param: AppsV1ApiListAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevisionList> {
    return this.api.listAppsV1NamespacedControllerRevision(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
  public listAppsV1NamespacedDaemonSet(
    param: AppsV1ApiListAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSetList> {
    return this.api.listAppsV1NamespacedDaemonSet(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
  public listAppsV1NamespacedDeployment(
    param: AppsV1ApiListAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DeploymentList> {
    return this.api.listAppsV1NamespacedDeployment(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
  public listAppsV1NamespacedReplicaSet(
    param: AppsV1ApiListAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSetList> {
    return this.api.listAppsV1NamespacedReplicaSet(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
  public listAppsV1NamespacedStatefulSet(
    param: AppsV1ApiListAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSetList> {
    return this.api.listAppsV1NamespacedStatefulSet(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
  public listAppsV1ReplicaSetForAllNamespaces(
    param: AppsV1ApiListAppsV1ReplicaSetForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSetList> {
    return this.api.listAppsV1ReplicaSetForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
  public listAppsV1StatefulSetForAllNamespaces(
    param: AppsV1ApiListAppsV1StatefulSetForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSetList> {
    return this.api.listAppsV1StatefulSetForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ControllerRevision
     * @param param the request object
     */
  public patchAppsV1NamespacedControllerRevision(
    param: AppsV1ApiPatchAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevision> {
    return this.api.patchAppsV1NamespacedControllerRevision(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified DaemonSet
     * @param param the request object
     */
  public patchAppsV1NamespacedDaemonSet(
    param: AppsV1ApiPatchAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.patchAppsV1NamespacedDaemonSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified DaemonSet
     * @param param the request object
     */
  public patchAppsV1NamespacedDaemonSetStatus(
    param: AppsV1ApiPatchAppsV1NamespacedDaemonSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.patchAppsV1NamespacedDaemonSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Deployment
     * @param param the request object
     */
  public patchAppsV1NamespacedDeployment(
    param: AppsV1ApiPatchAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.patchAppsV1NamespacedDeployment(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update scale of the specified Deployment
     * @param param the request object
     */
  public patchAppsV1NamespacedDeploymentScale(
    param: AppsV1ApiPatchAppsV1NamespacedDeploymentScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.patchAppsV1NamespacedDeploymentScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Deployment
     * @param param the request object
     */
  public patchAppsV1NamespacedDeploymentStatus(
    param: AppsV1ApiPatchAppsV1NamespacedDeploymentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.patchAppsV1NamespacedDeploymentStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ReplicaSet
     * @param param the request object
     */
  public patchAppsV1NamespacedReplicaSet(
    param: AppsV1ApiPatchAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.patchAppsV1NamespacedReplicaSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update scale of the specified ReplicaSet
     * @param param the request object
     */
  public patchAppsV1NamespacedReplicaSetScale(
    param: AppsV1ApiPatchAppsV1NamespacedReplicaSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.patchAppsV1NamespacedReplicaSetScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified ReplicaSet
     * @param param the request object
     */
  public patchAppsV1NamespacedReplicaSetStatus(
    param: AppsV1ApiPatchAppsV1NamespacedReplicaSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.patchAppsV1NamespacedReplicaSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified StatefulSet
     * @param param the request object
     */
  public patchAppsV1NamespacedStatefulSet(
    param: AppsV1ApiPatchAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.patchAppsV1NamespacedStatefulSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update scale of the specified StatefulSet
     * @param param the request object
     */
  public patchAppsV1NamespacedStatefulSetScale(
    param: AppsV1ApiPatchAppsV1NamespacedStatefulSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.patchAppsV1NamespacedStatefulSetScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified StatefulSet
     * @param param the request object
     */
  public patchAppsV1NamespacedStatefulSetStatus(
    param: AppsV1ApiPatchAppsV1NamespacedStatefulSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.patchAppsV1NamespacedStatefulSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified ControllerRevision
     * @param param the request object
     */
  public readAppsV1NamespacedControllerRevision(
    param: AppsV1ApiReadAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevision> {
    return this.api.readAppsV1NamespacedControllerRevision(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified DaemonSet
     * @param param the request object
     */
  public readAppsV1NamespacedDaemonSet(
    param: AppsV1ApiReadAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.readAppsV1NamespacedDaemonSet(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified DaemonSet
     * @param param the request object
     */
  public readAppsV1NamespacedDaemonSetStatus(
    param: AppsV1ApiReadAppsV1NamespacedDaemonSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.readAppsV1NamespacedDaemonSetStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Deployment
     * @param param the request object
     */
  public readAppsV1NamespacedDeployment(
    param: AppsV1ApiReadAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.readAppsV1NamespacedDeployment(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read scale of the specified Deployment
     * @param param the request object
     */
  public readAppsV1NamespacedDeploymentScale(
    param: AppsV1ApiReadAppsV1NamespacedDeploymentScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.readAppsV1NamespacedDeploymentScale(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Deployment
     * @param param the request object
     */
  public readAppsV1NamespacedDeploymentStatus(
    param: AppsV1ApiReadAppsV1NamespacedDeploymentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.readAppsV1NamespacedDeploymentStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified ReplicaSet
     * @param param the request object
     */
  public readAppsV1NamespacedReplicaSet(
    param: AppsV1ApiReadAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.readAppsV1NamespacedReplicaSet(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read scale of the specified ReplicaSet
     * @param param the request object
     */
  public readAppsV1NamespacedReplicaSetScale(
    param: AppsV1ApiReadAppsV1NamespacedReplicaSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.readAppsV1NamespacedReplicaSetScale(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified ReplicaSet
     * @param param the request object
     */
  public readAppsV1NamespacedReplicaSetStatus(
    param: AppsV1ApiReadAppsV1NamespacedReplicaSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.readAppsV1NamespacedReplicaSetStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified StatefulSet
     * @param param the request object
     */
  public readAppsV1NamespacedStatefulSet(
    param: AppsV1ApiReadAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.readAppsV1NamespacedStatefulSet(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read scale of the specified StatefulSet
     * @param param the request object
     */
  public readAppsV1NamespacedStatefulSetScale(
    param: AppsV1ApiReadAppsV1NamespacedStatefulSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.readAppsV1NamespacedStatefulSetScale(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified StatefulSet
     * @param param the request object
     */
  public readAppsV1NamespacedStatefulSetStatus(
    param: AppsV1ApiReadAppsV1NamespacedStatefulSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.readAppsV1NamespacedStatefulSetStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ControllerRevision
     * @param param the request object
     */
  public replaceAppsV1NamespacedControllerRevision(
    param: AppsV1ApiReplaceAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ControllerRevision> {
    return this.api.replaceAppsV1NamespacedControllerRevision(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified DaemonSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedDaemonSet(
    param: AppsV1ApiReplaceAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.replaceAppsV1NamespacedDaemonSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified DaemonSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedDaemonSetStatus(
    param: AppsV1ApiReplaceAppsV1NamespacedDaemonSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1DaemonSet> {
    return this.api.replaceAppsV1NamespacedDaemonSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Deployment
     * @param param the request object
     */
  public replaceAppsV1NamespacedDeployment(
    param: AppsV1ApiReplaceAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.replaceAppsV1NamespacedDeployment(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace scale of the specified Deployment
     * @param param the request object
     */
  public replaceAppsV1NamespacedDeploymentScale(
    param: AppsV1ApiReplaceAppsV1NamespacedDeploymentScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.replaceAppsV1NamespacedDeploymentScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Deployment
     * @param param the request object
     */
  public replaceAppsV1NamespacedDeploymentStatus(
    param: AppsV1ApiReplaceAppsV1NamespacedDeploymentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1Deployment> {
    return this.api.replaceAppsV1NamespacedDeploymentStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ReplicaSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedReplicaSet(
    param: AppsV1ApiReplaceAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.replaceAppsV1NamespacedReplicaSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace scale of the specified ReplicaSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedReplicaSetScale(
    param: AppsV1ApiReplaceAppsV1NamespacedReplicaSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.replaceAppsV1NamespacedReplicaSetScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified ReplicaSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedReplicaSetStatus(
    param: AppsV1ApiReplaceAppsV1NamespacedReplicaSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1ReplicaSet> {
    return this.api.replaceAppsV1NamespacedReplicaSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified StatefulSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedStatefulSet(
    param: AppsV1ApiReplaceAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.replaceAppsV1NamespacedStatefulSet(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace scale of the specified StatefulSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedStatefulSetScale(
    param: AppsV1ApiReplaceAppsV1NamespacedStatefulSetScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.replaceAppsV1NamespacedStatefulSetScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified StatefulSet
     * @param param the request object
     */
  public replaceAppsV1NamespacedStatefulSetStatus(
    param: AppsV1ApiReplaceAppsV1NamespacedStatefulSetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAppsV1StatefulSet> {
    return this.api.replaceAppsV1NamespacedStatefulSetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1ControllerRevisionListForAllNamespaces(
    param: AppsV1ApiWatchAppsV1ControllerRevisionListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1ControllerRevisionListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1DaemonSetListForAllNamespaces(
    param: AppsV1ApiWatchAppsV1DaemonSetListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1DaemonSetListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1DeploymentListForAllNamespaces(
    param: AppsV1ApiWatchAppsV1DeploymentListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1DeploymentListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAppsV1NamespacedControllerRevision(
    param: AppsV1ApiWatchAppsV1NamespacedControllerRevisionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedControllerRevision(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1NamespacedControllerRevisionList(
    param: AppsV1ApiWatchAppsV1NamespacedControllerRevisionListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedControllerRevisionList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind DaemonSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAppsV1NamespacedDaemonSet(
    param: AppsV1ApiWatchAppsV1NamespacedDaemonSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedDaemonSet(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1NamespacedDaemonSetList(
    param: AppsV1ApiWatchAppsV1NamespacedDaemonSetListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedDaemonSetList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Deployment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAppsV1NamespacedDeployment(
    param: AppsV1ApiWatchAppsV1NamespacedDeploymentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedDeployment(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1NamespacedDeploymentList(
    param: AppsV1ApiWatchAppsV1NamespacedDeploymentListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedDeploymentList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAppsV1NamespacedReplicaSet(
    param: AppsV1ApiWatchAppsV1NamespacedReplicaSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedReplicaSet(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1NamespacedReplicaSetList(
    param: AppsV1ApiWatchAppsV1NamespacedReplicaSetListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedReplicaSetList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind StatefulSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAppsV1NamespacedStatefulSet(
    param: AppsV1ApiWatchAppsV1NamespacedStatefulSetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedStatefulSet(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1NamespacedStatefulSetList(
    param: AppsV1ApiWatchAppsV1NamespacedStatefulSetListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1NamespacedStatefulSetList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1ReplicaSetListForAllNamespaces(
    param: AppsV1ApiWatchAppsV1ReplicaSetListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1ReplicaSetListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAppsV1StatefulSetListForAllNamespaces(
    param: AppsV1ApiWatchAppsV1StatefulSetListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAppsV1StatefulSetListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableAuthenticationApi } from "./ObservableAPI.ts";
import {
  AuthenticationApiRequestFactory,
  AuthenticationApiResponseProcessor,
} from "../apis/AuthenticationApi.ts";

export interface AuthenticationApiGetAuthenticationAPIGroupRequest {
}

export class ObjectAuthenticationApi {
  private api: ObservableAuthenticationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthenticationApiRequestFactory,
    responseProcessor?: AuthenticationApiResponseProcessor,
  ) {
    this.api = new ObservableAuthenticationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getAuthenticationAPIGroup(
    param: AuthenticationApiGetAuthenticationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getAuthenticationAPIGroup(options).toPromise();
  }
}

import { ObservableAuthenticationV1Api } from "./ObservableAPI.ts";
import {
  AuthenticationV1ApiRequestFactory,
  AuthenticationV1ApiResponseProcessor,
} from "../apis/AuthenticationV1Api.ts";

export interface AuthenticationV1ApiCreateAuthenticationV1TokenReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthenticationV1TokenReview
     * @memberof AuthenticationV1ApicreateAuthenticationV1TokenReview
     */
  body: IoK8sApiAuthenticationV1TokenReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthenticationV1ApicreateAuthenticationV1TokenReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthenticationV1ApicreateAuthenticationV1TokenReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthenticationV1ApicreateAuthenticationV1TokenReview
     */
  pretty?: string;
}

export interface AuthenticationV1ApiGetAuthenticationV1APIResourcesRequest {
}

export class ObjectAuthenticationV1Api {
  private api: ObservableAuthenticationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthenticationV1ApiRequestFactory,
    responseProcessor?: AuthenticationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableAuthenticationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a TokenReview
     * @param param the request object
     */
  public createAuthenticationV1TokenReview(
    param: AuthenticationV1ApiCreateAuthenticationV1TokenReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthenticationV1TokenReview> {
    return this.api.createAuthenticationV1TokenReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAuthenticationV1APIResources(
    param: AuthenticationV1ApiGetAuthenticationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAuthenticationV1APIResources(options).toPromise();
  }
}

import { ObservableAuthenticationV1beta1Api } from "./ObservableAPI.ts";
import {
  AuthenticationV1beta1ApiRequestFactory,
  AuthenticationV1beta1ApiResponseProcessor,
} from "../apis/AuthenticationV1beta1Api.ts";

export interface AuthenticationV1beta1ApiCreateAuthenticationV1beta1TokenReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthenticationV1beta1TokenReview
     * @memberof AuthenticationV1beta1ApicreateAuthenticationV1beta1TokenReview
     */
  body: IoK8sApiAuthenticationV1beta1TokenReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthenticationV1beta1ApicreateAuthenticationV1beta1TokenReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthenticationV1beta1ApicreateAuthenticationV1beta1TokenReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthenticationV1beta1ApicreateAuthenticationV1beta1TokenReview
     */
  pretty?: string;
}

export interface AuthenticationV1beta1ApiGetAuthenticationV1beta1APIResourcesRequest {
}

export class ObjectAuthenticationV1beta1Api {
  private api: ObservableAuthenticationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthenticationV1beta1ApiRequestFactory,
    responseProcessor?: AuthenticationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableAuthenticationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a TokenReview
     * @param param the request object
     */
  public createAuthenticationV1beta1TokenReview(
    param:
      AuthenticationV1beta1ApiCreateAuthenticationV1beta1TokenReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthenticationV1beta1TokenReview> {
    return this.api.createAuthenticationV1beta1TokenReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAuthenticationV1beta1APIResources(
    param: AuthenticationV1beta1ApiGetAuthenticationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAuthenticationV1beta1APIResources(options).toPromise();
  }
}

import { ObservableAuthorizationApi } from "./ObservableAPI.ts";
import {
  AuthorizationApiRequestFactory,
  AuthorizationApiResponseProcessor,
} from "../apis/AuthorizationApi.ts";

export interface AuthorizationApiGetAuthorizationAPIGroupRequest {
}

export class ObjectAuthorizationApi {
  private api: ObservableAuthorizationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthorizationApiRequestFactory,
    responseProcessor?: AuthorizationApiResponseProcessor,
  ) {
    this.api = new ObservableAuthorizationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getAuthorizationAPIGroup(
    param: AuthorizationApiGetAuthorizationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getAuthorizationAPIGroup(options).toPromise();
  }
}

import { ObservableAuthorizationV1Api } from "./ObservableAPI.ts";
import {
  AuthorizationV1ApiRequestFactory,
  AuthorizationV1ApiResponseProcessor,
} from "../apis/AuthorizationV1Api.ts";

export interface AuthorizationV1ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1NamespacedLocalSubjectAccessReview
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAuthorizationV1LocalSubjectAccessReview
     * @memberof AuthorizationV1ApicreateAuthorizationV1NamespacedLocalSubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1LocalSubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1NamespacedLocalSubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1NamespacedLocalSubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1NamespacedLocalSubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1SelfSubjectAccessReview
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1SelfSubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1SelfSubjectRulesReview
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectRulesReview
     */
  body: IoK8sApiAuthorizationV1SelfSubjectRulesReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectRulesReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectRulesReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SelfSubjectRulesReview
     */
  pretty?: string;
}

export interface AuthorizationV1ApiCreateAuthorizationV1SubjectAccessReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1SubjectAccessReview
     * @memberof AuthorizationV1ApicreateAuthorizationV1SubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1SubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1ApicreateAuthorizationV1SubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1ApiGetAuthorizationV1APIResourcesRequest {
}

export class ObjectAuthorizationV1Api {
  private api: ObservableAuthorizationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthorizationV1ApiRequestFactory,
    responseProcessor?: AuthorizationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableAuthorizationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1NamespacedLocalSubjectAccessReview(
    param:
      AuthorizationV1ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1LocalSubjectAccessReview> {
    return this.api.createAuthorizationV1NamespacedLocalSubjectAccessReview(
      param.namespace,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1SelfSubjectAccessReview(
    param:
      AuthorizationV1ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1SelfSubjectAccessReview> {
    return this.api.createAuthorizationV1SelfSubjectAccessReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
  public createAuthorizationV1SelfSubjectRulesReview(
    param: AuthorizationV1ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1SelfSubjectRulesReview> {
    return this.api.createAuthorizationV1SelfSubjectRulesReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a SubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1SubjectAccessReview(
    param: AuthorizationV1ApiCreateAuthorizationV1SubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1SubjectAccessReview> {
    return this.api.createAuthorizationV1SubjectAccessReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAuthorizationV1APIResources(
    param: AuthorizationV1ApiGetAuthorizationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAuthorizationV1APIResources(options).toPromise();
  }
}

import { ObservableAuthorizationV1beta1Api } from "./ObservableAPI.ts";
import {
  AuthorizationV1beta1ApiRequestFactory,
  AuthorizationV1beta1ApiResponseProcessor,
} from "../apis/AuthorizationV1beta1Api.ts";

export interface AuthorizationV1beta1ApiCreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1NamespacedLocalSubjectAccessReview
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAuthorizationV1beta1LocalSubjectAccessReview
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1NamespacedLocalSubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1beta1LocalSubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1NamespacedLocalSubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1NamespacedLocalSubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1NamespacedLocalSubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1beta1ApiCreateAuthorizationV1beta1SelfSubjectAccessReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1beta1SelfSubjectAccessReview
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1beta1SelfSubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1beta1ApiCreateAuthorizationV1beta1SelfSubjectRulesReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1beta1SelfSubjectRulesReview
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectRulesReview
     */
  body: IoK8sApiAuthorizationV1beta1SelfSubjectRulesReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectRulesReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectRulesReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SelfSubjectRulesReview
     */
  pretty?: string;
}

export interface AuthorizationV1beta1ApiCreateAuthorizationV1beta1SubjectAccessReviewRequest {
  /**
     * 
     * @type IoK8sApiAuthorizationV1beta1SubjectAccessReview
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SubjectAccessReview
     */
  body: IoK8sApiAuthorizationV1beta1SubjectAccessReview;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SubjectAccessReview
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SubjectAccessReview
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AuthorizationV1beta1ApicreateAuthorizationV1beta1SubjectAccessReview
     */
  pretty?: string;
}

export interface AuthorizationV1beta1ApiGetAuthorizationV1beta1APIResourcesRequest {
}

export class ObjectAuthorizationV1beta1Api {
  private api: ObservableAuthorizationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AuthorizationV1beta1ApiRequestFactory,
    responseProcessor?: AuthorizationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableAuthorizationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1beta1NamespacedLocalSubjectAccessReview(
    param:
      AuthorizationV1beta1ApiCreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1beta1LocalSubjectAccessReview> {
    return this.api
      .createAuthorizationV1beta1NamespacedLocalSubjectAccessReview(
        param.namespace,
        param.body,
        param.dryRun,
        param.fieldManager,
        param.pretty,
        options,
      ).toPromise();
  }

  /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1beta1SelfSubjectAccessReview(
    param:
      AuthorizationV1beta1ApiCreateAuthorizationV1beta1SelfSubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1beta1SelfSubjectAccessReview> {
    return this.api.createAuthorizationV1beta1SelfSubjectAccessReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
  public createAuthorizationV1beta1SelfSubjectRulesReview(
    param:
      AuthorizationV1beta1ApiCreateAuthorizationV1beta1SelfSubjectRulesReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1beta1SelfSubjectRulesReview> {
    return this.api.createAuthorizationV1beta1SelfSubjectRulesReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a SubjectAccessReview
     * @param param the request object
     */
  public createAuthorizationV1beta1SubjectAccessReview(
    param:
      AuthorizationV1beta1ApiCreateAuthorizationV1beta1SubjectAccessReviewRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthorizationV1beta1SubjectAccessReview> {
    return this.api.createAuthorizationV1beta1SubjectAccessReview(
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAuthorizationV1beta1APIResources(
    param: AuthorizationV1beta1ApiGetAuthorizationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAuthorizationV1beta1APIResources(options).toPromise();
  }
}

import { ObservableAutoscalingApi } from "./ObservableAPI.ts";
import {
  AutoscalingApiRequestFactory,
  AutoscalingApiResponseProcessor,
} from "../apis/AutoscalingApi.ts";

export interface AutoscalingApiGetAutoscalingAPIGroupRequest {
}

export class ObjectAutoscalingApi {
  private api: ObservableAutoscalingApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: AutoscalingApiRequestFactory,
    responseProcessor?: AutoscalingApiResponseProcessor,
  ) {
    this.api = new ObservableAutoscalingApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getAutoscalingAPIGroup(
    param: AutoscalingApiGetAutoscalingAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getAutoscalingAPIGroup(options).toPromise();
  }
}

import { ObservableAutoscalingV1Api } from "./ObservableAPI.ts";
import {
  AutoscalingV1ApiRequestFactory,
  AutoscalingV1ApiResponseProcessor,
} from "../apis/AutoscalingV1Api.ts";

export interface AutoscalingV1ApiCreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApicreateAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApicreateAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApicreateAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApicreateAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApicreateAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV1ApiDeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV1ApideleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV1ApiDeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV1ApideleteAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV1ApiGetAutoscalingV1APIResourcesRequest {
}

export interface AutoscalingV1ApiListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApilistAutoscalingV1HorizontalPodAutoscalerForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV1ApiListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApilistAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV1ApiPatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  force?: boolean;
}

export interface AutoscalingV1ApiPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV1ApipatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  force?: boolean;
}

export interface AutoscalingV1ApiReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  _export?: boolean;
}

export interface AutoscalingV1ApiReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
}

export interface AutoscalingV1ApiReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV1ApiReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  body: IoK8sApiAutoscalingV1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV1ApireplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
}

export interface AutoscalingV1ApiWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV1ApiWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV1ApiWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV1ApiwatchAutoscalingV1NamespacedHorizontalPodAutoscalerList
     */
  watch?: boolean;
}

export class ObjectAutoscalingV1Api {
  private api: ObservableAutoscalingV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AutoscalingV1ApiRequestFactory,
    responseProcessor?: AutoscalingV1ApiResponseProcessor,
  ) {
    this.api = new ObservableAutoscalingV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
  public createAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiCreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.createAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiDeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler(
        param.namespace,
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiDeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAutoscalingV1APIResources(
    param: AutoscalingV1ApiGetAutoscalingV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAutoscalingV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(
    param:
      AutoscalingV1ApiListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscalerList> {
    return this.api.listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscalerList> {
    return this.api.listAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiPatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.patchAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV1ApiPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.readAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV1ApiReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.replaceAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV1ApiReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1HorizontalPodAutoscaler> {
    return this.api.replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(
    param:
      AutoscalingV1ApiWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAutoscalingV1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV1ApiWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAutoscalingV1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV1NamespacedHorizontalPodAutoscalerList(
    param:
      AutoscalingV1ApiWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAutoscalingV1NamespacedHorizontalPodAutoscalerList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableAutoscalingV2beta1Api } from "./ObservableAPI.ts";
import {
  AutoscalingV2beta1ApiRequestFactory,
  AutoscalingV2beta1ApiResponseProcessor,
} from "../apis/AutoscalingV2beta1Api.ts";

export interface AutoscalingV2beta1ApiCreateAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApicreateAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApicreateAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApicreateAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApicreateAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApicreateAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta1ApiDeleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV2beta1ApiDeleteAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV2beta1ApideleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV2beta1ApiGetAutoscalingV2beta1APIResourcesRequest {
}

export interface AutoscalingV2beta1ApiListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV2beta1ApiListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApilistAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV2beta1ApiPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  force?: boolean;
}

export interface AutoscalingV2beta1ApiPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta1ApipatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  force?: boolean;
}

export interface AutoscalingV2beta1ApiReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  _export?: boolean;
}

export interface AutoscalingV2beta1ApiReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
}

export interface AutoscalingV2beta1ApiReplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta1ApiReplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  body: IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta1ApireplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta1ApiWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV2beta1ApiWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV2beta1ApiWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta1ApiwatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList
     */
  watch?: boolean;
}

export class ObjectAutoscalingV2beta1Api {
  private api: ObservableAutoscalingV2beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AutoscalingV2beta1ApiRequestFactory,
    responseProcessor?: AutoscalingV2beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableAutoscalingV2beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
  public createAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiCreateAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api.createAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiDeleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler(
        param.namespace,
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiDeleteAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAutoscalingV2beta1APIResources(
    param: AutoscalingV2beta1ApiGetAutoscalingV2beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAutoscalingV2beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(
    param:
      AutoscalingV2beta1ApiListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerList> {
    return this.api
      .listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscalerList> {
    return this.api.listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api.patchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta1ApiPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api
      .patchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        param.force,
        options,
      ).toPromise();
  }

  /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api.readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta1ApiReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api
      .readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.pretty,
        options,
      ).toPromise();
  }

  /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiReplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api.replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta1ApiReplaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta1HorizontalPodAutoscaler> {
    return this.api
      .replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(
    param:
      AutoscalingV2beta1ApiWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta1ApiWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(
    param:
      AutoscalingV2beta1ApiWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(
        param.namespace,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }
}

import { ObservableAutoscalingV2beta2Api } from "./ObservableAPI.ts";
import {
  AutoscalingV2beta2ApiRequestFactory,
  AutoscalingV2beta2ApiResponseProcessor,
} from "../apis/AutoscalingV2beta2Api.ts";

export interface AutoscalingV2beta2ApiCreateAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApicreateAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApicreateAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApicreateAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApicreateAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApicreateAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta2ApiDeleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV2beta2ApiDeleteAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof AutoscalingV2beta2ApideleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface AutoscalingV2beta2ApiGetAutoscalingV2beta2APIResourcesRequest {
}

export interface AutoscalingV2beta2ApiListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV2beta2ApiListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApilistAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV2beta2ApiPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  force?: boolean;
}

export interface AutoscalingV2beta2ApiPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof AutoscalingV2beta2ApipatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  force?: boolean;
}

export interface AutoscalingV2beta2ApiReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  _export?: boolean;
}

export interface AutoscalingV2beta2ApiReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
}

export interface AutoscalingV2beta2ApiReplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  body: IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta2ApiReplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  body: IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof AutoscalingV2beta2ApireplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus
     */
  fieldManager?: string;
}

export interface AutoscalingV2beta2ApiWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces
     */
  watch?: boolean;
}

export interface AutoscalingV2beta2ApiWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest {
  /**
     * name of the HorizontalPodAutoscaler
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler
     */
  watch?: boolean;
}

export interface AutoscalingV2beta2ApiWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof AutoscalingV2beta2ApiwatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList
     */
  watch?: boolean;
}

export class ObjectAutoscalingV2beta2Api {
  private api: ObservableAutoscalingV2beta2Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: AutoscalingV2beta2ApiRequestFactory,
    responseProcessor?: AutoscalingV2beta2ApiResponseProcessor,
  ) {
    this.api = new ObservableAutoscalingV2beta2Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
  public createAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiCreateAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api.createAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiDeleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler(
        param.namespace,
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
  public deleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiDeleteAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getAutoscalingV2beta2APIResources(
    param: AutoscalingV2beta2ApiGetAutoscalingV2beta2APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getAutoscalingV2beta2APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(
    param:
      AutoscalingV2beta2ApiListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerList> {
    return this.api
      .listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
  public listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscalerList> {
    return this.api.listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api.patchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public patchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta2ApiPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api
      .patchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        param.force,
        options,
      ).toPromise();
  }

  /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api.readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta2ApiReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api
      .readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.pretty,
        options,
      ).toPromise();
  }

  /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiReplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api.replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
  public replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
    param:
      AutoscalingV2beta2ApiReplaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV2beta2HorizontalPodAutoscaler> {
    return this.api
      .replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(
        param.name,
        param.namespace,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(
    param:
      AutoscalingV2beta2ApiWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
    param:
      AutoscalingV2beta2ApiWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(
    param:
      AutoscalingV2beta2ApiWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(
        param.namespace,
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }
}

import { ObservableBatchApi } from "./ObservableAPI.ts";
import {
  BatchApiRequestFactory,
  BatchApiResponseProcessor,
} from "../apis/BatchApi.ts";

export interface BatchApiGetBatchAPIGroupRequest {
}

export class ObjectBatchApi {
  private api: ObservableBatchApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: BatchApiRequestFactory,
    responseProcessor?: BatchApiResponseProcessor,
  ) {
    this.api = new ObservableBatchApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getBatchAPIGroup(
    param: BatchApiGetBatchAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getBatchAPIGroup(options).toPromise();
  }
}

import { ObservableBatchV1Api } from "./ObservableAPI.ts";
import {
  BatchV1ApiRequestFactory,
  BatchV1ApiResponseProcessor,
} from "../apis/BatchV1Api.ts";

export interface BatchV1ApiCreateBatchV1NamespacedJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApicreateBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1Job
     * @memberof BatchV1ApicreateBatchV1NamespacedJob
     */
  body: IoK8sApiBatchV1Job;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApicreateBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApicreateBatchV1NamespacedJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApicreateBatchV1NamespacedJob
     */
  fieldManager?: string;
}

export interface BatchV1ApiDeleteBatchV1CollectionNamespacedJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV1ApideleteBatchV1CollectionNamespacedJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV1ApiDeleteBatchV1NamespacedJobRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV1ApideleteBatchV1NamespacedJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV1ApiGetBatchV1APIResourcesRequest {
}

export interface BatchV1ApiListBatchV1JobForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistBatchV1JobForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV1ApiListBatchV1NamespacedJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApilistBatchV1NamespacedJob
     */
  watch?: boolean;
}

export interface BatchV1ApiPatchBatchV1NamespacedJobRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchBatchV1NamespacedJob
     */
  force?: boolean;
}

export interface BatchV1ApiPatchBatchV1NamespacedJobStatusRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1ApipatchBatchV1NamespacedJobStatus
     */
  force?: boolean;
}

export interface BatchV1ApiReadBatchV1NamespacedJobRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV1ApireadBatchV1NamespacedJob
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV1ApireadBatchV1NamespacedJob
     */
  _export?: boolean;
}

export interface BatchV1ApiReadBatchV1NamespacedJobStatusRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJobStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireadBatchV1NamespacedJobStatus
     */
  pretty?: string;
}

export interface BatchV1ApiReplaceBatchV1NamespacedJobRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1Job
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  body: IoK8sApiBatchV1Job;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJob
     */
  fieldManager?: string;
}

export interface BatchV1ApiReplaceBatchV1NamespacedJobStatusRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1Job
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  body: IoK8sApiBatchV1Job;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1ApireplaceBatchV1NamespacedJobStatus
     */
  fieldManager?: string;
}

export interface BatchV1ApiWatchBatchV1JobListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1JobListForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV1ApiWatchBatchV1NamespacedJobRequest {
  /**
     * name of the Job
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1NamespacedJob
     */
  watch?: boolean;
}

export interface BatchV1ApiWatchBatchV1NamespacedJobListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1ApiwatchBatchV1NamespacedJobList
     */
  watch?: boolean;
}

export class ObjectBatchV1Api {
  private api: ObservableBatchV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: BatchV1ApiRequestFactory,
    responseProcessor?: BatchV1ApiResponseProcessor,
  ) {
    this.api = new ObservableBatchV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a Job
     * @param param the request object
     */
  public createBatchV1NamespacedJob(
    param: BatchV1ApiCreateBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.createBatchV1NamespacedJob(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Job
     * @param param the request object
     */
  public deleteBatchV1CollectionNamespacedJob(
    param: BatchV1ApiDeleteBatchV1CollectionNamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV1CollectionNamespacedJob(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Job
     * @param param the request object
     */
  public deleteBatchV1NamespacedJob(
    param: BatchV1ApiDeleteBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV1NamespacedJob(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getBatchV1APIResources(
    param: BatchV1ApiGetBatchV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getBatchV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Job
     * @param param the request object
     */
  public listBatchV1JobForAllNamespaces(
    param: BatchV1ApiListBatchV1JobForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1JobList> {
    return this.api.listBatchV1JobForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Job
     * @param param the request object
     */
  public listBatchV1NamespacedJob(
    param: BatchV1ApiListBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1JobList> {
    return this.api.listBatchV1NamespacedJob(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Job
     * @param param the request object
     */
  public patchBatchV1NamespacedJob(
    param: BatchV1ApiPatchBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.patchBatchV1NamespacedJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Job
     * @param param the request object
     */
  public patchBatchV1NamespacedJobStatus(
    param: BatchV1ApiPatchBatchV1NamespacedJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.patchBatchV1NamespacedJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Job
     * @param param the request object
     */
  public readBatchV1NamespacedJob(
    param: BatchV1ApiReadBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.readBatchV1NamespacedJob(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Job
     * @param param the request object
     */
  public readBatchV1NamespacedJobStatus(
    param: BatchV1ApiReadBatchV1NamespacedJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.readBatchV1NamespacedJobStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Job
     * @param param the request object
     */
  public replaceBatchV1NamespacedJob(
    param: BatchV1ApiReplaceBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.replaceBatchV1NamespacedJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Job
     * @param param the request object
     */
  public replaceBatchV1NamespacedJobStatus(
    param: BatchV1ApiReplaceBatchV1NamespacedJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1Job> {
    return this.api.replaceBatchV1NamespacedJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV1JobListForAllNamespaces(
    param: BatchV1ApiWatchBatchV1JobListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1JobListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Job. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchBatchV1NamespacedJob(
    param: BatchV1ApiWatchBatchV1NamespacedJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1NamespacedJob(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV1NamespacedJobList(
    param: BatchV1ApiWatchBatchV1NamespacedJobListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1NamespacedJobList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableBatchV1beta1Api } from "./ObservableAPI.ts";
import {
  BatchV1beta1ApiRequestFactory,
  BatchV1beta1ApiResponseProcessor,
} from "../apis/BatchV1beta1Api.ts";

export interface BatchV1beta1ApiCreateBatchV1beta1NamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApicreateBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1beta1CronJob
     * @memberof BatchV1beta1ApicreateBatchV1beta1NamespacedCronJob
     */
  body: IoK8sApiBatchV1beta1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApicreateBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApicreateBatchV1beta1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApicreateBatchV1beta1NamespacedCronJob
     */
  fieldManager?: string;
}

export interface BatchV1beta1ApiDeleteBatchV1beta1CollectionNamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV1beta1ApideleteBatchV1beta1CollectionNamespacedCronJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV1beta1ApiDeleteBatchV1beta1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV1beta1ApideleteBatchV1beta1NamespacedCronJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV1beta1ApiGetBatchV1beta1APIResourcesRequest {
}

export interface BatchV1beta1ApiListBatchV1beta1CronJobForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApilistBatchV1beta1CronJobForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV1beta1ApiListBatchV1beta1NamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApilistBatchV1beta1NamespacedCronJob
     */
  watch?: boolean;
}

export interface BatchV1beta1ApiPatchBatchV1beta1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJob
     */
  force?: boolean;
}

export interface BatchV1beta1ApiPatchBatchV1beta1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV1beta1ApipatchBatchV1beta1NamespacedCronJobStatus
     */
  force?: boolean;
}

export interface BatchV1beta1ApiReadBatchV1beta1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJob
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJob
     */
  _export?: boolean;
}

export interface BatchV1beta1ApiReadBatchV1beta1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireadBatchV1beta1NamespacedCronJobStatus
     */
  pretty?: string;
}

export interface BatchV1beta1ApiReplaceBatchV1beta1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1beta1CronJob
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  body: IoK8sApiBatchV1beta1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJob
     */
  fieldManager?: string;
}

export interface BatchV1beta1ApiReplaceBatchV1beta1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV1beta1CronJob
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  body: IoK8sApiBatchV1beta1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV1beta1ApireplaceBatchV1beta1NamespacedCronJobStatus
     */
  fieldManager?: string;
}

export interface BatchV1beta1ApiWatchBatchV1beta1CronJobListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1CronJobListForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV1beta1ApiWatchBatchV1beta1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJob
     */
  watch?: boolean;
}

export interface BatchV1beta1ApiWatchBatchV1beta1NamespacedCronJobListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV1beta1ApiwatchBatchV1beta1NamespacedCronJobList
     */
  watch?: boolean;
}

export class ObjectBatchV1beta1Api {
  private api: ObservableBatchV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: BatchV1beta1ApiRequestFactory,
    responseProcessor?: BatchV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableBatchV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CronJob
     * @param param the request object
     */
  public createBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiCreateBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.createBatchV1beta1NamespacedCronJob(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CronJob
     * @param param the request object
     */
  public deleteBatchV1beta1CollectionNamespacedCronJob(
    param: BatchV1beta1ApiDeleteBatchV1beta1CollectionNamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV1beta1CollectionNamespacedCronJob(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a CronJob
     * @param param the request object
     */
  public deleteBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiDeleteBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV1beta1NamespacedCronJob(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getBatchV1beta1APIResources(
    param: BatchV1beta1ApiGetBatchV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getBatchV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
  public listBatchV1beta1CronJobForAllNamespaces(
    param: BatchV1beta1ApiListBatchV1beta1CronJobForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJobList> {
    return this.api.listBatchV1beta1CronJobForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
  public listBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiListBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJobList> {
    return this.api.listBatchV1beta1NamespacedCronJob(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CronJob
     * @param param the request object
     */
  public patchBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiPatchBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.patchBatchV1beta1NamespacedCronJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
  public patchBatchV1beta1NamespacedCronJobStatus(
    param: BatchV1beta1ApiPatchBatchV1beta1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.patchBatchV1beta1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CronJob
     * @param param the request object
     */
  public readBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiReadBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.readBatchV1beta1NamespacedCronJob(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CronJob
     * @param param the request object
     */
  public readBatchV1beta1NamespacedCronJobStatus(
    param: BatchV1beta1ApiReadBatchV1beta1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.readBatchV1beta1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CronJob
     * @param param the request object
     */
  public replaceBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiReplaceBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.replaceBatchV1beta1NamespacedCronJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CronJob
     * @param param the request object
     */
  public replaceBatchV1beta1NamespacedCronJobStatus(
    param: BatchV1beta1ApiReplaceBatchV1beta1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV1beta1CronJob> {
    return this.api.replaceBatchV1beta1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV1beta1CronJobListForAllNamespaces(
    param: BatchV1beta1ApiWatchBatchV1beta1CronJobListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1beta1CronJobListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchBatchV1beta1NamespacedCronJob(
    param: BatchV1beta1ApiWatchBatchV1beta1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1beta1NamespacedCronJob(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV1beta1NamespacedCronJobList(
    param: BatchV1beta1ApiWatchBatchV1beta1NamespacedCronJobListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV1beta1NamespacedCronJobList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableBatchV2alpha1Api } from "./ObservableAPI.ts";
import {
  BatchV2alpha1ApiRequestFactory,
  BatchV2alpha1ApiResponseProcessor,
} from "../apis/BatchV2alpha1Api.ts";

export interface BatchV2alpha1ApiCreateBatchV2alpha1NamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApicreateBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV2alpha1CronJob
     * @memberof BatchV2alpha1ApicreateBatchV2alpha1NamespacedCronJob
     */
  body: IoK8sApiBatchV2alpha1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApicreateBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApicreateBatchV2alpha1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV2alpha1ApicreateBatchV2alpha1NamespacedCronJob
     */
  fieldManager?: string;
}

export interface BatchV2alpha1ApiDeleteBatchV2alpha1CollectionNamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1CollectionNamespacedCronJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV2alpha1ApiDeleteBatchV2alpha1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof BatchV2alpha1ApideleteBatchV2alpha1NamespacedCronJob
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface BatchV2alpha1ApiGetBatchV2alpha1APIResourcesRequest {
}

export interface BatchV2alpha1ApiListBatchV2alpha1CronJobForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV2alpha1ApilistBatchV2alpha1CronJobForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV2alpha1ApiListBatchV2alpha1NamespacedCronJobRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV2alpha1ApilistBatchV2alpha1NamespacedCronJob
     */
  watch?: boolean;
}

export interface BatchV2alpha1ApiPatchBatchV2alpha1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJob
     */
  force?: boolean;
}

export interface BatchV2alpha1ApiPatchBatchV2alpha1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof BatchV2alpha1ApipatchBatchV2alpha1NamespacedCronJobStatus
     */
  force?: boolean;
}

export interface BatchV2alpha1ApiReadBatchV2alpha1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJob
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJob
     */
  _export?: boolean;
}

export interface BatchV2alpha1ApiReadBatchV2alpha1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApireadBatchV2alpha1NamespacedCronJobStatus
     */
  pretty?: string;
}

export interface BatchV2alpha1ApiReplaceBatchV2alpha1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV2alpha1CronJob
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  body: IoK8sApiBatchV2alpha1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJob
     */
  fieldManager?: string;
}

export interface BatchV2alpha1ApiReplaceBatchV2alpha1NamespacedCronJobStatusRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiBatchV2alpha1CronJob
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  body: IoK8sApiBatchV2alpha1CronJob;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof BatchV2alpha1ApireplaceBatchV2alpha1NamespacedCronJobStatus
     */
  fieldManager?: string;
}

export interface BatchV2alpha1ApiWatchBatchV2alpha1CronJobListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1CronJobListForAllNamespaces
     */
  watch?: boolean;
}

export interface BatchV2alpha1ApiWatchBatchV2alpha1NamespacedCronJobRequest {
  /**
     * name of the CronJob
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJob
     */
  watch?: boolean;
}

export interface BatchV2alpha1ApiWatchBatchV2alpha1NamespacedCronJobListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof BatchV2alpha1ApiwatchBatchV2alpha1NamespacedCronJobList
     */
  watch?: boolean;
}

export class ObjectBatchV2alpha1Api {
  private api: ObservableBatchV2alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: BatchV2alpha1ApiRequestFactory,
    responseProcessor?: BatchV2alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableBatchV2alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CronJob
     * @param param the request object
     */
  public createBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiCreateBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.createBatchV2alpha1NamespacedCronJob(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CronJob
     * @param param the request object
     */
  public deleteBatchV2alpha1CollectionNamespacedCronJob(
    param:
      BatchV2alpha1ApiDeleteBatchV2alpha1CollectionNamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV2alpha1CollectionNamespacedCronJob(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a CronJob
     * @param param the request object
     */
  public deleteBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiDeleteBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteBatchV2alpha1NamespacedCronJob(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getBatchV2alpha1APIResources(
    param: BatchV2alpha1ApiGetBatchV2alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getBatchV2alpha1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
  public listBatchV2alpha1CronJobForAllNamespaces(
    param: BatchV2alpha1ApiListBatchV2alpha1CronJobForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJobList> {
    return this.api.listBatchV2alpha1CronJobForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
  public listBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiListBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJobList> {
    return this.api.listBatchV2alpha1NamespacedCronJob(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CronJob
     * @param param the request object
     */
  public patchBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiPatchBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.patchBatchV2alpha1NamespacedCronJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
  public patchBatchV2alpha1NamespacedCronJobStatus(
    param: BatchV2alpha1ApiPatchBatchV2alpha1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.patchBatchV2alpha1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CronJob
     * @param param the request object
     */
  public readBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiReadBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.readBatchV2alpha1NamespacedCronJob(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CronJob
     * @param param the request object
     */
  public readBatchV2alpha1NamespacedCronJobStatus(
    param: BatchV2alpha1ApiReadBatchV2alpha1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.readBatchV2alpha1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CronJob
     * @param param the request object
     */
  public replaceBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiReplaceBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.replaceBatchV2alpha1NamespacedCronJob(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CronJob
     * @param param the request object
     */
  public replaceBatchV2alpha1NamespacedCronJobStatus(
    param: BatchV2alpha1ApiReplaceBatchV2alpha1NamespacedCronJobStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiBatchV2alpha1CronJob> {
    return this.api.replaceBatchV2alpha1NamespacedCronJobStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV2alpha1CronJobListForAllNamespaces(
    param: BatchV2alpha1ApiWatchBatchV2alpha1CronJobListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV2alpha1CronJobListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchBatchV2alpha1NamespacedCronJob(
    param: BatchV2alpha1ApiWatchBatchV2alpha1NamespacedCronJobRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV2alpha1NamespacedCronJob(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchBatchV2alpha1NamespacedCronJobList(
    param: BatchV2alpha1ApiWatchBatchV2alpha1NamespacedCronJobListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchBatchV2alpha1NamespacedCronJobList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableCertificatesApi } from "./ObservableAPI.ts";
import {
  CertificatesApiRequestFactory,
  CertificatesApiResponseProcessor,
} from "../apis/CertificatesApi.ts";

export interface CertificatesApiGetCertificatesAPIGroupRequest {
}

export class ObjectCertificatesApi {
  private api: ObservableCertificatesApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: CertificatesApiRequestFactory,
    responseProcessor?: CertificatesApiResponseProcessor,
  ) {
    this.api = new ObservableCertificatesApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getCertificatesAPIGroup(
    param: CertificatesApiGetCertificatesAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getCertificatesAPIGroup(options).toPromise();
  }
}

import { ObservableCertificatesV1Api } from "./ObservableAPI.ts";
import {
  CertificatesV1ApiRequestFactory,
  CertificatesV1ApiResponseProcessor,
} from "../apis/CertificatesV1Api.ts";

export interface CertificatesV1ApiCreateCertificatesV1CertificateSigningRequestRequest {
  /**
     * 
     * @type IoK8sApiCertificatesV1CertificateSigningRequest
     * @memberof CertificatesV1ApicreateCertificatesV1CertificateSigningRequest
     */
  body: IoK8sApiCertificatesV1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApicreateCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApicreateCertificatesV1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApicreateCertificatesV1CertificateSigningRequest
     */
  fieldManager?: string;
}

export interface CertificatesV1ApiDeleteCertificatesV1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CertificatesV1ApideleteCertificatesV1CertificateSigningRequest
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CertificatesV1ApiDeleteCertificatesV1CollectionCertificateSigningRequestRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CertificatesV1ApideleteCertificatesV1CollectionCertificateSigningRequest
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CertificatesV1ApiGetCertificatesV1APIResourcesRequest {
}

export interface CertificatesV1ApiListCertificatesV1CertificateSigningRequestRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1ApilistCertificatesV1CertificateSigningRequest
     */
  watch?: boolean;
}

export interface CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequest
     */
  force?: boolean;
}

export interface CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestApproval
     */
  force?: boolean;
}

export interface CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificatesV1CertificateSigningRequestStatus
     */
  force?: boolean;
}

export interface CertificatesV1ApiReadCertificatesV1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequest
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequest
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequest
     */
  _export?: boolean;
}

export interface CertificatesV1ApiReadCertificatesV1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequestApproval
     */
  pretty?: string;
}

export interface CertificatesV1ApiReadCertificatesV1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireadCertificatesV1CertificateSigningRequestStatus
     */
  pretty?: string;
}

export interface CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequest
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequest
     */
  body: IoK8sApiCertificatesV1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequest
     */
  fieldManager?: string;
}

export interface CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestApproval
     */
  body: IoK8sApiCertificatesV1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestApproval
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestApproval
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestApproval
     */
  fieldManager?: string;
}

export interface CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestStatus
     */
  body: IoK8sApiCertificatesV1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1ApireplaceCertificatesV1CertificateSigningRequestStatus
     */
  fieldManager?: string;
}

export interface CertificatesV1ApiWatchCertificatesV1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequest
     */
  watch?: boolean;
}

export interface CertificatesV1ApiWatchCertificatesV1CertificateSigningRequestListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1ApiwatchCertificatesV1CertificateSigningRequestList
     */
  watch?: boolean;
}

export class ObjectCertificatesV1Api {
  private api: ObservableCertificatesV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: CertificatesV1ApiRequestFactory,
    responseProcessor?: CertificatesV1ApiResponseProcessor,
  ) {
    this.api = new ObservableCertificatesV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
  public createCertificatesV1CertificateSigningRequest(
    param:
      CertificatesV1ApiCreateCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.createCertificatesV1CertificateSigningRequest(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
  public deleteCertificatesV1CertificateSigningRequest(
    param:
      CertificatesV1ApiDeleteCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCertificatesV1CertificateSigningRequest(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
  public deleteCertificatesV1CollectionCertificateSigningRequest(
    param:
      CertificatesV1ApiDeleteCertificatesV1CollectionCertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCertificatesV1CollectionCertificateSigningRequest(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getCertificatesV1APIResources(
    param: CertificatesV1ApiGetCertificatesV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getCertificatesV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
  public listCertificatesV1CertificateSigningRequest(
    param: CertificatesV1ApiListCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequestList> {
    return this.api.listCertificatesV1CertificateSigningRequest(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1CertificateSigningRequest(
    param: CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.patchCertificatesV1CertificateSigningRequest(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1CertificateSigningRequestApproval(
    param:
      CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.patchCertificatesV1CertificateSigningRequestApproval(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1CertificateSigningRequestStatus(
    param:
      CertificatesV1ApiPatchCertificatesV1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.patchCertificatesV1CertificateSigningRequestStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1CertificateSigningRequest(
    param: CertificatesV1ApiReadCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.readCertificatesV1CertificateSigningRequest(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1CertificateSigningRequestApproval(
    param:
      CertificatesV1ApiReadCertificatesV1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.readCertificatesV1CertificateSigningRequestApproval(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1CertificateSigningRequestStatus(
    param:
      CertificatesV1ApiReadCertificatesV1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.readCertificatesV1CertificateSigningRequestStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1CertificateSigningRequest(
    param:
      CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1CertificateSigningRequest(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1CertificateSigningRequestApproval(
    param:
      CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1CertificateSigningRequestApproval(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1CertificateSigningRequestStatus(
    param:
      CertificatesV1ApiReplaceCertificatesV1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1CertificateSigningRequestStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCertificatesV1CertificateSigningRequest(
    param: CertificatesV1ApiWatchCertificatesV1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCertificatesV1CertificateSigningRequest(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCertificatesV1CertificateSigningRequestList(
    param:
      CertificatesV1ApiWatchCertificatesV1CertificateSigningRequestListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCertificatesV1CertificateSigningRequestList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableCertificatesV1beta1Api } from "./ObservableAPI.ts";
import {
  CertificatesV1beta1ApiRequestFactory,
  CertificatesV1beta1ApiResponseProcessor,
} from "../apis/CertificatesV1beta1Api.ts";

export interface CertificatesV1beta1ApiCreateCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * 
     * @type IoK8sApiCertificatesV1beta1CertificateSigningRequest
     * @memberof CertificatesV1beta1ApicreateCertificatesV1beta1CertificateSigningRequest
     */
  body: IoK8sApiCertificatesV1beta1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApicreateCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApicreateCertificatesV1beta1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1beta1ApicreateCertificatesV1beta1CertificateSigningRequest
     */
  fieldManager?: string;
}

export interface CertificatesV1beta1ApiDeleteCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CertificateSigningRequest
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CertificatesV1beta1ApiDeleteCertificatesV1beta1CollectionCertificateSigningRequestRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CertificatesV1beta1ApideleteCertificatesV1beta1CollectionCertificateSigningRequest
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CertificatesV1beta1ApiGetCertificatesV1beta1APIResourcesRequest {
}

export interface CertificatesV1beta1ApiListCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1beta1ApilistCertificatesV1beta1CertificateSigningRequest
     */
  watch?: boolean;
}

export interface CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequest
     */
  force?: boolean;
}

export interface CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestApproval
     */
  force?: boolean;
}

export interface CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CertificatesV1beta1ApipatchCertificatesV1beta1CertificateSigningRequestStatus
     */
  force?: boolean;
}

export interface CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequest
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequest
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequest
     */
  _export?: boolean;
}

export interface CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequestApproval
     */
  pretty?: string;
}

export interface CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireadCertificatesV1beta1CertificateSigningRequestStatus
     */
  pretty?: string;
}

export interface CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequest
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1beta1CertificateSigningRequest
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequest
     */
  body: IoK8sApiCertificatesV1beta1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequest
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequest
     */
  fieldManager?: string;
}

export interface CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestApprovalRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestApproval
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1beta1CertificateSigningRequest
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestApproval
     */
  body: IoK8sApiCertificatesV1beta1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestApproval
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestApproval
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestApproval
     */
  fieldManager?: string;
}

export interface CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestStatusRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCertificatesV1beta1CertificateSigningRequest
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestStatus
     */
  body: IoK8sApiCertificatesV1beta1CertificateSigningRequest;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CertificatesV1beta1ApireplaceCertificatesV1beta1CertificateSigningRequestStatus
     */
  fieldManager?: string;
}

export interface CertificatesV1beta1ApiWatchCertificatesV1beta1CertificateSigningRequestRequest {
  /**
     * name of the CertificateSigningRequest
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequest
     */
  watch?: boolean;
}

export interface CertificatesV1beta1ApiWatchCertificatesV1beta1CertificateSigningRequestListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CertificatesV1beta1ApiwatchCertificatesV1beta1CertificateSigningRequestList
     */
  watch?: boolean;
}

export class ObjectCertificatesV1beta1Api {
  private api: ObservableCertificatesV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: CertificatesV1beta1ApiRequestFactory,
    responseProcessor?: CertificatesV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableCertificatesV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
  public createCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiCreateCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.createCertificatesV1beta1CertificateSigningRequest(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
  public deleteCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiDeleteCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCertificatesV1beta1CertificateSigningRequest(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
  public deleteCertificatesV1beta1CollectionCertificateSigningRequest(
    param:
      CertificatesV1beta1ApiDeleteCertificatesV1beta1CollectionCertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteCertificatesV1beta1CollectionCertificateSigningRequest(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getCertificatesV1beta1APIResources(
    param: CertificatesV1beta1ApiGetCertificatesV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getCertificatesV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
  public listCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiListCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequestList> {
    return this.api.listCertificatesV1beta1CertificateSigningRequest(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.patchCertificatesV1beta1CertificateSigningRequest(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1beta1CertificateSigningRequestApproval(
    param:
      CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.patchCertificatesV1beta1CertificateSigningRequestApproval(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public patchCertificatesV1beta1CertificateSigningRequestStatus(
    param:
      CertificatesV1beta1ApiPatchCertificatesV1beta1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.patchCertificatesV1beta1CertificateSigningRequestStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.readCertificatesV1beta1CertificateSigningRequest(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1beta1CertificateSigningRequestApproval(
    param:
      CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.readCertificatesV1beta1CertificateSigningRequestApproval(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public readCertificatesV1beta1CertificateSigningRequestStatus(
    param:
      CertificatesV1beta1ApiReadCertificatesV1beta1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.readCertificatesV1beta1CertificateSigningRequestStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1beta1CertificateSigningRequest(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1beta1CertificateSigningRequestApproval(
    param:
      CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestApprovalRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1beta1CertificateSigningRequestApproval(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
  public replaceCertificatesV1beta1CertificateSigningRequestStatus(
    param:
      CertificatesV1beta1ApiReplaceCertificatesV1beta1CertificateSigningRequestStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCertificatesV1beta1CertificateSigningRequest> {
    return this.api.replaceCertificatesV1beta1CertificateSigningRequestStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCertificatesV1beta1CertificateSigningRequest(
    param:
      CertificatesV1beta1ApiWatchCertificatesV1beta1CertificateSigningRequestRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCertificatesV1beta1CertificateSigningRequest(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCertificatesV1beta1CertificateSigningRequestList(
    param:
      CertificatesV1beta1ApiWatchCertificatesV1beta1CertificateSigningRequestListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCertificatesV1beta1CertificateSigningRequestList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableCoordinationApi } from "./ObservableAPI.ts";
import {
  CoordinationApiRequestFactory,
  CoordinationApiResponseProcessor,
} from "../apis/CoordinationApi.ts";

export interface CoordinationApiGetCoordinationAPIGroupRequest {
}

export class ObjectCoordinationApi {
  private api: ObservableCoordinationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: CoordinationApiRequestFactory,
    responseProcessor?: CoordinationApiResponseProcessor,
  ) {
    this.api = new ObservableCoordinationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getCoordinationAPIGroup(
    param: CoordinationApiGetCoordinationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getCoordinationAPIGroup(options).toPromise();
  }
}

import { ObservableCoordinationV1Api } from "./ObservableAPI.ts";
import {
  CoordinationV1ApiRequestFactory,
  CoordinationV1ApiResponseProcessor,
} from "../apis/CoordinationV1Api.ts";

export interface CoordinationV1ApiCreateCoordinationV1NamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApicreateCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoordinationV1Lease
     * @memberof CoordinationV1ApicreateCoordinationV1NamespacedLease
     */
  body: IoK8sApiCoordinationV1Lease;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApicreateCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApicreateCoordinationV1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1ApicreateCoordinationV1NamespacedLease
     */
  fieldManager?: string;
}

export interface CoordinationV1ApiDeleteCoordinationV1CollectionNamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoordinationV1ApideleteCoordinationV1CollectionNamespacedLease
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoordinationV1ApiDeleteCoordinationV1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoordinationV1ApideleteCoordinationV1NamespacedLease
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoordinationV1ApiGetCoordinationV1APIResourcesRequest {
}

export interface CoordinationV1ApiListCoordinationV1LeaseForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApilistCoordinationV1LeaseForAllNamespaces
     */
  watch?: boolean;
}

export interface CoordinationV1ApiListCoordinationV1NamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApilistCoordinationV1NamespacedLease
     */
  watch?: boolean;
}

export interface CoordinationV1ApiPatchCoordinationV1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoordinationV1ApipatchCoordinationV1NamespacedLease
     */
  force?: boolean;
}

export interface CoordinationV1ApiReadCoordinationV1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApireadCoordinationV1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApireadCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApireadCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoordinationV1ApireadCoordinationV1NamespacedLease
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoordinationV1ApireadCoordinationV1NamespacedLease
     */
  _export?: boolean;
}

export interface CoordinationV1ApiReplaceCoordinationV1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoordinationV1Lease
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  body: IoK8sApiCoordinationV1Lease;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1ApireplaceCoordinationV1NamespacedLease
     */
  fieldManager?: string;
}

export interface CoordinationV1ApiWatchCoordinationV1LeaseListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1LeaseListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoordinationV1ApiWatchCoordinationV1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLease
     */
  watch?: boolean;
}

export interface CoordinationV1ApiWatchCoordinationV1NamespacedLeaseListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1ApiwatchCoordinationV1NamespacedLeaseList
     */
  watch?: boolean;
}

export class ObjectCoordinationV1Api {
  private api: ObservableCoordinationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: CoordinationV1ApiRequestFactory,
    responseProcessor?: CoordinationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableCoordinationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a Lease
     * @param param the request object
     */
  public createCoordinationV1NamespacedLease(
    param: CoordinationV1ApiCreateCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1Lease> {
    return this.api.createCoordinationV1NamespacedLease(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Lease
     * @param param the request object
     */
  public deleteCoordinationV1CollectionNamespacedLease(
    param:
      CoordinationV1ApiDeleteCoordinationV1CollectionNamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoordinationV1CollectionNamespacedLease(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Lease
     * @param param the request object
     */
  public deleteCoordinationV1NamespacedLease(
    param: CoordinationV1ApiDeleteCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoordinationV1NamespacedLease(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getCoordinationV1APIResources(
    param: CoordinationV1ApiGetCoordinationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getCoordinationV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
  public listCoordinationV1LeaseForAllNamespaces(
    param: CoordinationV1ApiListCoordinationV1LeaseForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1LeaseList> {
    return this.api.listCoordinationV1LeaseForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
  public listCoordinationV1NamespacedLease(
    param: CoordinationV1ApiListCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1LeaseList> {
    return this.api.listCoordinationV1NamespacedLease(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Lease
     * @param param the request object
     */
  public patchCoordinationV1NamespacedLease(
    param: CoordinationV1ApiPatchCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1Lease> {
    return this.api.patchCoordinationV1NamespacedLease(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Lease
     * @param param the request object
     */
  public readCoordinationV1NamespacedLease(
    param: CoordinationV1ApiReadCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1Lease> {
    return this.api.readCoordinationV1NamespacedLease(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Lease
     * @param param the request object
     */
  public replaceCoordinationV1NamespacedLease(
    param: CoordinationV1ApiReplaceCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1Lease> {
    return this.api.replaceCoordinationV1NamespacedLease(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoordinationV1LeaseListForAllNamespaces(
    param: CoordinationV1ApiWatchCoordinationV1LeaseListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1LeaseListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoordinationV1NamespacedLease(
    param: CoordinationV1ApiWatchCoordinationV1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1NamespacedLease(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoordinationV1NamespacedLeaseList(
    param: CoordinationV1ApiWatchCoordinationV1NamespacedLeaseListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1NamespacedLeaseList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableCoordinationV1beta1Api } from "./ObservableAPI.ts";
import {
  CoordinationV1beta1ApiRequestFactory,
  CoordinationV1beta1ApiResponseProcessor,
} from "../apis/CoordinationV1beta1Api.ts";

export interface CoordinationV1beta1ApiCreateCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApicreateCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoordinationV1beta1Lease
     * @memberof CoordinationV1beta1ApicreateCoordinationV1beta1NamespacedLease
     */
  body: IoK8sApiCoordinationV1beta1Lease;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApicreateCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1beta1ApicreateCoordinationV1beta1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1beta1ApicreateCoordinationV1beta1NamespacedLease
     */
  fieldManager?: string;
}

export interface CoordinationV1beta1ApiDeleteCoordinationV1beta1CollectionNamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1CollectionNamespacedLease
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoordinationV1beta1ApiDeleteCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoordinationV1beta1ApideleteCoordinationV1beta1NamespacedLease
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoordinationV1beta1ApiGetCoordinationV1beta1APIResourcesRequest {
}

export interface CoordinationV1beta1ApiListCoordinationV1beta1LeaseForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1LeaseForAllNamespaces
     */
  watch?: boolean;
}

export interface CoordinationV1beta1ApiListCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1beta1ApilistCoordinationV1beta1NamespacedLease
     */
  watch?: boolean;
}

export interface CoordinationV1beta1ApiPatchCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoordinationV1beta1ApipatchCoordinationV1beta1NamespacedLease
     */
  force?: boolean;
}

export interface CoordinationV1beta1ApiReadCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1beta1ApireadCoordinationV1beta1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApireadCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApireadCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoordinationV1beta1ApireadCoordinationV1beta1NamespacedLease
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoordinationV1beta1ApireadCoordinationV1beta1NamespacedLease
     */
  _export?: boolean;
}

export interface CoordinationV1beta1ApiReplaceCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoordinationV1beta1Lease
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  body: IoK8sApiCoordinationV1beta1Lease;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoordinationV1beta1ApireplaceCoordinationV1beta1NamespacedLease
     */
  fieldManager?: string;
}

export interface CoordinationV1beta1ApiWatchCoordinationV1beta1LeaseListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1LeaseListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoordinationV1beta1ApiWatchCoordinationV1beta1NamespacedLeaseRequest {
  /**
     * name of the Lease
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLease
     */
  watch?: boolean;
}

export interface CoordinationV1beta1ApiWatchCoordinationV1beta1NamespacedLeaseListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoordinationV1beta1ApiwatchCoordinationV1beta1NamespacedLeaseList
     */
  watch?: boolean;
}

export class ObjectCoordinationV1beta1Api {
  private api: ObservableCoordinationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: CoordinationV1beta1ApiRequestFactory,
    responseProcessor?: CoordinationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableCoordinationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a Lease
     * @param param the request object
     */
  public createCoordinationV1beta1NamespacedLease(
    param:
      CoordinationV1beta1ApiCreateCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1Lease> {
    return this.api.createCoordinationV1beta1NamespacedLease(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Lease
     * @param param the request object
     */
  public deleteCoordinationV1beta1CollectionNamespacedLease(
    param:
      CoordinationV1beta1ApiDeleteCoordinationV1beta1CollectionNamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoordinationV1beta1CollectionNamespacedLease(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Lease
     * @param param the request object
     */
  public deleteCoordinationV1beta1NamespacedLease(
    param:
      CoordinationV1beta1ApiDeleteCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoordinationV1beta1NamespacedLease(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getCoordinationV1beta1APIResources(
    param: CoordinationV1beta1ApiGetCoordinationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getCoordinationV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
  public listCoordinationV1beta1LeaseForAllNamespaces(
    param:
      CoordinationV1beta1ApiListCoordinationV1beta1LeaseForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1LeaseList> {
    return this.api.listCoordinationV1beta1LeaseForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
  public listCoordinationV1beta1NamespacedLease(
    param: CoordinationV1beta1ApiListCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1LeaseList> {
    return this.api.listCoordinationV1beta1NamespacedLease(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Lease
     * @param param the request object
     */
  public patchCoordinationV1beta1NamespacedLease(
    param: CoordinationV1beta1ApiPatchCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1Lease> {
    return this.api.patchCoordinationV1beta1NamespacedLease(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Lease
     * @param param the request object
     */
  public readCoordinationV1beta1NamespacedLease(
    param: CoordinationV1beta1ApiReadCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1Lease> {
    return this.api.readCoordinationV1beta1NamespacedLease(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Lease
     * @param param the request object
     */
  public replaceCoordinationV1beta1NamespacedLease(
    param:
      CoordinationV1beta1ApiReplaceCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoordinationV1beta1Lease> {
    return this.api.replaceCoordinationV1beta1NamespacedLease(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoordinationV1beta1LeaseListForAllNamespaces(
    param:
      CoordinationV1beta1ApiWatchCoordinationV1beta1LeaseListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1beta1LeaseListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoordinationV1beta1NamespacedLease(
    param: CoordinationV1beta1ApiWatchCoordinationV1beta1NamespacedLeaseRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1beta1NamespacedLease(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoordinationV1beta1NamespacedLeaseList(
    param:
      CoordinationV1beta1ApiWatchCoordinationV1beta1NamespacedLeaseListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoordinationV1beta1NamespacedLeaseList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableCoreApi } from "./ObservableAPI.ts";
import {
  CoreApiRequestFactory,
  CoreApiResponseProcessor,
} from "../apis/CoreApi.ts";

export interface CoreApiGetCoreAPIVersionsRequest {
}

export class ObjectCoreApi {
  private api: ObservableCoreApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: CoreApiRequestFactory,
    responseProcessor?: CoreApiResponseProcessor,
  ) {
    this.api = new ObservableCoreApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get available API versions
     * @param param the request object
     */
  public getCoreAPIVersions(
    param: CoreApiGetCoreAPIVersionsRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIVersions> {
    return this.api.getCoreAPIVersions(options).toPromise();
  }
}

import { ObservableCoreV1Api } from "./ObservableAPI.ts";
import {
  CoreV1ApiRequestFactory,
  CoreV1ApiResponseProcessor,
} from "../apis/CoreV1Api.ts";

export interface CoreV1ApiConnectCoreV1DeleteNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1DeleteNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1DeleteNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1DeleteNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1DeleteNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedPodAttachRequest {
  /**
     * name of the PodAttachOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  namespace: string;
  /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  container?: string;
  /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  stderr?: boolean;
  /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  stdin?: boolean;
  /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  stdout?: boolean;
  /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodAttach
     */
  tty?: boolean;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedPodExecRequest {
  /**
     * name of the PodExecOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  namespace: string;
  /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  command?: string;
  /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  container?: string;
  /**
     * Redirect the standard error stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  stderr?: boolean;
  /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  stdin?: boolean;
  /**
     * Redirect the standard output stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  stdout?: boolean;
  /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodExec
     */
  tty?: boolean;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedPodPortforwardRequest {
  /**
     * name of the PodPortForwardOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodPortforward
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodPortforward
     */
  namespace: string;
  /**
     * List of ports to forward Required when using WebSockets
     * @type number
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodPortforward
     */
  ports?: number;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1GetNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1GetNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1GetNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1HeadNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1HeadNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1OptionsNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1OptionsNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PatchNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PatchNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedPodAttachRequest {
  /**
     * name of the PodAttachOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  namespace: string;
  /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  container?: string;
  /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  stderr?: boolean;
  /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  stdin?: boolean;
  /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  stdout?: boolean;
  /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodAttach
     */
  tty?: boolean;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedPodExecRequest {
  /**
     * name of the PodExecOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  namespace: string;
  /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  command?: string;
  /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  container?: string;
  /**
     * Redirect the standard error stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  stderr?: boolean;
  /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  stdin?: boolean;
  /**
     * Redirect the standard output stream of the pod for this call. Defaults to true.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  stdout?: boolean;
  /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodExec
     */
  tty?: boolean;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedPodPortforwardRequest {
  /**
     * name of the PodPortForwardOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodPortforward
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodPortforward
     */
  namespace: string;
  /**
     * List of ports to forward Required when using WebSockets
     * @type number
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodPortforward
     */
  ports?: number;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PostNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PostNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PostNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PutNamespacedPodProxyRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxy
     */
  namespace: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PutNamespacedPodProxyWithPathRequest {
  /**
     * name of the PodProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to pod.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedPodProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PutNamespacedServiceProxyRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxy
     */
  namespace: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
  /**
     * name of the ServiceProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxyWithPath
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxyWithPath
     */
  namespace: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxyWithPath
     */
  path: string;
  /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNamespacedServiceProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiConnectCoreV1PutNodeProxyRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNodeProxy
     */
  name: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNodeProxy
     */
  path?: string;
}

export interface CoreV1ApiConnectCoreV1PutNodeProxyWithPathRequest {
  /**
     * name of the NodeProxyOptions
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNodeProxyWithPath
     */
  name: string;
  /**
     * path to the resource
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNodeProxyWithPath
     */
  path: string;
  /**
     * Path is the URL path to use for the current proxy request to node.
     * @type string
     * @memberof CoreV1ApiconnectCoreV1PutNodeProxyWithPath
     */
  path2?: string;
}

export interface CoreV1ApiCreateCoreV1NamespaceRequest {
  /**
     * 
     * @type IoK8sApiCoreV1Namespace
     * @memberof CoreV1ApicreateCoreV1Namespace
     */
  body: IoK8sApiCoreV1Namespace;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1Namespace
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1Namespace
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1Namespace
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Binding
     * @memberof CoreV1ApicreateCoreV1NamespacedBinding
     */
  body: IoK8sApiCoreV1Binding;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedBinding
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedBinding
     */
  pretty?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedConfigMapRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ConfigMap
     * @memberof CoreV1ApicreateCoreV1NamespacedConfigMap
     */
  body: IoK8sApiCoreV1ConfigMap;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedConfigMap
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedConfigMap
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedEndpointsRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Endpoints
     * @memberof CoreV1ApicreateCoreV1NamespacedEndpoints
     */
  body: IoK8sApiCoreV1Endpoints;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEndpoints
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEndpoints
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Event
     * @memberof CoreV1ApicreateCoreV1NamespacedEvent
     */
  body: IoK8sApiCoreV1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedEvent
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedLimitRangeRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1LimitRange
     * @memberof CoreV1ApicreateCoreV1NamespacedLimitRange
     */
  body: IoK8sApiCoreV1LimitRange;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedLimitRange
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedLimitRange
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolumeClaim
     * @memberof CoreV1ApicreateCoreV1NamespacedPersistentVolumeClaim
     */
  body: IoK8sApiCoreV1PersistentVolumeClaim;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPersistentVolumeClaim
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPersistentVolumeClaim
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedPodRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Pod
     * @memberof CoreV1ApicreateCoreV1NamespacedPod
     */
  body: IoK8sApiCoreV1Pod;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPod
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPod
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedPodBindingRequest {
  /**
     * name of the Binding
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Binding
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  body: IoK8sApiCoreV1Binding;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodBinding
     */
  pretty?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedPodEvictionRequest {
  /**
     * name of the Eviction
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiPolicyV1beta1Eviction
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  body: IoK8sApiPolicyV1beta1Eviction;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodEviction
     */
  pretty?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedPodTemplateRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1PodTemplate
     * @memberof CoreV1ApicreateCoreV1NamespacedPodTemplate
     */
  body: IoK8sApiCoreV1PodTemplate;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodTemplate
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedPodTemplate
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedReplicationControllerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ReplicationController
     * @memberof CoreV1ApicreateCoreV1NamespacedReplicationController
     */
  body: IoK8sApiCoreV1ReplicationController;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedReplicationController
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedReplicationController
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedResourceQuotaRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ResourceQuota
     * @memberof CoreV1ApicreateCoreV1NamespacedResourceQuota
     */
  body: IoK8sApiCoreV1ResourceQuota;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedResourceQuota
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedResourceQuota
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedSecretRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Secret
     * @memberof CoreV1ApicreateCoreV1NamespacedSecret
     */
  body: IoK8sApiCoreV1Secret;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedSecret
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedSecret
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedServiceRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedService
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Service
     * @memberof CoreV1ApicreateCoreV1NamespacedService
     */
  body: IoK8sApiCoreV1Service;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedService
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedServiceAccountRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ServiceAccount
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccount
     */
  body: IoK8sApiCoreV1ServiceAccount;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccount
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccount
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1NamespacedServiceAccountTokenRequest {
  /**
     * name of the TokenRequest
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAuthenticationV1TokenRequest
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  body: IoK8sApiAuthenticationV1TokenRequest;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1NamespacedServiceAccountToken
     */
  pretty?: string;
}

export interface CoreV1ApiCreateCoreV1NodeRequest {
  /**
     * 
     * @type IoK8sApiCoreV1Node
     * @memberof CoreV1ApicreateCoreV1Node
     */
  body: IoK8sApiCoreV1Node;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1Node
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1Node
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1Node
     */
  fieldManager?: string;
}

export interface CoreV1ApiCreateCoreV1PersistentVolumeRequest {
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolume
     * @memberof CoreV1ApicreateCoreV1PersistentVolume
     */
  body: IoK8sApiCoreV1PersistentVolume;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApicreateCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApicreateCoreV1PersistentVolume
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApicreateCoreV1PersistentVolume
     */
  fieldManager?: string;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedConfigMapRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedConfigMap
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedEndpointsRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEndpoints
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedLimitRangeRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedLimitRange
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPersistentVolumeClaim
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedPodRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPod
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedPodTemplateRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedPodTemplate
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedReplicationControllerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedReplicationController
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedResourceQuotaRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedResourceQuota
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedSecretRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedSecret
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNamespacedServiceAccountRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNamespacedServiceAccount
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionNodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionNode
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1CollectionPersistentVolumeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1CollectionPersistentVolume
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespaceRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1Namespace
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedConfigMapRequest {
  /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedConfigMap
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedEndpointsRequest {
  /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedEndpoints
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedLimitRangeRequest {
  /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedLimitRange
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedPersistentVolumeClaim
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedPodRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedPod
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedPodTemplateRequest {
  /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedPodTemplate
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedReplicationControllerRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedReplicationController
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedResourceQuotaRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedResourceQuota
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedSecretRequest {
  /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedSecret
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedServiceRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedService
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NamespacedServiceAccountRequest {
  /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1NamespacedServiceAccount
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1NodeRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApideleteCoreV1Node
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1Node
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1Node
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1Node
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1Node
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1Node
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1Node
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiDeleteCoreV1PersistentVolumeRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof CoreV1ApideleteCoreV1PersistentVolume
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface CoreV1ApiGetCoreV1APIResourcesRequest {
}

export interface CoreV1ApiListCoreV1ComponentStatusRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ComponentStatus
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1ConfigMapForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ConfigMapForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1EndpointsForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1EndpointsForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1EventForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1EventForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1LimitRangeForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1LimitRangeForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespaceRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1Namespace
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedConfigMapRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedConfigMap
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedEndpointsRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedEndpoints
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedEvent
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedLimitRangeRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedLimitRange
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPersistentVolumeClaim
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedPodRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPod
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedPodTemplateRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedPodTemplate
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedReplicationControllerRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedReplicationController
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedResourceQuotaRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedResourceQuota
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedSecretRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedSecret
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedServiceRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedService
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NamespacedServiceAccountRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1NamespacedServiceAccount
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1NodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1Node
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1Node
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1Node
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1Node
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1Node
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1PersistentVolumeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PersistentVolume
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PersistentVolumeClaimForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1PodForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PodForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1PodTemplateForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1PodTemplateForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1ReplicationControllerForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ReplicationControllerForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1ResourceQuotaForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ResourceQuotaForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1SecretForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1SecretForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1ServiceAccountForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ServiceAccountForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiListCoreV1ServiceForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApilistCoreV1ServiceForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespaceRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1Namespace
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespaceStatusRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespaceStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedConfigMapRequest {
  /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedConfigMap
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedEndpointsRequest {
  /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedEndpoints
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedEvent
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedLimitRangeRequest {
  /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedLimitRange
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaim
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedPersistentVolumeClaimStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedPodRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedPod
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedPodStatusRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedPodStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedPodTemplateRequest {
  /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedPodTemplate
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedReplicationControllerRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationController
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedReplicationControllerScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerScale
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedReplicationControllerStatusRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedReplicationControllerStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedResourceQuotaRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuota
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedResourceQuotaStatusRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedResourceQuotaStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedSecretRequest {
  /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedSecret
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedServiceRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedService
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedServiceAccountRequest {
  /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceAccount
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NamespacedServiceStatusRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NamespacedServiceStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NodeRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApipatchCoreV1Node
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1Node
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1Node
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1Node
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1Node
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1Node
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1NodeStatusRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1NodeStatus
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1PersistentVolumeRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1PersistentVolume
     */
  force?: boolean;
}

export interface CoreV1ApiPatchCoreV1PersistentVolumeStatusRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof CoreV1ApipatchCoreV1PersistentVolumeStatus
     */
  force?: boolean;
}

export interface CoreV1ApiReadCoreV1ComponentStatusRequest {
  /**
     * name of the ComponentStatus
     * @type string
     * @memberof CoreV1ApireadCoreV1ComponentStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1ComponentStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespaceRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireadCoreV1Namespace
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1Namespace
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1Namespace
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1Namespace
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespaceStatusRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespaceStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespaceStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedConfigMapRequest {
  /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedConfigMap
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedConfigMap
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedConfigMap
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedEndpointsRequest {
  /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEndpoints
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedEndpoints
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedEndpoints
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedEvent
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedEvent
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedLimitRangeRequest {
  /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedLimitRange
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedLimitRange
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedLimitRange
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaim
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaim
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaim
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaimStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaimStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPersistentVolumeClaimStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedPodRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPod
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPod
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPod
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedPodLogRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  namespace: string;
  /**
     * The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  container?: string;
  /**
     * Follow the log stream of the pod. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  follow?: boolean;
  /**
     * insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver&#39;s TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  insecureSkipTLSVerifyBackend?: boolean;
  /**
     * If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @type number
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  limitBytes?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  pretty?: string;
  /**
     * Return previous terminated container logs. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  previous?: boolean;
  /**
     * A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @type number
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  sinceSeconds?: number;
  /**
     * If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @type number
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  tailLines?: number;
  /**
     * If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodLog
     */
  timestamps?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedPodStatusRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedPodTemplateRequest {
  /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodTemplate
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodTemplate
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedPodTemplate
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedReplicationControllerRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationController
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationController
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationController
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedReplicationControllerScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerScale
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerScale
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedReplicationControllerStatusRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedReplicationControllerStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedResourceQuotaRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuota
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuota
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuota
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedResourceQuotaStatusRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuotaStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuotaStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedResourceQuotaStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NamespacedSecretRequest {
  /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedSecret
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedSecret
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedSecret
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedServiceRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedService
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedService
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedService
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedService
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedServiceAccountRequest {
  /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceAccount
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedServiceAccount
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1NamespacedServiceAccount
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NamespacedServiceStatusRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NamespacedServiceStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1NodeRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireadCoreV1Node
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1Node
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1Node
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1Node
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1NodeStatusRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireadCoreV1NodeStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1NodeStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReadCoreV1PersistentVolumeRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireadCoreV1PersistentVolume
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1PersistentVolume
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof CoreV1ApireadCoreV1PersistentVolume
     */
  _export?: boolean;
}

export interface CoreV1ApiReadCoreV1PersistentVolumeStatusRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireadCoreV1PersistentVolumeStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireadCoreV1PersistentVolumeStatus
     */
  pretty?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespaceRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Namespace
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1Namespace
     * @memberof CoreV1ApireplaceCoreV1Namespace
     */
  body: IoK8sApiCoreV1Namespace;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Namespace
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Namespace
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Namespace
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespaceFinalizeRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceFinalize
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1Namespace
     * @memberof CoreV1ApireplaceCoreV1NamespaceFinalize
     */
  body: IoK8sApiCoreV1Namespace;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceFinalize
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceFinalize
     */
  fieldManager?: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceFinalize
     */
  pretty?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespaceStatusRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1Namespace
     * @memberof CoreV1ApireplaceCoreV1NamespaceStatus
     */
  body: IoK8sApiCoreV1Namespace;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespaceStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedConfigMapRequest {
  /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ConfigMap
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  body: IoK8sApiCoreV1ConfigMap;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedConfigMap
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedEndpointsRequest {
  /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Endpoints
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  body: IoK8sApiCoreV1Endpoints;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEndpoints
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Event
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  body: IoK8sApiCoreV1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedEvent
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedLimitRangeRequest {
  /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1LimitRange
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  body: IoK8sApiCoreV1LimitRange;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedLimitRange
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  body: IoK8sApiCoreV1PersistentVolumeClaim;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaim
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  body: IoK8sApiCoreV1PersistentVolumeClaim;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPersistentVolumeClaimStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedPodRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Pod
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  body: IoK8sApiCoreV1Pod;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPod
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedPodStatusRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Pod
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  body: IoK8sApiCoreV1Pod;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedPodTemplateRequest {
  /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1PodTemplate
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  body: IoK8sApiCoreV1PodTemplate;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedPodTemplate
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedReplicationControllerRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ReplicationController
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  body: IoK8sApiCoreV1ReplicationController;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationController
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedReplicationControllerScaleRequest {
  /**
     * name of the Scale
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiAutoscalingV1Scale
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  body: IoK8sApiAutoscalingV1Scale;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerScale
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedReplicationControllerStatusRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ReplicationController
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  body: IoK8sApiCoreV1ReplicationController;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedReplicationControllerStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedResourceQuotaRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ResourceQuota
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  body: IoK8sApiCoreV1ResourceQuota;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuota
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedResourceQuotaStatusRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ResourceQuota
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  body: IoK8sApiCoreV1ResourceQuota;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedResourceQuotaStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedSecretRequest {
  /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Secret
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  body: IoK8sApiCoreV1Secret;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedSecret
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedServiceRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Service
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  body: IoK8sApiCoreV1Service;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedService
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedServiceAccountRequest {
  /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1ServiceAccount
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  body: IoK8sApiCoreV1ServiceAccount;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceAccount
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NamespacedServiceStatusRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiCoreV1Service
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  body: IoK8sApiCoreV1Service;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NamespacedServiceStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NodeRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Node
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1Node
     * @memberof CoreV1ApireplaceCoreV1Node
     */
  body: IoK8sApiCoreV1Node;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Node
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Node
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1Node
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1NodeStatusRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NodeStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1Node
     * @memberof CoreV1ApireplaceCoreV1NodeStatus
     */
  body: IoK8sApiCoreV1Node;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NodeStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NodeStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1NodeStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1PersistentVolumeRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolume
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolume
     * @memberof CoreV1ApireplaceCoreV1PersistentVolume
     */
  body: IoK8sApiCoreV1PersistentVolume;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolume
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolume
     */
  fieldManager?: string;
}

export interface CoreV1ApiReplaceCoreV1PersistentVolumeStatusRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolumeStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiCoreV1PersistentVolume
     * @memberof CoreV1ApireplaceCoreV1PersistentVolumeStatus
     */
  body: IoK8sApiCoreV1PersistentVolume;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolumeStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolumeStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof CoreV1ApireplaceCoreV1PersistentVolumeStatus
     */
  fieldManager?: string;
}

export interface CoreV1ApiWatchCoreV1ConfigMapListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ConfigMapListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1EndpointsListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1EndpointsListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1EventListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1EventListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1LimitRangeListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1LimitRangeListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespaceRequest {
  /**
     * name of the Namespace
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1Namespace
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespaceListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespaceList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedConfigMapRequest {
  /**
     * name of the ConfigMap
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMap
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedConfigMapListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedConfigMapList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedEndpointsRequest {
  /**
     * name of the Endpoints
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpoints
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedEndpointsListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEndpointsList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEvent
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedEventListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedEventList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedLimitRangeRequest {
  /**
     * name of the LimitRange
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRange
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedLimitRangeListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedLimitRangeList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPersistentVolumeClaimRequest {
  /**
     * name of the PersistentVolumeClaim
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaim
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPersistentVolumeClaimListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPersistentVolumeClaimList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPodRequest {
  /**
     * name of the Pod
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPod
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPodListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPodTemplateRequest {
  /**
     * name of the PodTemplate
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplate
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedPodTemplateListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedPodTemplateList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedReplicationControllerRequest {
  /**
     * name of the ReplicationController
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationController
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedReplicationControllerListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedReplicationControllerList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedResourceQuotaRequest {
  /**
     * name of the ResourceQuota
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuota
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedResourceQuotaListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedResourceQuotaList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedSecretRequest {
  /**
     * name of the Secret
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecret
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedSecretListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedSecretList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedServiceRequest {
  /**
     * name of the Service
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedService
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedServiceAccountRequest {
  /**
     * name of the ServiceAccount
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccount
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedServiceAccountListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceAccountList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NamespacedServiceListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NamespacedServiceList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NodeRequest {
  /**
     * name of the Node
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1Node
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1NodeListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1NodeList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1PersistentVolumeRequest {
  /**
     * name of the PersistentVolume
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolume
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeClaimListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1PersistentVolumeListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PersistentVolumeList
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1PodListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PodListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1PodTemplateListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1PodTemplateListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1ReplicationControllerListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ReplicationControllerListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1ResourceQuotaListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ResourceQuotaListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1SecretListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1SecretListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1ServiceAccountListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ServiceAccountListForAllNamespaces
     */
  watch?: boolean;
}

export interface CoreV1ApiWatchCoreV1ServiceListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof CoreV1ApiwatchCoreV1ServiceListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectCoreV1Api {
  private api: ObservableCoreV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: CoreV1ApiRequestFactory,
    responseProcessor?: CoreV1ApiResponseProcessor,
  ) {
    this.api = new ObservableCoreV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1DeleteNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1DeleteNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1DeleteNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1DeleteNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1DeleteNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1DeleteNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1DeleteNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1DeleteNodeProxy(
    param: CoreV1ApiConnectCoreV1DeleteNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNodeProxy(
      param.name,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1DeleteNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1DeleteNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1DeleteNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to attach of Pod
     * @param param the request object
     */
  public connectCoreV1GetNamespacedPodAttach(
    param: CoreV1ApiConnectCoreV1GetNamespacedPodAttachRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedPodAttach(
      param.name,
      param.namespace,
      param.container,
      param.stderr,
      param.stdin,
      param.stdout,
      param.tty,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to exec of Pod
     * @param param the request object
     */
  public connectCoreV1GetNamespacedPodExec(
    param: CoreV1ApiConnectCoreV1GetNamespacedPodExecRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedPodExec(
      param.name,
      param.namespace,
      param.command,
      param.container,
      param.stderr,
      param.stdin,
      param.stdout,
      param.tty,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to portforward of Pod
     * @param param the request object
     */
  public connectCoreV1GetNamespacedPodPortforward(
    param: CoreV1ApiConnectCoreV1GetNamespacedPodPortforwardRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedPodPortforward(
      param.name,
      param.namespace,
      param.ports,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1GetNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1GetNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1GetNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1GetNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1GetNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1GetNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1GetNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1GetNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1GetNodeProxy(
    param: CoreV1ApiConnectCoreV1GetNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNodeProxy(param.name, param.path, options)
      .toPromise();
  }

  /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1GetNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1GetNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1GetNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1HeadNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1HeadNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1HeadNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1HeadNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1HeadNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1HeadNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1HeadNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1HeadNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1HeadNodeProxy(
    param: CoreV1ApiConnectCoreV1HeadNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNodeProxy(param.name, param.path, options)
      .toPromise();
  }

  /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1HeadNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1HeadNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1HeadNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1OptionsNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1OptionsNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1OptionsNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1OptionsNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1OptionsNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1OptionsNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1OptionsNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1OptionsNodeProxy(
    param: CoreV1ApiConnectCoreV1OptionsNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNodeProxy(
      param.name,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1OptionsNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1OptionsNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1OptionsNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PatchNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1PatchNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PatchNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1PatchNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PatchNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1PatchNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PatchNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1PatchNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PatchNodeProxy(
    param: CoreV1ApiConnectCoreV1PatchNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNodeProxy(param.name, param.path, options)
      .toPromise();
  }

  /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PatchNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1PatchNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PatchNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to attach of Pod
     * @param param the request object
     */
  public connectCoreV1PostNamespacedPodAttach(
    param: CoreV1ApiConnectCoreV1PostNamespacedPodAttachRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedPodAttach(
      param.name,
      param.namespace,
      param.container,
      param.stderr,
      param.stdin,
      param.stdout,
      param.tty,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to exec of Pod
     * @param param the request object
     */
  public connectCoreV1PostNamespacedPodExec(
    param: CoreV1ApiConnectCoreV1PostNamespacedPodExecRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedPodExec(
      param.name,
      param.namespace,
      param.command,
      param.container,
      param.stderr,
      param.stdin,
      param.stdout,
      param.tty,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to portforward of Pod
     * @param param the request object
     */
  public connectCoreV1PostNamespacedPodPortforward(
    param: CoreV1ApiConnectCoreV1PostNamespacedPodPortforwardRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedPodPortforward(
      param.name,
      param.namespace,
      param.ports,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PostNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1PostNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PostNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1PostNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PostNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1PostNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PostNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1PostNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PostNodeProxy(
    param: CoreV1ApiConnectCoreV1PostNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNodeProxy(param.name, param.path, options)
      .toPromise();
  }

  /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PostNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1PostNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PostNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PutNamespacedPodProxy(
    param: CoreV1ApiConnectCoreV1PutNamespacedPodProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNamespacedPodProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
  public connectCoreV1PutNamespacedPodProxyWithPath(
    param: CoreV1ApiConnectCoreV1PutNamespacedPodProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNamespacedPodProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PutNamespacedServiceProxy(
    param: CoreV1ApiConnectCoreV1PutNamespacedServiceProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNamespacedServiceProxy(
      param.name,
      param.namespace,
      param.path,
      options,
    ).toPromise();
  }

  /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
  public connectCoreV1PutNamespacedServiceProxyWithPath(
    param: CoreV1ApiConnectCoreV1PutNamespacedServiceProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNamespacedServiceProxyWithPath(
      param.name,
      param.namespace,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PutNodeProxy(
    param: CoreV1ApiConnectCoreV1PutNodeProxyRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNodeProxy(param.name, param.path, options)
      .toPromise();
  }

  /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
  public connectCoreV1PutNodeProxyWithPath(
    param: CoreV1ApiConnectCoreV1PutNodeProxyWithPathRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.connectCoreV1PutNodeProxyWithPath(
      param.name,
      param.path,
      param.path2,
      options,
    ).toPromise();
  }

  /**
     * create a Namespace
     * @param param the request object
     */
  public createCoreV1Namespace(
    param: CoreV1ApiCreateCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.createCoreV1Namespace(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Binding
     * @param param the request object
     */
  public createCoreV1NamespacedBinding(
    param: CoreV1ApiCreateCoreV1NamespacedBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Binding> {
    return this.api.createCoreV1NamespacedBinding(
      param.namespace,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a ConfigMap
     * @param param the request object
     */
  public createCoreV1NamespacedConfigMap(
    param: CoreV1ApiCreateCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMap> {
    return this.api.createCoreV1NamespacedConfigMap(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create Endpoints
     * @param param the request object
     */
  public createCoreV1NamespacedEndpoints(
    param: CoreV1ApiCreateCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Endpoints> {
    return this.api.createCoreV1NamespacedEndpoints(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create an Event
     * @param param the request object
     */
  public createCoreV1NamespacedEvent(
    param: CoreV1ApiCreateCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Event> {
    return this.api.createCoreV1NamespacedEvent(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a LimitRange
     * @param param the request object
     */
  public createCoreV1NamespacedLimitRange(
    param: CoreV1ApiCreateCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRange> {
    return this.api.createCoreV1NamespacedLimitRange(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a PersistentVolumeClaim
     * @param param the request object
     */
  public createCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiCreateCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.createCoreV1NamespacedPersistentVolumeClaim(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Pod
     * @param param the request object
     */
  public createCoreV1NamespacedPod(
    param: CoreV1ApiCreateCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.createCoreV1NamespacedPod(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create binding of a Pod
     * @param param the request object
     */
  public createCoreV1NamespacedPodBinding(
    param: CoreV1ApiCreateCoreV1NamespacedPodBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Binding> {
    return this.api.createCoreV1NamespacedPodBinding(
      param.name,
      param.namespace,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create eviction of a Pod
     * @param param the request object
     */
  public createCoreV1NamespacedPodEviction(
    param: CoreV1ApiCreateCoreV1NamespacedPodEvictionRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1Eviction> {
    return this.api.createCoreV1NamespacedPodEviction(
      param.name,
      param.namespace,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a PodTemplate
     * @param param the request object
     */
  public createCoreV1NamespacedPodTemplate(
    param: CoreV1ApiCreateCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplate> {
    return this.api.createCoreV1NamespacedPodTemplate(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ReplicationController
     * @param param the request object
     */
  public createCoreV1NamespacedReplicationController(
    param: CoreV1ApiCreateCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.createCoreV1NamespacedReplicationController(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ResourceQuota
     * @param param the request object
     */
  public createCoreV1NamespacedResourceQuota(
    param: CoreV1ApiCreateCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.createCoreV1NamespacedResourceQuota(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Secret
     * @param param the request object
     */
  public createCoreV1NamespacedSecret(
    param: CoreV1ApiCreateCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Secret> {
    return this.api.createCoreV1NamespacedSecret(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Service
     * @param param the request object
     */
  public createCoreV1NamespacedService(
    param: CoreV1ApiCreateCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.createCoreV1NamespacedService(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ServiceAccount
     * @param param the request object
     */
  public createCoreV1NamespacedServiceAccount(
    param: CoreV1ApiCreateCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccount> {
    return this.api.createCoreV1NamespacedServiceAccount(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create token of a ServiceAccount
     * @param param the request object
     */
  public createCoreV1NamespacedServiceAccountToken(
    param: CoreV1ApiCreateCoreV1NamespacedServiceAccountTokenRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAuthenticationV1TokenRequest> {
    return this.api.createCoreV1NamespacedServiceAccountToken(
      param.name,
      param.namespace,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * create a Node
     * @param param the request object
     */
  public createCoreV1Node(
    param: CoreV1ApiCreateCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.createCoreV1Node(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a PersistentVolume
     * @param param the request object
     */
  public createCoreV1PersistentVolume(
    param: CoreV1ApiCreateCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.createCoreV1PersistentVolume(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ConfigMap
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedConfigMap(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedConfigMap(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Endpoints
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedEndpoints(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedEndpoints(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Event
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedEvent(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedEvent(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of LimitRange
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedLimitRange(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedLimitRange(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PersistentVolumeClaim
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedPersistentVolumeClaim(
    param:
      CoreV1ApiDeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedPersistentVolumeClaim(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Pod
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedPod(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedPod(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PodTemplate
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedPodTemplate(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedPodTemplate(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ReplicationController
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedReplicationController(
    param:
      CoreV1ApiDeleteCoreV1CollectionNamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedReplicationController(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ResourceQuota
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedResourceQuota(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedResourceQuota(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Secret
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedSecret(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedSecret(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ServiceAccount
     * @param param the request object
     */
  public deleteCoreV1CollectionNamespacedServiceAccount(
    param: CoreV1ApiDeleteCoreV1CollectionNamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNamespacedServiceAccount(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Node
     * @param param the request object
     */
  public deleteCoreV1CollectionNode(
    param: CoreV1ApiDeleteCoreV1CollectionNodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionNode(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PersistentVolume
     * @param param the request object
     */
  public deleteCoreV1CollectionPersistentVolume(
    param: CoreV1ApiDeleteCoreV1CollectionPersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1CollectionPersistentVolume(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Namespace
     * @param param the request object
     */
  public deleteCoreV1Namespace(
    param: CoreV1ApiDeleteCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1Namespace(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ConfigMap
     * @param param the request object
     */
  public deleteCoreV1NamespacedConfigMap(
    param: CoreV1ApiDeleteCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedConfigMap(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete Endpoints
     * @param param the request object
     */
  public deleteCoreV1NamespacedEndpoints(
    param: CoreV1ApiDeleteCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedEndpoints(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Event
     * @param param the request object
     */
  public deleteCoreV1NamespacedEvent(
    param: CoreV1ApiDeleteCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a LimitRange
     * @param param the request object
     */
  public deleteCoreV1NamespacedLimitRange(
    param: CoreV1ApiDeleteCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedLimitRange(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PersistentVolumeClaim
     * @param param the request object
     */
  public deleteCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiDeleteCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.deleteCoreV1NamespacedPersistentVolumeClaim(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Pod
     * @param param the request object
     */
  public deleteCoreV1NamespacedPod(
    param: CoreV1ApiDeleteCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.deleteCoreV1NamespacedPod(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PodTemplate
     * @param param the request object
     */
  public deleteCoreV1NamespacedPodTemplate(
    param: CoreV1ApiDeleteCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplate> {
    return this.api.deleteCoreV1NamespacedPodTemplate(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ReplicationController
     * @param param the request object
     */
  public deleteCoreV1NamespacedReplicationController(
    param: CoreV1ApiDeleteCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedReplicationController(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ResourceQuota
     * @param param the request object
     */
  public deleteCoreV1NamespacedResourceQuota(
    param: CoreV1ApiDeleteCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.deleteCoreV1NamespacedResourceQuota(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Secret
     * @param param the request object
     */
  public deleteCoreV1NamespacedSecret(
    param: CoreV1ApiDeleteCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedSecret(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Service
     * @param param the request object
     */
  public deleteCoreV1NamespacedService(
    param: CoreV1ApiDeleteCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1NamespacedService(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ServiceAccount
     * @param param the request object
     */
  public deleteCoreV1NamespacedServiceAccount(
    param: CoreV1ApiDeleteCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccount> {
    return this.api.deleteCoreV1NamespacedServiceAccount(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Node
     * @param param the request object
     */
  public deleteCoreV1Node(
    param: CoreV1ApiDeleteCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteCoreV1Node(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PersistentVolume
     * @param param the request object
     */
  public deleteCoreV1PersistentVolume(
    param: CoreV1ApiDeleteCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.deleteCoreV1PersistentVolume(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getCoreV1APIResources(
    param: CoreV1ApiGetCoreV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getCoreV1APIResources(options).toPromise();
  }

  /**
     * list objects of kind ComponentStatus
     * @param param the request object
     */
  public listCoreV1ComponentStatus(
    param: CoreV1ApiListCoreV1ComponentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ComponentStatusList> {
    return this.api.listCoreV1ComponentStatus(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
  public listCoreV1ConfigMapForAllNamespaces(
    param: CoreV1ApiListCoreV1ConfigMapForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMapList> {
    return this.api.listCoreV1ConfigMapForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
  public listCoreV1EndpointsForAllNamespaces(
    param: CoreV1ApiListCoreV1EndpointsForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1EndpointsList> {
    return this.api.listCoreV1EndpointsForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listCoreV1EventForAllNamespaces(
    param: CoreV1ApiListCoreV1EventForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1EventList> {
    return this.api.listCoreV1EventForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
  public listCoreV1LimitRangeForAllNamespaces(
    param: CoreV1ApiListCoreV1LimitRangeForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRangeList> {
    return this.api.listCoreV1LimitRangeForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Namespace
     * @param param the request object
     */
  public listCoreV1Namespace(
    param: CoreV1ApiListCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1NamespaceList> {
    return this.api.listCoreV1Namespace(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
  public listCoreV1NamespacedConfigMap(
    param: CoreV1ApiListCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMapList> {
    return this.api.listCoreV1NamespacedConfigMap(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
  public listCoreV1NamespacedEndpoints(
    param: CoreV1ApiListCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1EndpointsList> {
    return this.api.listCoreV1NamespacedEndpoints(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listCoreV1NamespacedEvent(
    param: CoreV1ApiListCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1EventList> {
    return this.api.listCoreV1NamespacedEvent(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
  public listCoreV1NamespacedLimitRange(
    param: CoreV1ApiListCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRangeList> {
    return this.api.listCoreV1NamespacedLimitRange(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
  public listCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiListCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
    return this.api.listCoreV1NamespacedPersistentVolumeClaim(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
  public listCoreV1NamespacedPod(
    param: CoreV1ApiListCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodList> {
    return this.api.listCoreV1NamespacedPod(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
  public listCoreV1NamespacedPodTemplate(
    param: CoreV1ApiListCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplateList> {
    return this.api.listCoreV1NamespacedPodTemplate(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
  public listCoreV1NamespacedReplicationController(
    param: CoreV1ApiListCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationControllerList> {
    return this.api.listCoreV1NamespacedReplicationController(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
  public listCoreV1NamespacedResourceQuota(
    param: CoreV1ApiListCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuotaList> {
    return this.api.listCoreV1NamespacedResourceQuota(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
  public listCoreV1NamespacedSecret(
    param: CoreV1ApiListCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1SecretList> {
    return this.api.listCoreV1NamespacedSecret(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Service
     * @param param the request object
     */
  public listCoreV1NamespacedService(
    param: CoreV1ApiListCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceList> {
    return this.api.listCoreV1NamespacedService(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
  public listCoreV1NamespacedServiceAccount(
    param: CoreV1ApiListCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccountList> {
    return this.api.listCoreV1NamespacedServiceAccount(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Node
     * @param param the request object
     */
  public listCoreV1Node(
    param: CoreV1ApiListCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1NodeList> {
    return this.api.listCoreV1Node(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PersistentVolume
     * @param param the request object
     */
  public listCoreV1PersistentVolume(
    param: CoreV1ApiListCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeList> {
    return this.api.listCoreV1PersistentVolume(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
  public listCoreV1PersistentVolumeClaimForAllNamespaces(
    param: CoreV1ApiListCoreV1PersistentVolumeClaimForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
    return this.api.listCoreV1PersistentVolumeClaimForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
  public listCoreV1PodForAllNamespaces(
    param: CoreV1ApiListCoreV1PodForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodList> {
    return this.api.listCoreV1PodForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
  public listCoreV1PodTemplateForAllNamespaces(
    param: CoreV1ApiListCoreV1PodTemplateForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplateList> {
    return this.api.listCoreV1PodTemplateForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
  public listCoreV1ReplicationControllerForAllNamespaces(
    param: CoreV1ApiListCoreV1ReplicationControllerForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationControllerList> {
    return this.api.listCoreV1ReplicationControllerForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
  public listCoreV1ResourceQuotaForAllNamespaces(
    param: CoreV1ApiListCoreV1ResourceQuotaForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuotaList> {
    return this.api.listCoreV1ResourceQuotaForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
  public listCoreV1SecretForAllNamespaces(
    param: CoreV1ApiListCoreV1SecretForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1SecretList> {
    return this.api.listCoreV1SecretForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
  public listCoreV1ServiceAccountForAllNamespaces(
    param: CoreV1ApiListCoreV1ServiceAccountForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccountList> {
    return this.api.listCoreV1ServiceAccountForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Service
     * @param param the request object
     */
  public listCoreV1ServiceForAllNamespaces(
    param: CoreV1ApiListCoreV1ServiceForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceList> {
    return this.api.listCoreV1ServiceForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Namespace
     * @param param the request object
     */
  public patchCoreV1Namespace(
    param: CoreV1ApiPatchCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.patchCoreV1Namespace(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Namespace
     * @param param the request object
     */
  public patchCoreV1NamespaceStatus(
    param: CoreV1ApiPatchCoreV1NamespaceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.patchCoreV1NamespaceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ConfigMap
     * @param param the request object
     */
  public patchCoreV1NamespacedConfigMap(
    param: CoreV1ApiPatchCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMap> {
    return this.api.patchCoreV1NamespacedConfigMap(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Endpoints
     * @param param the request object
     */
  public patchCoreV1NamespacedEndpoints(
    param: CoreV1ApiPatchCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Endpoints> {
    return this.api.patchCoreV1NamespacedEndpoints(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Event
     * @param param the request object
     */
  public patchCoreV1NamespacedEvent(
    param: CoreV1ApiPatchCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Event> {
    return this.api.patchCoreV1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified LimitRange
     * @param param the request object
     */
  public patchCoreV1NamespacedLimitRange(
    param: CoreV1ApiPatchCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRange> {
    return this.api.patchCoreV1NamespacedLimitRange(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PersistentVolumeClaim
     * @param param the request object
     */
  public patchCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiPatchCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.patchCoreV1NamespacedPersistentVolumeClaim(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified PersistentVolumeClaim
     * @param param the request object
     */
  public patchCoreV1NamespacedPersistentVolumeClaimStatus(
    param: CoreV1ApiPatchCoreV1NamespacedPersistentVolumeClaimStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.patchCoreV1NamespacedPersistentVolumeClaimStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Pod
     * @param param the request object
     */
  public patchCoreV1NamespacedPod(
    param: CoreV1ApiPatchCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.patchCoreV1NamespacedPod(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Pod
     * @param param the request object
     */
  public patchCoreV1NamespacedPodStatus(
    param: CoreV1ApiPatchCoreV1NamespacedPodStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.patchCoreV1NamespacedPodStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PodTemplate
     * @param param the request object
     */
  public patchCoreV1NamespacedPodTemplate(
    param: CoreV1ApiPatchCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplate> {
    return this.api.patchCoreV1NamespacedPodTemplate(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ReplicationController
     * @param param the request object
     */
  public patchCoreV1NamespacedReplicationController(
    param: CoreV1ApiPatchCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.patchCoreV1NamespacedReplicationController(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update scale of the specified ReplicationController
     * @param param the request object
     */
  public patchCoreV1NamespacedReplicationControllerScale(
    param: CoreV1ApiPatchCoreV1NamespacedReplicationControllerScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.patchCoreV1NamespacedReplicationControllerScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified ReplicationController
     * @param param the request object
     */
  public patchCoreV1NamespacedReplicationControllerStatus(
    param: CoreV1ApiPatchCoreV1NamespacedReplicationControllerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.patchCoreV1NamespacedReplicationControllerStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ResourceQuota
     * @param param the request object
     */
  public patchCoreV1NamespacedResourceQuota(
    param: CoreV1ApiPatchCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.patchCoreV1NamespacedResourceQuota(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified ResourceQuota
     * @param param the request object
     */
  public patchCoreV1NamespacedResourceQuotaStatus(
    param: CoreV1ApiPatchCoreV1NamespacedResourceQuotaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.patchCoreV1NamespacedResourceQuotaStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Secret
     * @param param the request object
     */
  public patchCoreV1NamespacedSecret(
    param: CoreV1ApiPatchCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Secret> {
    return this.api.patchCoreV1NamespacedSecret(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Service
     * @param param the request object
     */
  public patchCoreV1NamespacedService(
    param: CoreV1ApiPatchCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.patchCoreV1NamespacedService(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ServiceAccount
     * @param param the request object
     */
  public patchCoreV1NamespacedServiceAccount(
    param: CoreV1ApiPatchCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccount> {
    return this.api.patchCoreV1NamespacedServiceAccount(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Service
     * @param param the request object
     */
  public patchCoreV1NamespacedServiceStatus(
    param: CoreV1ApiPatchCoreV1NamespacedServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.patchCoreV1NamespacedServiceStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Node
     * @param param the request object
     */
  public patchCoreV1Node(
    param: CoreV1ApiPatchCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.patchCoreV1Node(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Node
     * @param param the request object
     */
  public patchCoreV1NodeStatus(
    param: CoreV1ApiPatchCoreV1NodeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.patchCoreV1NodeStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PersistentVolume
     * @param param the request object
     */
  public patchCoreV1PersistentVolume(
    param: CoreV1ApiPatchCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.patchCoreV1PersistentVolume(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified PersistentVolume
     * @param param the request object
     */
  public patchCoreV1PersistentVolumeStatus(
    param: CoreV1ApiPatchCoreV1PersistentVolumeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.patchCoreV1PersistentVolumeStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified ComponentStatus
     * @param param the request object
     */
  public readCoreV1ComponentStatus(
    param: CoreV1ApiReadCoreV1ComponentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ComponentStatus> {
    return this.api.readCoreV1ComponentStatus(param.name, param.pretty, options)
      .toPromise();
  }

  /**
     * read the specified Namespace
     * @param param the request object
     */
  public readCoreV1Namespace(
    param: CoreV1ApiReadCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.readCoreV1Namespace(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Namespace
     * @param param the request object
     */
  public readCoreV1NamespaceStatus(
    param: CoreV1ApiReadCoreV1NamespaceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.readCoreV1NamespaceStatus(param.name, param.pretty, options)
      .toPromise();
  }

  /**
     * read the specified ConfigMap
     * @param param the request object
     */
  public readCoreV1NamespacedConfigMap(
    param: CoreV1ApiReadCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMap> {
    return this.api.readCoreV1NamespacedConfigMap(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified Endpoints
     * @param param the request object
     */
  public readCoreV1NamespacedEndpoints(
    param: CoreV1ApiReadCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Endpoints> {
    return this.api.readCoreV1NamespacedEndpoints(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified Event
     * @param param the request object
     */
  public readCoreV1NamespacedEvent(
    param: CoreV1ApiReadCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Event> {
    return this.api.readCoreV1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified LimitRange
     * @param param the request object
     */
  public readCoreV1NamespacedLimitRange(
    param: CoreV1ApiReadCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRange> {
    return this.api.readCoreV1NamespacedLimitRange(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified PersistentVolumeClaim
     * @param param the request object
     */
  public readCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiReadCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.readCoreV1NamespacedPersistentVolumeClaim(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified PersistentVolumeClaim
     * @param param the request object
     */
  public readCoreV1NamespacedPersistentVolumeClaimStatus(
    param: CoreV1ApiReadCoreV1NamespacedPersistentVolumeClaimStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.readCoreV1NamespacedPersistentVolumeClaimStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Pod
     * @param param the request object
     */
  public readCoreV1NamespacedPod(
    param: CoreV1ApiReadCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.readCoreV1NamespacedPod(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read log of the specified Pod
     * @param param the request object
     */
  public readCoreV1NamespacedPodLog(
    param: CoreV1ApiReadCoreV1NamespacedPodLogRequest,
    options?: Configuration,
  ): Promise<string> {
    return this.api.readCoreV1NamespacedPodLog(
      param.name,
      param.namespace,
      param.container,
      param.follow,
      param.insecureSkipTLSVerifyBackend,
      param.limitBytes,
      param.pretty,
      param.previous,
      param.sinceSeconds,
      param.tailLines,
      param.timestamps,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Pod
     * @param param the request object
     */
  public readCoreV1NamespacedPodStatus(
    param: CoreV1ApiReadCoreV1NamespacedPodStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.readCoreV1NamespacedPodStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified PodTemplate
     * @param param the request object
     */
  public readCoreV1NamespacedPodTemplate(
    param: CoreV1ApiReadCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplate> {
    return this.api.readCoreV1NamespacedPodTemplate(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified ReplicationController
     * @param param the request object
     */
  public readCoreV1NamespacedReplicationController(
    param: CoreV1ApiReadCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.readCoreV1NamespacedReplicationController(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read scale of the specified ReplicationController
     * @param param the request object
     */
  public readCoreV1NamespacedReplicationControllerScale(
    param: CoreV1ApiReadCoreV1NamespacedReplicationControllerScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.readCoreV1NamespacedReplicationControllerScale(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified ReplicationController
     * @param param the request object
     */
  public readCoreV1NamespacedReplicationControllerStatus(
    param: CoreV1ApiReadCoreV1NamespacedReplicationControllerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.readCoreV1NamespacedReplicationControllerStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified ResourceQuota
     * @param param the request object
     */
  public readCoreV1NamespacedResourceQuota(
    param: CoreV1ApiReadCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.readCoreV1NamespacedResourceQuota(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified ResourceQuota
     * @param param the request object
     */
  public readCoreV1NamespacedResourceQuotaStatus(
    param: CoreV1ApiReadCoreV1NamespacedResourceQuotaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.readCoreV1NamespacedResourceQuotaStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Secret
     * @param param the request object
     */
  public readCoreV1NamespacedSecret(
    param: CoreV1ApiReadCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Secret> {
    return this.api.readCoreV1NamespacedSecret(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified Service
     * @param param the request object
     */
  public readCoreV1NamespacedService(
    param: CoreV1ApiReadCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.readCoreV1NamespacedService(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified ServiceAccount
     * @param param the request object
     */
  public readCoreV1NamespacedServiceAccount(
    param: CoreV1ApiReadCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccount> {
    return this.api.readCoreV1NamespacedServiceAccount(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Service
     * @param param the request object
     */
  public readCoreV1NamespacedServiceStatus(
    param: CoreV1ApiReadCoreV1NamespacedServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.readCoreV1NamespacedServiceStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Node
     * @param param the request object
     */
  public readCoreV1Node(
    param: CoreV1ApiReadCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.readCoreV1Node(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Node
     * @param param the request object
     */
  public readCoreV1NodeStatus(
    param: CoreV1ApiReadCoreV1NodeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.readCoreV1NodeStatus(param.name, param.pretty, options)
      .toPromise();
  }

  /**
     * read the specified PersistentVolume
     * @param param the request object
     */
  public readCoreV1PersistentVolume(
    param: CoreV1ApiReadCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.readCoreV1PersistentVolume(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified PersistentVolume
     * @param param the request object
     */
  public readCoreV1PersistentVolumeStatus(
    param: CoreV1ApiReadCoreV1PersistentVolumeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.readCoreV1PersistentVolumeStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Namespace
     * @param param the request object
     */
  public replaceCoreV1Namespace(
    param: CoreV1ApiReplaceCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.replaceCoreV1Namespace(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace finalize of the specified Namespace
     * @param param the request object
     */
  public replaceCoreV1NamespaceFinalize(
    param: CoreV1ApiReplaceCoreV1NamespaceFinalizeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.replaceCoreV1NamespaceFinalize(
      param.name,
      param.body,
      param.dryRun,
      param.fieldManager,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Namespace
     * @param param the request object
     */
  public replaceCoreV1NamespaceStatus(
    param: CoreV1ApiReplaceCoreV1NamespaceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Namespace> {
    return this.api.replaceCoreV1NamespaceStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ConfigMap
     * @param param the request object
     */
  public replaceCoreV1NamespacedConfigMap(
    param: CoreV1ApiReplaceCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ConfigMap> {
    return this.api.replaceCoreV1NamespacedConfigMap(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Endpoints
     * @param param the request object
     */
  public replaceCoreV1NamespacedEndpoints(
    param: CoreV1ApiReplaceCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Endpoints> {
    return this.api.replaceCoreV1NamespacedEndpoints(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Event
     * @param param the request object
     */
  public replaceCoreV1NamespacedEvent(
    param: CoreV1ApiReplaceCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Event> {
    return this.api.replaceCoreV1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified LimitRange
     * @param param the request object
     */
  public replaceCoreV1NamespacedLimitRange(
    param: CoreV1ApiReplaceCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1LimitRange> {
    return this.api.replaceCoreV1NamespacedLimitRange(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PersistentVolumeClaim
     * @param param the request object
     */
  public replaceCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiReplaceCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.replaceCoreV1NamespacedPersistentVolumeClaim(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified PersistentVolumeClaim
     * @param param the request object
     */
  public replaceCoreV1NamespacedPersistentVolumeClaimStatus(
    param: CoreV1ApiReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
    return this.api.replaceCoreV1NamespacedPersistentVolumeClaimStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Pod
     * @param param the request object
     */
  public replaceCoreV1NamespacedPod(
    param: CoreV1ApiReplaceCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.replaceCoreV1NamespacedPod(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Pod
     * @param param the request object
     */
  public replaceCoreV1NamespacedPodStatus(
    param: CoreV1ApiReplaceCoreV1NamespacedPodStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Pod> {
    return this.api.replaceCoreV1NamespacedPodStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PodTemplate
     * @param param the request object
     */
  public replaceCoreV1NamespacedPodTemplate(
    param: CoreV1ApiReplaceCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PodTemplate> {
    return this.api.replaceCoreV1NamespacedPodTemplate(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ReplicationController
     * @param param the request object
     */
  public replaceCoreV1NamespacedReplicationController(
    param: CoreV1ApiReplaceCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.replaceCoreV1NamespacedReplicationController(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace scale of the specified ReplicationController
     * @param param the request object
     */
  public replaceCoreV1NamespacedReplicationControllerScale(
    param: CoreV1ApiReplaceCoreV1NamespacedReplicationControllerScaleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiAutoscalingV1Scale> {
    return this.api.replaceCoreV1NamespacedReplicationControllerScale(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified ReplicationController
     * @param param the request object
     */
  public replaceCoreV1NamespacedReplicationControllerStatus(
    param: CoreV1ApiReplaceCoreV1NamespacedReplicationControllerStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ReplicationController> {
    return this.api.replaceCoreV1NamespacedReplicationControllerStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ResourceQuota
     * @param param the request object
     */
  public replaceCoreV1NamespacedResourceQuota(
    param: CoreV1ApiReplaceCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.replaceCoreV1NamespacedResourceQuota(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified ResourceQuota
     * @param param the request object
     */
  public replaceCoreV1NamespacedResourceQuotaStatus(
    param: CoreV1ApiReplaceCoreV1NamespacedResourceQuotaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ResourceQuota> {
    return this.api.replaceCoreV1NamespacedResourceQuotaStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Secret
     * @param param the request object
     */
  public replaceCoreV1NamespacedSecret(
    param: CoreV1ApiReplaceCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Secret> {
    return this.api.replaceCoreV1NamespacedSecret(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Service
     * @param param the request object
     */
  public replaceCoreV1NamespacedService(
    param: CoreV1ApiReplaceCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.replaceCoreV1NamespacedService(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ServiceAccount
     * @param param the request object
     */
  public replaceCoreV1NamespacedServiceAccount(
    param: CoreV1ApiReplaceCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1ServiceAccount> {
    return this.api.replaceCoreV1NamespacedServiceAccount(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Service
     * @param param the request object
     */
  public replaceCoreV1NamespacedServiceStatus(
    param: CoreV1ApiReplaceCoreV1NamespacedServiceStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Service> {
    return this.api.replaceCoreV1NamespacedServiceStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Node
     * @param param the request object
     */
  public replaceCoreV1Node(
    param: CoreV1ApiReplaceCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.replaceCoreV1Node(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Node
     * @param param the request object
     */
  public replaceCoreV1NodeStatus(
    param: CoreV1ApiReplaceCoreV1NodeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1Node> {
    return this.api.replaceCoreV1NodeStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PersistentVolume
     * @param param the request object
     */
  public replaceCoreV1PersistentVolume(
    param: CoreV1ApiReplaceCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.replaceCoreV1PersistentVolume(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified PersistentVolume
     * @param param the request object
     */
  public replaceCoreV1PersistentVolumeStatus(
    param: CoreV1ApiReplaceCoreV1PersistentVolumeStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiCoreV1PersistentVolume> {
    return this.api.replaceCoreV1PersistentVolumeStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1ConfigMapListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1ConfigMapListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1ConfigMapListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1EndpointsListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1EndpointsListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1EndpointsListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1EventListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1EventListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1EventListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1LimitRangeListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1LimitRangeListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1LimitRangeListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1Namespace(
    param: CoreV1ApiWatchCoreV1NamespaceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1Namespace(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespaceList(
    param: CoreV1ApiWatchCoreV1NamespaceListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespaceList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedConfigMap(
    param: CoreV1ApiWatchCoreV1NamespacedConfigMapRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedConfigMap(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedConfigMapList(
    param: CoreV1ApiWatchCoreV1NamespacedConfigMapListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedConfigMapList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Endpoints. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedEndpoints(
    param: CoreV1ApiWatchCoreV1NamespacedEndpointsRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedEndpoints(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedEndpointsList(
    param: CoreV1ApiWatchCoreV1NamespacedEndpointsListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedEndpointsList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedEvent(
    param: CoreV1ApiWatchCoreV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedEvent(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedEventList(
    param: CoreV1ApiWatchCoreV1NamespacedEventListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedEventList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind LimitRange. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedLimitRange(
    param: CoreV1ApiWatchCoreV1NamespacedLimitRangeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedLimitRange(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedLimitRangeList(
    param: CoreV1ApiWatchCoreV1NamespacedLimitRangeListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedLimitRangeList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedPersistentVolumeClaim(
    param: CoreV1ApiWatchCoreV1NamespacedPersistentVolumeClaimRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPersistentVolumeClaim(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedPersistentVolumeClaimList(
    param: CoreV1ApiWatchCoreV1NamespacedPersistentVolumeClaimListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPersistentVolumeClaimList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedPod(
    param: CoreV1ApiWatchCoreV1NamespacedPodRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPod(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedPodList(
    param: CoreV1ApiWatchCoreV1NamespacedPodListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPodList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PodTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedPodTemplate(
    param: CoreV1ApiWatchCoreV1NamespacedPodTemplateRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPodTemplate(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedPodTemplateList(
    param: CoreV1ApiWatchCoreV1NamespacedPodTemplateListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedPodTemplateList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ReplicationController. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedReplicationController(
    param: CoreV1ApiWatchCoreV1NamespacedReplicationControllerRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedReplicationController(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedReplicationControllerList(
    param: CoreV1ApiWatchCoreV1NamespacedReplicationControllerListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedReplicationControllerList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedResourceQuota(
    param: CoreV1ApiWatchCoreV1NamespacedResourceQuotaRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedResourceQuota(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedResourceQuotaList(
    param: CoreV1ApiWatchCoreV1NamespacedResourceQuotaListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedResourceQuotaList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedSecret(
    param: CoreV1ApiWatchCoreV1NamespacedSecretRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedSecret(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedSecretList(
    param: CoreV1ApiWatchCoreV1NamespacedSecretListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedSecretList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Service. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedService(
    param: CoreV1ApiWatchCoreV1NamespacedServiceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedService(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1NamespacedServiceAccount(
    param: CoreV1ApiWatchCoreV1NamespacedServiceAccountRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedServiceAccount(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedServiceAccountList(
    param: CoreV1ApiWatchCoreV1NamespacedServiceAccountListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedServiceAccountList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NamespacedServiceList(
    param: CoreV1ApiWatchCoreV1NamespacedServiceListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NamespacedServiceList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Node. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1Node(
    param: CoreV1ApiWatchCoreV1NodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1Node(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Node. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1NodeList(
    param: CoreV1ApiWatchCoreV1NodeListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1NodeList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchCoreV1PersistentVolume(
    param: CoreV1ApiWatchCoreV1PersistentVolumeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1PersistentVolume(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1PersistentVolumeClaimListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1PersistentVolumeClaimListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1PersistentVolumeList(
    param: CoreV1ApiWatchCoreV1PersistentVolumeListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1PersistentVolumeList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1PodListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1PodListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1PodListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1PodTemplateListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1PodTemplateListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1PodTemplateListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1ReplicationControllerListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1ReplicationControllerListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1ReplicationControllerListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1ResourceQuotaListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1ResourceQuotaListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1ResourceQuotaListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1SecretListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1SecretListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1SecretListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1ServiceAccountListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1ServiceAccountListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1ServiceAccountListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchCoreV1ServiceListForAllNamespaces(
    param: CoreV1ApiWatchCoreV1ServiceListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchCoreV1ServiceListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableDiscoveryApi } from "./ObservableAPI.ts";
import {
  DiscoveryApiRequestFactory,
  DiscoveryApiResponseProcessor,
} from "../apis/DiscoveryApi.ts";

export interface DiscoveryApiGetDiscoveryAPIGroupRequest {
}

export class ObjectDiscoveryApi {
  private api: ObservableDiscoveryApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: DiscoveryApiRequestFactory,
    responseProcessor?: DiscoveryApiResponseProcessor,
  ) {
    this.api = new ObservableDiscoveryApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getDiscoveryAPIGroup(
    param: DiscoveryApiGetDiscoveryAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getDiscoveryAPIGroup(options).toPromise();
  }
}

import { ObservableDiscoveryV1beta1Api } from "./ObservableAPI.ts";
import {
  DiscoveryV1beta1ApiRequestFactory,
  DiscoveryV1beta1ApiResponseProcessor,
} from "../apis/DiscoveryV1beta1Api.ts";

export interface DiscoveryV1beta1ApiCreateDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApicreateDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiDiscoveryV1beta1EndpointSlice
     * @memberof DiscoveryV1beta1ApicreateDiscoveryV1beta1NamespacedEndpointSlice
     */
  body: IoK8sApiDiscoveryV1beta1EndpointSlice;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApicreateDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApicreateDiscoveryV1beta1NamespacedEndpointSlice
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1beta1ApicreateDiscoveryV1beta1NamespacedEndpointSlice
     */
  fieldManager?: string;
}

export interface DiscoveryV1beta1ApiDeleteDiscoveryV1beta1CollectionNamespacedEndpointSliceRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1CollectionNamespacedEndpointSlice
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DiscoveryV1beta1ApiDeleteDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof DiscoveryV1beta1ApideleteDiscoveryV1beta1NamespacedEndpointSlice
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DiscoveryV1beta1ApiGetDiscoveryV1beta1APIResourcesRequest {
}

export interface DiscoveryV1beta1ApiListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1EndpointSliceForAllNamespaces
     */
  watch?: boolean;
}

export interface DiscoveryV1beta1ApiListDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApilistDiscoveryV1beta1NamespacedEndpointSlice
     */
  watch?: boolean;
}

export interface DiscoveryV1beta1ApiPatchDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof DiscoveryV1beta1ApipatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  force?: boolean;
}

export interface DiscoveryV1beta1ApiReadDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApireadDiscoveryV1beta1NamespacedEndpointSlice
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApireadDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApireadDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof DiscoveryV1beta1ApireadDiscoveryV1beta1NamespacedEndpointSlice
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof DiscoveryV1beta1ApireadDiscoveryV1beta1NamespacedEndpointSlice
     */
  _export?: boolean;
}

export interface DiscoveryV1beta1ApiReplaceDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiDiscoveryV1beta1EndpointSlice
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  body: IoK8sApiDiscoveryV1beta1EndpointSlice;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof DiscoveryV1beta1ApireplaceDiscoveryV1beta1NamespacedEndpointSlice
     */
  fieldManager?: string;
}

export interface DiscoveryV1beta1ApiWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1EndpointSliceListForAllNamespaces
     */
  watch?: boolean;
}

export interface DiscoveryV1beta1ApiWatchDiscoveryV1beta1NamespacedEndpointSliceRequest {
  /**
     * name of the EndpointSlice
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSlice
     */
  watch?: boolean;
}

export interface DiscoveryV1beta1ApiWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof DiscoveryV1beta1ApiwatchDiscoveryV1beta1NamespacedEndpointSliceList
     */
  watch?: boolean;
}

export class ObjectDiscoveryV1beta1Api {
  private api: ObservableDiscoveryV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: DiscoveryV1beta1ApiRequestFactory,
    responseProcessor?: DiscoveryV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableDiscoveryV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an EndpointSlice
     * @param param the request object
     */
  public createDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiCreateDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSlice> {
    return this.api.createDiscoveryV1beta1NamespacedEndpointSlice(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
  public deleteDiscoveryV1beta1CollectionNamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiDeleteDiscoveryV1beta1CollectionNamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteDiscoveryV1beta1CollectionNamespacedEndpointSlice(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an EndpointSlice
     * @param param the request object
     */
  public deleteDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiDeleteDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteDiscoveryV1beta1NamespacedEndpointSlice(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getDiscoveryV1beta1APIResources(
    param: DiscoveryV1beta1ApiGetDiscoveryV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getDiscoveryV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
  public listDiscoveryV1beta1EndpointSliceForAllNamespaces(
    param:
      DiscoveryV1beta1ApiListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSliceList> {
    return this.api.listDiscoveryV1beta1EndpointSliceForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
  public listDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiListDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSliceList> {
    return this.api.listDiscoveryV1beta1NamespacedEndpointSlice(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
  public patchDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiPatchDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSlice> {
    return this.api.patchDiscoveryV1beta1NamespacedEndpointSlice(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified EndpointSlice
     * @param param the request object
     */
  public readDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiReadDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSlice> {
    return this.api.readDiscoveryV1beta1NamespacedEndpointSlice(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
  public replaceDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiReplaceDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApiDiscoveryV1beta1EndpointSlice> {
    return this.api.replaceDiscoveryV1beta1NamespacedEndpointSlice(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchDiscoveryV1beta1EndpointSliceListForAllNamespaces(
    param:
      DiscoveryV1beta1ApiWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchDiscoveryV1beta1EndpointSliceListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchDiscoveryV1beta1NamespacedEndpointSlice(
    param:
      DiscoveryV1beta1ApiWatchDiscoveryV1beta1NamespacedEndpointSliceRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchDiscoveryV1beta1NamespacedEndpointSlice(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchDiscoveryV1beta1NamespacedEndpointSliceList(
    param:
      DiscoveryV1beta1ApiWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchDiscoveryV1beta1NamespacedEndpointSliceList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableEventsApi } from "./ObservableAPI.ts";
import {
  EventsApiRequestFactory,
  EventsApiResponseProcessor,
} from "../apis/EventsApi.ts";

export interface EventsApiGetEventsAPIGroupRequest {
}

export class ObjectEventsApi {
  private api: ObservableEventsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: EventsApiRequestFactory,
    responseProcessor?: EventsApiResponseProcessor,
  ) {
    this.api = new ObservableEventsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getEventsAPIGroup(
    param: EventsApiGetEventsAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getEventsAPIGroup(options).toPromise();
  }
}

import { ObservableEventsV1Api } from "./ObservableAPI.ts";
import {
  EventsV1ApiRequestFactory,
  EventsV1ApiResponseProcessor,
} from "../apis/EventsV1Api.ts";

export interface EventsV1ApiCreateEventsV1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApicreateEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiEventsV1Event
     * @memberof EventsV1ApicreateEventsV1NamespacedEvent
     */
  body: IoK8sApiEventsV1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApicreateEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApicreateEventsV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1ApicreateEventsV1NamespacedEvent
     */
  fieldManager?: string;
}

export interface EventsV1ApiDeleteEventsV1CollectionNamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof EventsV1ApideleteEventsV1CollectionNamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface EventsV1ApiDeleteEventsV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof EventsV1ApideleteEventsV1NamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface EventsV1ApiGetEventsV1APIResourcesRequest {
}

export interface EventsV1ApiListEventsV1EventForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApilistEventsV1EventForAllNamespaces
     */
  watch?: boolean;
}

export interface EventsV1ApiListEventsV1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApilistEventsV1NamespacedEvent
     */
  watch?: boolean;
}

export interface EventsV1ApiPatchEventsV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof EventsV1ApipatchEventsV1NamespacedEvent
     */
  force?: boolean;
}

export interface EventsV1ApiReadEventsV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApireadEventsV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApireadEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApireadEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof EventsV1ApireadEventsV1NamespacedEvent
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof EventsV1ApireadEventsV1NamespacedEvent
     */
  _export?: boolean;
}

export interface EventsV1ApiReplaceEventsV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiEventsV1Event
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  body: IoK8sApiEventsV1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1ApireplaceEventsV1NamespacedEvent
     */
  fieldManager?: string;
}

export interface EventsV1ApiWatchEventsV1EventListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1EventListForAllNamespaces
     */
  watch?: boolean;
}

export interface EventsV1ApiWatchEventsV1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1NamespacedEvent
     */
  watch?: boolean;
}

export interface EventsV1ApiWatchEventsV1NamespacedEventListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1ApiwatchEventsV1NamespacedEventList
     */
  watch?: boolean;
}

export class ObjectEventsV1Api {
  private api: ObservableEventsV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: EventsV1ApiRequestFactory,
    responseProcessor?: EventsV1ApiResponseProcessor,
  ) {
    this.api = new ObservableEventsV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an Event
     * @param param the request object
     */
  public createEventsV1NamespacedEvent(
    param: EventsV1ApiCreateEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1Event> {
    return this.api.createEventsV1NamespacedEvent(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Event
     * @param param the request object
     */
  public deleteEventsV1CollectionNamespacedEvent(
    param: EventsV1ApiDeleteEventsV1CollectionNamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteEventsV1CollectionNamespacedEvent(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Event
     * @param param the request object
     */
  public deleteEventsV1NamespacedEvent(
    param: EventsV1ApiDeleteEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteEventsV1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getEventsV1APIResources(
    param: EventsV1ApiGetEventsV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getEventsV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listEventsV1EventForAllNamespaces(
    param: EventsV1ApiListEventsV1EventForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1EventList> {
    return this.api.listEventsV1EventForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listEventsV1NamespacedEvent(
    param: EventsV1ApiListEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1EventList> {
    return this.api.listEventsV1NamespacedEvent(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Event
     * @param param the request object
     */
  public patchEventsV1NamespacedEvent(
    param: EventsV1ApiPatchEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1Event> {
    return this.api.patchEventsV1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Event
     * @param param the request object
     */
  public readEventsV1NamespacedEvent(
    param: EventsV1ApiReadEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1Event> {
    return this.api.readEventsV1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Event
     * @param param the request object
     */
  public replaceEventsV1NamespacedEvent(
    param: EventsV1ApiReplaceEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1Event> {
    return this.api.replaceEventsV1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchEventsV1EventListForAllNamespaces(
    param: EventsV1ApiWatchEventsV1EventListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1EventListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchEventsV1NamespacedEvent(
    param: EventsV1ApiWatchEventsV1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1NamespacedEvent(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchEventsV1NamespacedEventList(
    param: EventsV1ApiWatchEventsV1NamespacedEventListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1NamespacedEventList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableEventsV1beta1Api } from "./ObservableAPI.ts";
import {
  EventsV1beta1ApiRequestFactory,
  EventsV1beta1ApiResponseProcessor,
} from "../apis/EventsV1beta1Api.ts";

export interface EventsV1beta1ApiCreateEventsV1beta1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApicreateEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiEventsV1beta1Event
     * @memberof EventsV1beta1ApicreateEventsV1beta1NamespacedEvent
     */
  body: IoK8sApiEventsV1beta1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApicreateEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApicreateEventsV1beta1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1beta1ApicreateEventsV1beta1NamespacedEvent
     */
  fieldManager?: string;
}

export interface EventsV1beta1ApiDeleteEventsV1beta1CollectionNamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof EventsV1beta1ApideleteEventsV1beta1CollectionNamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface EventsV1beta1ApiDeleteEventsV1beta1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof EventsV1beta1ApideleteEventsV1beta1NamespacedEvent
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface EventsV1beta1ApiGetEventsV1beta1APIResourcesRequest {
}

export interface EventsV1beta1ApiListEventsV1beta1EventForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventsV1beta1EventForAllNamespaces
     */
  watch?: boolean;
}

export interface EventsV1beta1ApiListEventsV1beta1NamespacedEventRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApilistEventsV1beta1NamespacedEvent
     */
  watch?: boolean;
}

export interface EventsV1beta1ApiPatchEventsV1beta1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof EventsV1beta1ApipatchEventsV1beta1NamespacedEvent
     */
  force?: boolean;
}

export interface EventsV1beta1ApiReadEventsV1beta1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApireadEventsV1beta1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApireadEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApireadEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof EventsV1beta1ApireadEventsV1beta1NamespacedEvent
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof EventsV1beta1ApireadEventsV1beta1NamespacedEvent
     */
  _export?: boolean;
}

export interface EventsV1beta1ApiReplaceEventsV1beta1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiEventsV1beta1Event
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  body: IoK8sApiEventsV1beta1Event;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof EventsV1beta1ApireplaceEventsV1beta1NamespacedEvent
     */
  fieldManager?: string;
}

export interface EventsV1beta1ApiWatchEventsV1beta1EventListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1EventListForAllNamespaces
     */
  watch?: boolean;
}

export interface EventsV1beta1ApiWatchEventsV1beta1NamespacedEventRequest {
  /**
     * name of the Event
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEvent
     */
  watch?: boolean;
}

export interface EventsV1beta1ApiWatchEventsV1beta1NamespacedEventListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof EventsV1beta1ApiwatchEventsV1beta1NamespacedEventList
     */
  watch?: boolean;
}

export class ObjectEventsV1beta1Api {
  private api: ObservableEventsV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: EventsV1beta1ApiRequestFactory,
    responseProcessor?: EventsV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableEventsV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an Event
     * @param param the request object
     */
  public createEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiCreateEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1Event> {
    return this.api.createEventsV1beta1NamespacedEvent(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Event
     * @param param the request object
     */
  public deleteEventsV1beta1CollectionNamespacedEvent(
    param: EventsV1beta1ApiDeleteEventsV1beta1CollectionNamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteEventsV1beta1CollectionNamespacedEvent(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Event
     * @param param the request object
     */
  public deleteEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiDeleteEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteEventsV1beta1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getEventsV1beta1APIResources(
    param: EventsV1beta1ApiGetEventsV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getEventsV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listEventsV1beta1EventForAllNamespaces(
    param: EventsV1beta1ApiListEventsV1beta1EventForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1EventList> {
    return this.api.listEventsV1beta1EventForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Event
     * @param param the request object
     */
  public listEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiListEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1EventList> {
    return this.api.listEventsV1beta1NamespacedEvent(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Event
     * @param param the request object
     */
  public patchEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiPatchEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1Event> {
    return this.api.patchEventsV1beta1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Event
     * @param param the request object
     */
  public readEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiReadEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1Event> {
    return this.api.readEventsV1beta1NamespacedEvent(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Event
     * @param param the request object
     */
  public replaceEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiReplaceEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApiEventsV1beta1Event> {
    return this.api.replaceEventsV1beta1NamespacedEvent(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchEventsV1beta1EventListForAllNamespaces(
    param: EventsV1beta1ApiWatchEventsV1beta1EventListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1beta1EventListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchEventsV1beta1NamespacedEvent(
    param: EventsV1beta1ApiWatchEventsV1beta1NamespacedEventRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1beta1NamespacedEvent(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchEventsV1beta1NamespacedEventList(
    param: EventsV1beta1ApiWatchEventsV1beta1NamespacedEventListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchEventsV1beta1NamespacedEventList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableExtensionsApi } from "./ObservableAPI.ts";
import {
  ExtensionsApiRequestFactory,
  ExtensionsApiResponseProcessor,
} from "../apis/ExtensionsApi.ts";

export interface ExtensionsApiGetExtensionsAPIGroupRequest {
}

export class ObjectExtensionsApi {
  private api: ObservableExtensionsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: ExtensionsApiRequestFactory,
    responseProcessor?: ExtensionsApiResponseProcessor,
  ) {
    this.api = new ObservableExtensionsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getExtensionsAPIGroup(
    param: ExtensionsApiGetExtensionsAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getExtensionsAPIGroup(options).toPromise();
  }
}

import { ObservableExtensionsV1beta1Api } from "./ObservableAPI.ts";
import {
  ExtensionsV1beta1ApiRequestFactory,
  ExtensionsV1beta1ApiResponseProcessor,
} from "../apis/ExtensionsV1beta1Api.ts";

export interface ExtensionsV1beta1ApiCreateExtensionsV1beta1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApicreateExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiExtensionsV1beta1Ingress
     * @memberof ExtensionsV1beta1ApicreateExtensionsV1beta1NamespacedIngress
     */
  body: IoK8sApiExtensionsV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApicreateExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApicreateExtensionsV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ExtensionsV1beta1ApicreateExtensionsV1beta1NamespacedIngress
     */
  fieldManager?: string;
}

export interface ExtensionsV1beta1ApiDeleteExtensionsV1beta1CollectionNamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1CollectionNamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ExtensionsV1beta1ApiDeleteExtensionsV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof ExtensionsV1beta1ApideleteExtensionsV1beta1NamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ExtensionsV1beta1ApiGetExtensionsV1beta1APIResourcesRequest {
}

export interface ExtensionsV1beta1ApiListExtensionsV1beta1IngressForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1IngressForAllNamespaces
     */
  watch?: boolean;
}

export interface ExtensionsV1beta1ApiListExtensionsV1beta1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ExtensionsV1beta1ApilistExtensionsV1beta1NamespacedIngress
     */
  watch?: boolean;
}

export interface ExtensionsV1beta1ApiPatchExtensionsV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngress
     */
  force?: boolean;
}

export interface ExtensionsV1beta1ApiPatchExtensionsV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof ExtensionsV1beta1ApipatchExtensionsV1beta1NamespacedIngressStatus
     */
  force?: boolean;
}

export interface ExtensionsV1beta1ApiReadExtensionsV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngress
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngress
     */
  _export?: boolean;
}

export interface ExtensionsV1beta1ApiReadExtensionsV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApireadExtensionsV1beta1NamespacedIngressStatus
     */
  pretty?: string;
}

export interface ExtensionsV1beta1ApiReplaceExtensionsV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiExtensionsV1beta1Ingress
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  body: IoK8sApiExtensionsV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngress
     */
  fieldManager?: string;
}

export interface ExtensionsV1beta1ApiReplaceExtensionsV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiExtensionsV1beta1Ingress
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  body: IoK8sApiExtensionsV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof ExtensionsV1beta1ApireplaceExtensionsV1beta1NamespacedIngressStatus
     */
  fieldManager?: string;
}

export interface ExtensionsV1beta1ApiWatchExtensionsV1beta1IngressListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1IngressListForAllNamespaces
     */
  watch?: boolean;
}

export interface ExtensionsV1beta1ApiWatchExtensionsV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngress
     */
  watch?: boolean;
}

export interface ExtensionsV1beta1ApiWatchExtensionsV1beta1NamespacedIngressListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof ExtensionsV1beta1ApiwatchExtensionsV1beta1NamespacedIngressList
     */
  watch?: boolean;
}

export class ObjectExtensionsV1beta1Api {
  private api: ObservableExtensionsV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: ExtensionsV1beta1ApiRequestFactory,
    responseProcessor?: ExtensionsV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableExtensionsV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an Ingress
     * @param param the request object
     */
  public createExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiCreateExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.createExtensionsV1beta1NamespacedIngress(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Ingress
     * @param param the request object
     */
  public deleteExtensionsV1beta1CollectionNamespacedIngress(
    param:
      ExtensionsV1beta1ApiDeleteExtensionsV1beta1CollectionNamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteExtensionsV1beta1CollectionNamespacedIngress(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Ingress
     * @param param the request object
     */
  public deleteExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiDeleteExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteExtensionsV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getExtensionsV1beta1APIResources(
    param: ExtensionsV1beta1ApiGetExtensionsV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getExtensionsV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listExtensionsV1beta1IngressForAllNamespaces(
    param:
      ExtensionsV1beta1ApiListExtensionsV1beta1IngressForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1IngressList> {
    return this.api.listExtensionsV1beta1IngressForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiListExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1IngressList> {
    return this.api.listExtensionsV1beta1NamespacedIngress(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Ingress
     * @param param the request object
     */
  public patchExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiPatchExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.patchExtensionsV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
  public patchExtensionsV1beta1NamespacedIngressStatus(
    param:
      ExtensionsV1beta1ApiPatchExtensionsV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.patchExtensionsV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified Ingress
     * @param param the request object
     */
  public readExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiReadExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.readExtensionsV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Ingress
     * @param param the request object
     */
  public readExtensionsV1beta1NamespacedIngressStatus(
    param:
      ExtensionsV1beta1ApiReadExtensionsV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.readExtensionsV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Ingress
     * @param param the request object
     */
  public replaceExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiReplaceExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.replaceExtensionsV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Ingress
     * @param param the request object
     */
  public replaceExtensionsV1beta1NamespacedIngressStatus(
    param:
      ExtensionsV1beta1ApiReplaceExtensionsV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiExtensionsV1beta1Ingress> {
    return this.api.replaceExtensionsV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchExtensionsV1beta1IngressListForAllNamespaces(
    param:
      ExtensionsV1beta1ApiWatchExtensionsV1beta1IngressListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchExtensionsV1beta1IngressListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchExtensionsV1beta1NamespacedIngress(
    param: ExtensionsV1beta1ApiWatchExtensionsV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchExtensionsV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchExtensionsV1beta1NamespacedIngressList(
    param:
      ExtensionsV1beta1ApiWatchExtensionsV1beta1NamespacedIngressListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchExtensionsV1beta1NamespacedIngressList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableFlowcontrolApiserverApi } from "./ObservableAPI.ts";
import {
  FlowcontrolApiserverApiRequestFactory,
  FlowcontrolApiserverApiResponseProcessor,
} from "../apis/FlowcontrolApiserverApi.ts";

export interface FlowcontrolApiserverApiGetFlowcontrolApiserverAPIGroupRequest {
}

export class ObjectFlowcontrolApiserverApi {
  private api: ObservableFlowcontrolApiserverApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: FlowcontrolApiserverApiRequestFactory,
    responseProcessor?: FlowcontrolApiserverApiResponseProcessor,
  ) {
    this.api = new ObservableFlowcontrolApiserverApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getFlowcontrolApiserverAPIGroup(
    param: FlowcontrolApiserverApiGetFlowcontrolApiserverAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getFlowcontrolApiserverAPIGroup(options).toPromise();
  }
}

import { ObservableFlowcontrolApiserverV1alpha1Api } from "./ObservableAPI.ts";
import {
  FlowcontrolApiserverV1alpha1ApiRequestFactory,
  FlowcontrolApiserverV1alpha1ApiResponseProcessor,
} from "../apis/FlowcontrolApiserverV1alpha1Api.ts";

export interface FlowcontrolApiserverV1alpha1ApiCreateFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1FlowSchema
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1FlowSchema
     */
  body: IoK8sApiFlowcontrolV1alpha1FlowSchema;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1FlowSchema
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1FlowSchema
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiCreateFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  body: IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApicreateFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1CollectionFlowSchemaRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionFlowSchema
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1FlowSchema
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof FlowcontrolApiserverV1alpha1ApideleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface FlowcontrolApiserverV1alpha1ApiGetFlowcontrolApiserverV1alpha1APIResourcesRequest {
}

export interface FlowcontrolApiserverV1alpha1ApiListFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1FlowSchema
     */
  watch?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiListFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApilistFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  watch?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  force?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  force?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  force?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApipatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  force?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchema
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchema
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchema
     */
  _export?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  pretty?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  _export?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  pretty?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchema
     */
  name: string;
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1FlowSchema
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchema
     */
  body: IoK8sApiFlowcontrolV1alpha1FlowSchema;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchema
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchema
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1FlowSchema
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  body: IoK8sApiFlowcontrolV1alpha1FlowSchema;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1FlowSchemaStatus
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  name: string;
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  body: IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  body: IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApireplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus
     */
  fieldManager?: string;
}

export interface FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1FlowSchemaRequest {
  /**
     * name of the FlowSchema
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchema
     */
  watch?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1FlowSchemaListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1FlowSchemaList
     */
  watch?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest {
  /**
     * name of the PriorityLevelConfiguration
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration
     */
  watch?: boolean;
}

export interface FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof FlowcontrolApiserverV1alpha1ApiwatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList
     */
  watch?: boolean;
}

export class ObjectFlowcontrolApiserverV1alpha1Api {
  private api: ObservableFlowcontrolApiserverV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: FlowcontrolApiserverV1alpha1ApiRequestFactory,
    responseProcessor?: FlowcontrolApiserverV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableFlowcontrolApiserverV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a FlowSchema
     * @param param the request object
     */
  public createFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiCreateFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.createFlowcontrolApiserverV1alpha1FlowSchema(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a PriorityLevelConfiguration
     * @param param the request object
     */
  public createFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiCreateFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api
      .createFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * delete collection of FlowSchema
     * @param param the request object
     */
  public deleteFlowcontrolApiserverV1alpha1CollectionFlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1CollectionFlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteFlowcontrolApiserverV1alpha1CollectionFlowSchema(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PriorityLevelConfiguration
     * @param param the request object
     */
  public deleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration(
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a FlowSchema
     * @param param the request object
     */
  public deleteFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteFlowcontrolApiserverV1alpha1FlowSchema(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PriorityLevelConfiguration
     * @param param the request object
     */
  public deleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiDeleteFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
        param.name,
        param.pretty,
        param.dryRun,
        param.gracePeriodSeconds,
        param.orphanDependents,
        param.propagationPolicy,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getFlowcontrolApiserverV1alpha1APIResources(
    param:
      FlowcontrolApiserverV1alpha1ApiGetFlowcontrolApiserverV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getFlowcontrolApiserverV1alpha1APIResources(options)
      .toPromise();
  }

  /**
     * list or watch objects of kind FlowSchema
     * @param param the request object
     */
  public listFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiListFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchemaList> {
    return this.api.listFlowcontrolApiserverV1alpha1FlowSchema(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PriorityLevelConfiguration
     * @param param the request object
     */
  public listFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiListFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfigurationList> {
    return this.api.listFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified FlowSchema
     * @param param the request object
     */
  public patchFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.patchFlowcontrolApiserverV1alpha1FlowSchema(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified FlowSchema
     * @param param the request object
     */
  public patchFlowcontrolApiserverV1alpha1FlowSchemaStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.patchFlowcontrolApiserverV1alpha1FlowSchemaStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public patchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api.patchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public patchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiPatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api
      .patchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        param.force,
        options,
      ).toPromise();
  }

  /**
     * read the specified FlowSchema
     * @param param the request object
     */
  public readFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.readFlowcontrolApiserverV1alpha1FlowSchema(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified FlowSchema
     * @param param the request object
     */
  public readFlowcontrolApiserverV1alpha1FlowSchemaStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.readFlowcontrolApiserverV1alpha1FlowSchemaStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public readFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api.readFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public readFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiReadFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api
      .readFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
        param.name,
        param.pretty,
        options,
      ).toPromise();
  }

  /**
     * replace the specified FlowSchema
     * @param param the request object
     */
  public replaceFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.replaceFlowcontrolApiserverV1alpha1FlowSchema(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified FlowSchema
     * @param param the request object
     */
  public replaceFlowcontrolApiserverV1alpha1FlowSchemaStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1FlowSchemaStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1FlowSchema> {
    return this.api.replaceFlowcontrolApiserverV1alpha1FlowSchemaStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public replaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api
      .replaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * replace status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
  public replaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
    param:
      FlowcontrolApiserverV1alpha1ApiReplaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiFlowcontrolV1alpha1PriorityLevelConfiguration> {
    return this.api
      .replaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus(
        param.name,
        param.body,
        param.pretty,
        param.dryRun,
        param.fieldManager,
        options,
      ).toPromise();
  }

  /**
     * watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchFlowcontrolApiserverV1alpha1FlowSchema(
    param:
      FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1FlowSchemaRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchFlowcontrolApiserverV1alpha1FlowSchema(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchFlowcontrolApiserverV1alpha1FlowSchemaList(
    param:
      FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1FlowSchemaListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchFlowcontrolApiserverV1alpha1FlowSchemaList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
    param:
      FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList(
    param:
      FlowcontrolApiserverV1alpha1ApiWatchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationList(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }
}

import { ObservableLogsApi } from "./ObservableAPI.ts";
import {
  LogsApiRequestFactory,
  LogsApiResponseProcessor,
} from "../apis/LogsApi.ts";

export interface LogsApiLogFileHandlerRequest {
  /**
     * path to the log
     * @type string
     * @memberof LogsApilogFileHandler
     */
  logpath: string;
}

export interface LogsApiLogFileListHandlerRequest {
}

export class ObjectLogsApi {
  private api: ObservableLogsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: LogsApiRequestFactory,
    responseProcessor?: LogsApiResponseProcessor,
  ) {
    this.api = new ObservableLogsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * @param param the request object
     */
  public logFileHandler(
    param: LogsApiLogFileHandlerRequest,
    options?: Configuration,
  ): Promise<void> {
    return this.api.logFileHandler(param.logpath, options).toPromise();
  }

  /**
     * @param param the request object
     */
  public logFileListHandler(
    param: LogsApiLogFileListHandlerRequest,
    options?: Configuration,
  ): Promise<void> {
    return this.api.logFileListHandler(options).toPromise();
  }
}

import { ObservableNetworkingApi } from "./ObservableAPI.ts";
import {
  NetworkingApiRequestFactory,
  NetworkingApiResponseProcessor,
} from "../apis/NetworkingApi.ts";

export interface NetworkingApiGetNetworkingAPIGroupRequest {
}

export class ObjectNetworkingApi {
  private api: ObservableNetworkingApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: NetworkingApiRequestFactory,
    responseProcessor?: NetworkingApiResponseProcessor,
  ) {
    this.api = new ObservableNetworkingApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getNetworkingAPIGroup(
    param: NetworkingApiGetNetworkingAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getNetworkingAPIGroup(options).toPromise();
  }
}

import { ObservableNetworkingV1Api } from "./ObservableAPI.ts";
import {
  NetworkingV1ApiRequestFactory,
  NetworkingV1ApiResponseProcessor,
} from "../apis/NetworkingV1Api.ts";

export interface NetworkingV1ApiCreateNetworkingV1IngressClassRequest {
  /**
     * 
     * @type IoK8sApiNetworkingV1IngressClass
     * @memberof NetworkingV1ApicreateNetworkingV1IngressClass
     */
  body: IoK8sApiNetworkingV1IngressClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1IngressClass
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiCreateNetworkingV1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1Ingress
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedIngress
     */
  body: IoK8sApiNetworkingV1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedIngress
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiCreateNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1NetworkPolicy
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedNetworkPolicy
     */
  body: IoK8sApiNetworkingV1NetworkPolicy;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedNetworkPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApicreateNetworkingV1NamespacedNetworkPolicy
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiDeleteNetworkingV1CollectionIngressClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionIngressClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiDeleteNetworkingV1CollectionNamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiDeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1CollectionNamespacedNetworkPolicy
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiDeleteNetworkingV1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1IngressClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiDeleteNetworkingV1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiDeleteNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1ApideleteNetworkingV1NamespacedNetworkPolicy
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1ApiGetNetworkingV1APIResourcesRequest {
}

export interface NetworkingV1ApiListNetworkingV1IngressClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1IngressClass
     */
  watch?: boolean;
}

export interface NetworkingV1ApiListNetworkingV1IngressForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1IngressForAllNamespaces
     */
  watch?: boolean;
}

export interface NetworkingV1ApiListNetworkingV1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedIngress
     */
  watch?: boolean;
}

export interface NetworkingV1ApiListNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NamespacedNetworkPolicy
     */
  watch?: boolean;
}

export interface NetworkingV1ApiListNetworkingV1NetworkPolicyForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkingV1NetworkPolicyForAllNamespaces
     */
  watch?: boolean;
}

export interface NetworkingV1ApiPatchNetworkingV1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNetworkingV1IngressClass
     */
  force?: boolean;
}

export interface NetworkingV1ApiPatchNetworkingV1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngress
     */
  force?: boolean;
}

export interface NetworkingV1ApiPatchNetworkingV1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedIngressStatus
     */
  force?: boolean;
}

export interface NetworkingV1ApiPatchNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1ApipatchNetworkingV1NamespacedNetworkPolicy
     */
  force?: boolean;
}

export interface NetworkingV1ApiReadNetworkingV1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1IngressClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1IngressClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1IngressClass
     */
  _export?: boolean;
}

export interface NetworkingV1ApiReadNetworkingV1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngress
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngress
     */
  _export?: boolean;
}

export interface NetworkingV1ApiReadNetworkingV1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedIngressStatus
     */
  pretty?: string;
}

export interface NetworkingV1ApiReadNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedNetworkPolicy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedNetworkPolicy
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1ApireadNetworkingV1NamespacedNetworkPolicy
     */
  _export?: boolean;
}

export interface NetworkingV1ApiReplaceNetworkingV1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1IngressClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1IngressClass
     * @memberof NetworkingV1ApireplaceNetworkingV1IngressClass
     */
  body: IoK8sApiNetworkingV1IngressClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1IngressClass
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiReplaceNetworkingV1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1Ingress
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  body: IoK8sApiNetworkingV1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngress
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiReplaceNetworkingV1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1Ingress
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  body: IoK8sApiNetworkingV1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedIngressStatus
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiReplaceNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1NetworkPolicy
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  body: IoK8sApiNetworkingV1NetworkPolicy;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1ApireplaceNetworkingV1NamespacedNetworkPolicy
     */
  fieldManager?: string;
}

export interface NetworkingV1ApiWatchNetworkingV1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClass
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1IngressClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressClassList
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1IngressListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1IngressListForAllNamespaces
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngress
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1NamespacedIngressListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedIngressList
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1NamespacedNetworkPolicyRequest {
  /**
     * name of the NetworkPolicy
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicy
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1NamespacedNetworkPolicyListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NamespacedNetworkPolicyList
     */
  watch?: boolean;
}

export interface NetworkingV1ApiWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1ApiwatchNetworkingV1NetworkPolicyListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectNetworkingV1Api {
  private api: ObservableNetworkingV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: NetworkingV1ApiRequestFactory,
    responseProcessor?: NetworkingV1ApiResponseProcessor,
  ) {
    this.api = new ObservableNetworkingV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an IngressClass
     * @param param the request object
     */
  public createNetworkingV1IngressClass(
    param: NetworkingV1ApiCreateNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressClass> {
    return this.api.createNetworkingV1IngressClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create an Ingress
     * @param param the request object
     */
  public createNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiCreateNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.createNetworkingV1NamespacedIngress(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a NetworkPolicy
     * @param param the request object
     */
  public createNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiCreateNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicy> {
    return this.api.createNetworkingV1NamespacedNetworkPolicy(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of IngressClass
     * @param param the request object
     */
  public deleteNetworkingV1CollectionIngressClass(
    param: NetworkingV1ApiDeleteNetworkingV1CollectionIngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1CollectionIngressClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Ingress
     * @param param the request object
     */
  public deleteNetworkingV1CollectionNamespacedIngress(
    param: NetworkingV1ApiDeleteNetworkingV1CollectionNamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1CollectionNamespacedIngress(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of NetworkPolicy
     * @param param the request object
     */
  public deleteNetworkingV1CollectionNamespacedNetworkPolicy(
    param:
      NetworkingV1ApiDeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1CollectionNamespacedNetworkPolicy(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an IngressClass
     * @param param the request object
     */
  public deleteNetworkingV1IngressClass(
    param: NetworkingV1ApiDeleteNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1IngressClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Ingress
     * @param param the request object
     */
  public deleteNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiDeleteNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a NetworkPolicy
     * @param param the request object
     */
  public deleteNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiDeleteNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1NamespacedNetworkPolicy(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getNetworkingV1APIResources(
    param: NetworkingV1ApiGetNetworkingV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getNetworkingV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
  public listNetworkingV1IngressClass(
    param: NetworkingV1ApiListNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressClassList> {
    return this.api.listNetworkingV1IngressClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listNetworkingV1IngressForAllNamespaces(
    param: NetworkingV1ApiListNetworkingV1IngressForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressList> {
    return this.api.listNetworkingV1IngressForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiListNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressList> {
    return this.api.listNetworkingV1NamespacedIngress(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
  public listNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiListNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicyList> {
    return this.api.listNetworkingV1NamespacedNetworkPolicy(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
  public listNetworkingV1NetworkPolicyForAllNamespaces(
    param: NetworkingV1ApiListNetworkingV1NetworkPolicyForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicyList> {
    return this.api.listNetworkingV1NetworkPolicyForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified IngressClass
     * @param param the request object
     */
  public patchNetworkingV1IngressClass(
    param: NetworkingV1ApiPatchNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressClass> {
    return this.api.patchNetworkingV1IngressClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Ingress
     * @param param the request object
     */
  public patchNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiPatchNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.patchNetworkingV1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
  public patchNetworkingV1NamespacedIngressStatus(
    param: NetworkingV1ApiPatchNetworkingV1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.patchNetworkingV1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified NetworkPolicy
     * @param param the request object
     */
  public patchNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiPatchNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicy> {
    return this.api.patchNetworkingV1NamespacedNetworkPolicy(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified IngressClass
     * @param param the request object
     */
  public readNetworkingV1IngressClass(
    param: NetworkingV1ApiReadNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressClass> {
    return this.api.readNetworkingV1IngressClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified Ingress
     * @param param the request object
     */
  public readNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiReadNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.readNetworkingV1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Ingress
     * @param param the request object
     */
  public readNetworkingV1NamespacedIngressStatus(
    param: NetworkingV1ApiReadNetworkingV1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.readNetworkingV1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified NetworkPolicy
     * @param param the request object
     */
  public readNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiReadNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicy> {
    return this.api.readNetworkingV1NamespacedNetworkPolicy(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified IngressClass
     * @param param the request object
     */
  public replaceNetworkingV1IngressClass(
    param: NetworkingV1ApiReplaceNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1IngressClass> {
    return this.api.replaceNetworkingV1IngressClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Ingress
     * @param param the request object
     */
  public replaceNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiReplaceNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.replaceNetworkingV1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Ingress
     * @param param the request object
     */
  public replaceNetworkingV1NamespacedIngressStatus(
    param: NetworkingV1ApiReplaceNetworkingV1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1Ingress> {
    return this.api.replaceNetworkingV1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified NetworkPolicy
     * @param param the request object
     */
  public replaceNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiReplaceNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1NetworkPolicy> {
    return this.api.replaceNetworkingV1NamespacedNetworkPolicy(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind IngressClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNetworkingV1IngressClass(
    param: NetworkingV1ApiWatchNetworkingV1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1IngressClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of IngressClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1IngressClassList(
    param: NetworkingV1ApiWatchNetworkingV1IngressClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1IngressClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1IngressListForAllNamespaces(
    param: NetworkingV1ApiWatchNetworkingV1IngressListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1IngressListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNetworkingV1NamespacedIngress(
    param: NetworkingV1ApiWatchNetworkingV1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1NamespacedIngress(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1NamespacedIngressList(
    param: NetworkingV1ApiWatchNetworkingV1NamespacedIngressListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1NamespacedIngressList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNetworkingV1NamespacedNetworkPolicy(
    param: NetworkingV1ApiWatchNetworkingV1NamespacedNetworkPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1NamespacedNetworkPolicy(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1NamespacedNetworkPolicyList(
    param: NetworkingV1ApiWatchNetworkingV1NamespacedNetworkPolicyListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1NamespacedNetworkPolicyList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1NetworkPolicyListForAllNamespaces(
    param:
      NetworkingV1ApiWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1NetworkPolicyListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableNetworkingV1beta1Api } from "./ObservableAPI.ts";
import {
  NetworkingV1beta1ApiRequestFactory,
  NetworkingV1beta1ApiResponseProcessor,
} from "../apis/NetworkingV1beta1Api.ts";

export interface NetworkingV1beta1ApiCreateNetworkingV1beta1IngressClassRequest {
  /**
     * 
     * @type IoK8sApiNetworkingV1beta1IngressClass
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1IngressClass
     */
  body: IoK8sApiNetworkingV1beta1IngressClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1IngressClass
     */
  fieldManager?: string;
}

export interface NetworkingV1beta1ApiCreateNetworkingV1beta1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1beta1Ingress
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1NamespacedIngress
     */
  body: IoK8sApiNetworkingV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1beta1ApicreateNetworkingV1beta1NamespacedIngress
     */
  fieldManager?: string;
}

export interface NetworkingV1beta1ApiDeleteNetworkingV1beta1CollectionIngressClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionIngressClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1beta1ApiDeleteNetworkingV1beta1CollectionNamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1CollectionNamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1beta1ApiDeleteNetworkingV1beta1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1IngressClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1beta1ApiDeleteNetworkingV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteNetworkingV1beta1NamespacedIngress
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NetworkingV1beta1ApiGetNetworkingV1beta1APIResourcesRequest {
}

export interface NetworkingV1beta1ApiListNetworkingV1beta1IngressClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressClass
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiListNetworkingV1beta1IngressForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1IngressForAllNamespaces
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiListNetworkingV1beta1NamespacedIngressRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApilistNetworkingV1beta1NamespacedIngress
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiPatchNetworkingV1beta1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1IngressClass
     */
  force?: boolean;
}

export interface NetworkingV1beta1ApiPatchNetworkingV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngress
     */
  force?: boolean;
}

export interface NetworkingV1beta1ApiPatchNetworkingV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchNetworkingV1beta1NamespacedIngressStatus
     */
  force?: boolean;
}

export interface NetworkingV1beta1ApiReadNetworkingV1beta1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1IngressClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1IngressClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1IngressClass
     */
  _export?: boolean;
}

export interface NetworkingV1beta1ApiReadNetworkingV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngress
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngress
     */
  _export?: boolean;
}

export interface NetworkingV1beta1ApiReadNetworkingV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireadNetworkingV1beta1NamespacedIngressStatus
     */
  pretty?: string;
}

export interface NetworkingV1beta1ApiReplaceNetworkingV1beta1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1IngressClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1beta1IngressClass
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1IngressClass
     */
  body: IoK8sApiNetworkingV1beta1IngressClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1IngressClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1IngressClass
     */
  fieldManager?: string;
}

export interface NetworkingV1beta1ApiReplaceNetworkingV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1beta1Ingress
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  body: IoK8sApiNetworkingV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngress
     */
  fieldManager?: string;
}

export interface NetworkingV1beta1ApiReplaceNetworkingV1beta1NamespacedIngressStatusRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiNetworkingV1beta1Ingress
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  body: IoK8sApiNetworkingV1beta1Ingress;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NetworkingV1beta1ApireplaceNetworkingV1beta1NamespacedIngressStatus
     */
  fieldManager?: string;
}

export interface NetworkingV1beta1ApiWatchNetworkingV1beta1IngressClassRequest {
  /**
     * name of the IngressClass
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClass
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiWatchNetworkingV1beta1IngressClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressClassList
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiWatchNetworkingV1beta1IngressListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1IngressListForAllNamespaces
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiWatchNetworkingV1beta1NamespacedIngressRequest {
  /**
     * name of the Ingress
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngress
     */
  watch?: boolean;
}

export interface NetworkingV1beta1ApiWatchNetworkingV1beta1NamespacedIngressListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NetworkingV1beta1ApiwatchNetworkingV1beta1NamespacedIngressList
     */
  watch?: boolean;
}

export class ObjectNetworkingV1beta1Api {
  private api: ObservableNetworkingV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: NetworkingV1beta1ApiRequestFactory,
    responseProcessor?: NetworkingV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableNetworkingV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create an IngressClass
     * @param param the request object
     */
  public createNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiCreateNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressClass> {
    return this.api.createNetworkingV1beta1IngressClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create an Ingress
     * @param param the request object
     */
  public createNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiCreateNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.createNetworkingV1beta1NamespacedIngress(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of IngressClass
     * @param param the request object
     */
  public deleteNetworkingV1beta1CollectionIngressClass(
    param:
      NetworkingV1beta1ApiDeleteNetworkingV1beta1CollectionIngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1beta1CollectionIngressClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Ingress
     * @param param the request object
     */
  public deleteNetworkingV1beta1CollectionNamespacedIngress(
    param:
      NetworkingV1beta1ApiDeleteNetworkingV1beta1CollectionNamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1beta1CollectionNamespacedIngress(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an IngressClass
     * @param param the request object
     */
  public deleteNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiDeleteNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1beta1IngressClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete an Ingress
     * @param param the request object
     */
  public deleteNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiDeleteNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNetworkingV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getNetworkingV1beta1APIResources(
    param: NetworkingV1beta1ApiGetNetworkingV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getNetworkingV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
  public listNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiListNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressClassList> {
    return this.api.listNetworkingV1beta1IngressClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listNetworkingV1beta1IngressForAllNamespaces(
    param:
      NetworkingV1beta1ApiListNetworkingV1beta1IngressForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressList> {
    return this.api.listNetworkingV1beta1IngressForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
  public listNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiListNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressList> {
    return this.api.listNetworkingV1beta1NamespacedIngress(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified IngressClass
     * @param param the request object
     */
  public patchNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiPatchNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressClass> {
    return this.api.patchNetworkingV1beta1IngressClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Ingress
     * @param param the request object
     */
  public patchNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiPatchNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.patchNetworkingV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
  public patchNetworkingV1beta1NamespacedIngressStatus(
    param:
      NetworkingV1beta1ApiPatchNetworkingV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.patchNetworkingV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified IngressClass
     * @param param the request object
     */
  public readNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiReadNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressClass> {
    return this.api.readNetworkingV1beta1IngressClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified Ingress
     * @param param the request object
     */
  public readNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiReadNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.readNetworkingV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified Ingress
     * @param param the request object
     */
  public readNetworkingV1beta1NamespacedIngressStatus(
    param:
      NetworkingV1beta1ApiReadNetworkingV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.readNetworkingV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified IngressClass
     * @param param the request object
     */
  public replaceNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiReplaceNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1IngressClass> {
    return this.api.replaceNetworkingV1beta1IngressClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Ingress
     * @param param the request object
     */
  public replaceNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiReplaceNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.replaceNetworkingV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified Ingress
     * @param param the request object
     */
  public replaceNetworkingV1beta1NamespacedIngressStatus(
    param:
      NetworkingV1beta1ApiReplaceNetworkingV1beta1NamespacedIngressStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNetworkingV1beta1Ingress> {
    return this.api.replaceNetworkingV1beta1NamespacedIngressStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind IngressClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNetworkingV1beta1IngressClass(
    param: NetworkingV1beta1ApiWatchNetworkingV1beta1IngressClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1beta1IngressClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of IngressClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1beta1IngressClassList(
    param: NetworkingV1beta1ApiWatchNetworkingV1beta1IngressClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1beta1IngressClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1beta1IngressListForAllNamespaces(
    param:
      NetworkingV1beta1ApiWatchNetworkingV1beta1IngressListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1beta1IngressListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNetworkingV1beta1NamespacedIngress(
    param: NetworkingV1beta1ApiWatchNetworkingV1beta1NamespacedIngressRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1beta1NamespacedIngress(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNetworkingV1beta1NamespacedIngressList(
    param:
      NetworkingV1beta1ApiWatchNetworkingV1beta1NamespacedIngressListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNetworkingV1beta1NamespacedIngressList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableNodeApi } from "./ObservableAPI.ts";
import {
  NodeApiRequestFactory,
  NodeApiResponseProcessor,
} from "../apis/NodeApi.ts";

export interface NodeApiGetNodeAPIGroupRequest {
}

export class ObjectNodeApi {
  private api: ObservableNodeApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: NodeApiRequestFactory,
    responseProcessor?: NodeApiResponseProcessor,
  ) {
    this.api = new ObservableNodeApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getNodeAPIGroup(
    param: NodeApiGetNodeAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getNodeAPIGroup(options).toPromise();
  }
}

import { ObservableNodeV1alpha1Api } from "./ObservableAPI.ts";
import {
  NodeV1alpha1ApiRequestFactory,
  NodeV1alpha1ApiResponseProcessor,
} from "../apis/NodeV1alpha1Api.ts";

export interface NodeV1alpha1ApiCreateNodeV1alpha1RuntimeClassRequest {
  /**
     * 
     * @type IoK8sApiNodeV1alpha1RuntimeClass
     * @memberof NodeV1alpha1ApicreateNodeV1alpha1RuntimeClass
     */
  body: IoK8sApiNodeV1alpha1RuntimeClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApicreateNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApicreateNodeV1alpha1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1alpha1ApicreateNodeV1alpha1RuntimeClass
     */
  fieldManager?: string;
}

export interface NodeV1alpha1ApiDeleteNodeV1alpha1CollectionRuntimeClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1CollectionRuntimeClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NodeV1alpha1ApiDeleteNodeV1alpha1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NodeV1alpha1ApideleteNodeV1alpha1RuntimeClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NodeV1alpha1ApiGetNodeV1alpha1APIResourcesRequest {
}

export interface NodeV1alpha1ApiListNodeV1alpha1RuntimeClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1alpha1ApilistNodeV1alpha1RuntimeClass
     */
  watch?: boolean;
}

export interface NodeV1alpha1ApiPatchNodeV1alpha1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NodeV1alpha1ApipatchNodeV1alpha1RuntimeClass
     */
  force?: boolean;
}

export interface NodeV1alpha1ApiReadNodeV1alpha1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApireadNodeV1alpha1RuntimeClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApireadNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NodeV1alpha1ApireadNodeV1alpha1RuntimeClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NodeV1alpha1ApireadNodeV1alpha1RuntimeClass
     */
  _export?: boolean;
}

export interface NodeV1alpha1ApiReplaceNodeV1alpha1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApireplaceNodeV1alpha1RuntimeClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiNodeV1alpha1RuntimeClass
     * @memberof NodeV1alpha1ApireplaceNodeV1alpha1RuntimeClass
     */
  body: IoK8sApiNodeV1alpha1RuntimeClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApireplaceNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1alpha1ApireplaceNodeV1alpha1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1alpha1ApireplaceNodeV1alpha1RuntimeClass
     */
  fieldManager?: string;
}

export interface NodeV1alpha1ApiWatchNodeV1alpha1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClass
     */
  watch?: boolean;
}

export interface NodeV1alpha1ApiWatchNodeV1alpha1RuntimeClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1alpha1ApiwatchNodeV1alpha1RuntimeClassList
     */
  watch?: boolean;
}

export class ObjectNodeV1alpha1Api {
  private api: ObservableNodeV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: NodeV1alpha1ApiRequestFactory,
    responseProcessor?: NodeV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableNodeV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a RuntimeClass
     * @param param the request object
     */
  public createNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiCreateNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1alpha1RuntimeClass> {
    return this.api.createNodeV1alpha1RuntimeClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
  public deleteNodeV1alpha1CollectionRuntimeClass(
    param: NodeV1alpha1ApiDeleteNodeV1alpha1CollectionRuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNodeV1alpha1CollectionRuntimeClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a RuntimeClass
     * @param param the request object
     */
  public deleteNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiDeleteNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNodeV1alpha1RuntimeClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getNodeV1alpha1APIResources(
    param: NodeV1alpha1ApiGetNodeV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getNodeV1alpha1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
  public listNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiListNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1alpha1RuntimeClassList> {
    return this.api.listNodeV1alpha1RuntimeClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
  public patchNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiPatchNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1alpha1RuntimeClass> {
    return this.api.patchNodeV1alpha1RuntimeClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified RuntimeClass
     * @param param the request object
     */
  public readNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiReadNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1alpha1RuntimeClass> {
    return this.api.readNodeV1alpha1RuntimeClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
  public replaceNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiReplaceNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1alpha1RuntimeClass> {
    return this.api.replaceNodeV1alpha1RuntimeClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNodeV1alpha1RuntimeClass(
    param: NodeV1alpha1ApiWatchNodeV1alpha1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNodeV1alpha1RuntimeClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNodeV1alpha1RuntimeClassList(
    param: NodeV1alpha1ApiWatchNodeV1alpha1RuntimeClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNodeV1alpha1RuntimeClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableNodeV1beta1Api } from "./ObservableAPI.ts";
import {
  NodeV1beta1ApiRequestFactory,
  NodeV1beta1ApiResponseProcessor,
} from "../apis/NodeV1beta1Api.ts";

export interface NodeV1beta1ApiCreateNodeV1beta1RuntimeClassRequest {
  /**
     * 
     * @type IoK8sApiNodeV1beta1RuntimeClass
     * @memberof NodeV1beta1ApicreateNodeV1beta1RuntimeClass
     */
  body: IoK8sApiNodeV1beta1RuntimeClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApicreateNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApicreateNodeV1beta1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1beta1ApicreateNodeV1beta1RuntimeClass
     */
  fieldManager?: string;
}

export interface NodeV1beta1ApiDeleteNodeV1beta1CollectionRuntimeClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NodeV1beta1ApideleteNodeV1beta1CollectionRuntimeClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NodeV1beta1ApiDeleteNodeV1beta1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof NodeV1beta1ApideleteNodeV1beta1RuntimeClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface NodeV1beta1ApiGetNodeV1beta1APIResourcesRequest {
}

export interface NodeV1beta1ApiListNodeV1beta1RuntimeClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1beta1ApilistNodeV1beta1RuntimeClass
     */
  watch?: boolean;
}

export interface NodeV1beta1ApiPatchNodeV1beta1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof NodeV1beta1ApipatchNodeV1beta1RuntimeClass
     */
  force?: boolean;
}

export interface NodeV1beta1ApiReadNodeV1beta1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApireadNodeV1beta1RuntimeClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApireadNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NodeV1beta1ApireadNodeV1beta1RuntimeClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof NodeV1beta1ApireadNodeV1beta1RuntimeClass
     */
  _export?: boolean;
}

export interface NodeV1beta1ApiReplaceNodeV1beta1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApireplaceNodeV1beta1RuntimeClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiNodeV1beta1RuntimeClass
     * @memberof NodeV1beta1ApireplaceNodeV1beta1RuntimeClass
     */
  body: IoK8sApiNodeV1beta1RuntimeClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApireplaceNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof NodeV1beta1ApireplaceNodeV1beta1RuntimeClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof NodeV1beta1ApireplaceNodeV1beta1RuntimeClass
     */
  fieldManager?: string;
}

export interface NodeV1beta1ApiWatchNodeV1beta1RuntimeClassRequest {
  /**
     * name of the RuntimeClass
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClass
     */
  watch?: boolean;
}

export interface NodeV1beta1ApiWatchNodeV1beta1RuntimeClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof NodeV1beta1ApiwatchNodeV1beta1RuntimeClassList
     */
  watch?: boolean;
}

export class ObjectNodeV1beta1Api {
  private api: ObservableNodeV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: NodeV1beta1ApiRequestFactory,
    responseProcessor?: NodeV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableNodeV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a RuntimeClass
     * @param param the request object
     */
  public createNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiCreateNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1beta1RuntimeClass> {
    return this.api.createNodeV1beta1RuntimeClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
  public deleteNodeV1beta1CollectionRuntimeClass(
    param: NodeV1beta1ApiDeleteNodeV1beta1CollectionRuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNodeV1beta1CollectionRuntimeClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a RuntimeClass
     * @param param the request object
     */
  public deleteNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiDeleteNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteNodeV1beta1RuntimeClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getNodeV1beta1APIResources(
    param: NodeV1beta1ApiGetNodeV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getNodeV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
  public listNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiListNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1beta1RuntimeClassList> {
    return this.api.listNodeV1beta1RuntimeClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
  public patchNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiPatchNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1beta1RuntimeClass> {
    return this.api.patchNodeV1beta1RuntimeClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified RuntimeClass
     * @param param the request object
     */
  public readNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiReadNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1beta1RuntimeClass> {
    return this.api.readNodeV1beta1RuntimeClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
  public replaceNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiReplaceNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiNodeV1beta1RuntimeClass> {
    return this.api.replaceNodeV1beta1RuntimeClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchNodeV1beta1RuntimeClass(
    param: NodeV1beta1ApiWatchNodeV1beta1RuntimeClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNodeV1beta1RuntimeClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchNodeV1beta1RuntimeClassList(
    param: NodeV1beta1ApiWatchNodeV1beta1RuntimeClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchNodeV1beta1RuntimeClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservablePolicyApi } from "./ObservableAPI.ts";
import {
  PolicyApiRequestFactory,
  PolicyApiResponseProcessor,
} from "../apis/PolicyApi.ts";

export interface PolicyApiGetPolicyAPIGroupRequest {
}

export class ObjectPolicyApi {
  private api: ObservablePolicyApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: PolicyApiRequestFactory,
    responseProcessor?: PolicyApiResponseProcessor,
  ) {
    this.api = new ObservablePolicyApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getPolicyAPIGroup(
    param: PolicyApiGetPolicyAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getPolicyAPIGroup(options).toPromise();
  }
}

import { ObservablePolicyV1beta1Api } from "./ObservableAPI.ts";
import {
  PolicyV1beta1ApiRequestFactory,
  PolicyV1beta1ApiResponseProcessor,
} from "../apis/PolicyV1beta1Api.ts";

export interface PolicyV1beta1ApiCreatePolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiPolicyV1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1NamespacedPodDisruptionBudget
     */
  body: IoK8sApiPolicyV1beta1PodDisruptionBudget;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1NamespacedPodDisruptionBudget
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1NamespacedPodDisruptionBudget
     */
  fieldManager?: string;
}

export interface PolicyV1beta1ApiCreatePolicyV1beta1PodSecurityPolicyRequest {
  /**
     * 
     * @type IoK8sApiPolicyV1beta1PodSecurityPolicy
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1PodSecurityPolicy
     */
  body: IoK8sApiPolicyV1beta1PodSecurityPolicy;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1PodSecurityPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApicreatePolicyV1beta1PodSecurityPolicy
     */
  fieldManager?: string;
}

export interface PolicyV1beta1ApiDeletePolicyV1beta1CollectionNamespacedPodDisruptionBudgetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionNamespacedPodDisruptionBudget
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface PolicyV1beta1ApiDeletePolicyV1beta1CollectionPodSecurityPolicyRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof PolicyV1beta1ApideletePolicyV1beta1CollectionPodSecurityPolicy
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface PolicyV1beta1ApiDeletePolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof PolicyV1beta1ApideletePolicyV1beta1NamespacedPodDisruptionBudget
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface PolicyV1beta1ApiDeletePolicyV1beta1PodSecurityPolicyRequest {
  /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof PolicyV1beta1ApideletePolicyV1beta1PodSecurityPolicy
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface PolicyV1beta1ApiGetPolicyV1beta1APIResourcesRequest {
}

export interface PolicyV1beta1ApiListPolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1NamespacedPodDisruptionBudget
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodDisruptionBudgetForAllNamespaces
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiListPolicyV1beta1PodSecurityPolicyRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApilistPolicyV1beta1PodSecurityPolicy
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiPatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  force?: boolean;
}

export interface PolicyV1beta1ApiPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  force?: boolean;
}

export interface PolicyV1beta1ApiPatchPolicyV1beta1PodSecurityPolicyRequest {
  /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof PolicyV1beta1ApipatchPolicyV1beta1PodSecurityPolicy
     */
  force?: boolean;
}

export interface PolicyV1beta1ApiReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudget
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudget
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudget
     */
  _export?: boolean;
}

export interface PolicyV1beta1ApiReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  pretty?: string;
}

export interface PolicyV1beta1ApiReadPolicyV1beta1PodSecurityPolicyRequest {
  /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1PodSecurityPolicy
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireadPolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof PolicyV1beta1ApireadPolicyV1beta1PodSecurityPolicy
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof PolicyV1beta1ApireadPolicyV1beta1PodSecurityPolicy
     */
  _export?: boolean;
}

export interface PolicyV1beta1ApiReplacePolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiPolicyV1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  body: IoK8sApiPolicyV1beta1PodDisruptionBudget;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudget
     */
  fieldManager?: string;
}

export interface PolicyV1beta1ApiReplacePolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiPolicyV1beta1PodDisruptionBudget
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  body: IoK8sApiPolicyV1beta1PodDisruptionBudget;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1NamespacedPodDisruptionBudgetStatus
     */
  fieldManager?: string;
}

export interface PolicyV1beta1ApiReplacePolicyV1beta1PodSecurityPolicyRequest {
  /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1PodSecurityPolicy
     */
  name: string;
  /**
     * 
     * @type IoK8sApiPolicyV1beta1PodSecurityPolicy
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1PodSecurityPolicy
     */
  body: IoK8sApiPolicyV1beta1PodSecurityPolicy;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1PodSecurityPolicy
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof PolicyV1beta1ApireplacePolicyV1beta1PodSecurityPolicy
     */
  fieldManager?: string;
}

export interface PolicyV1beta1ApiWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest {
  /**
     * name of the PodDisruptionBudget
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudget
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1NamespacedPodDisruptionBudgetList
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiWatchPolicyV1beta1PodSecurityPolicyRequest {
  /**
     * name of the PodSecurityPolicy
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicy
     */
  watch?: boolean;
}

export interface PolicyV1beta1ApiWatchPolicyV1beta1PodSecurityPolicyListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof PolicyV1beta1ApiwatchPolicyV1beta1PodSecurityPolicyList
     */
  watch?: boolean;
}

export class ObjectPolicyV1beta1Api {
  private api: ObservablePolicyV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: PolicyV1beta1ApiRequestFactory,
    responseProcessor?: PolicyV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservablePolicyV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
  public createPolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiCreatePolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.createPolicyV1beta1NamespacedPodDisruptionBudget(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a PodSecurityPolicy
     * @param param the request object
     */
  public createPolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiCreatePolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicy> {
    return this.api.createPolicyV1beta1PodSecurityPolicy(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
  public deletePolicyV1beta1CollectionNamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiDeletePolicyV1beta1CollectionNamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deletePolicyV1beta1CollectionNamespacedPodDisruptionBudget(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PodSecurityPolicy
     * @param param the request object
     */
  public deletePolicyV1beta1CollectionPodSecurityPolicy(
    param:
      PolicyV1beta1ApiDeletePolicyV1beta1CollectionPodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deletePolicyV1beta1CollectionPodSecurityPolicy(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
  public deletePolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiDeletePolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deletePolicyV1beta1NamespacedPodDisruptionBudget(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PodSecurityPolicy
     * @param param the request object
     */
  public deletePolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiDeletePolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicy> {
    return this.api.deletePolicyV1beta1PodSecurityPolicy(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getPolicyV1beta1APIResources(
    param: PolicyV1beta1ApiGetPolicyV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getPolicyV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
  public listPolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiListPolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudgetList> {
    return this.api.listPolicyV1beta1NamespacedPodDisruptionBudget(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
  public listPolicyV1beta1PodDisruptionBudgetForAllNamespaces(
    param:
      PolicyV1beta1ApiListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudgetList> {
    return this.api.listPolicyV1beta1PodDisruptionBudgetForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PodSecurityPolicy
     * @param param the request object
     */
  public listPolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiListPolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicyList> {
    return this.api.listPolicyV1beta1PodSecurityPolicy(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
  public patchPolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiPatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.patchPolicyV1beta1NamespacedPodDisruptionBudget(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
  public patchPolicyV1beta1NamespacedPodDisruptionBudgetStatus(
    param:
      PolicyV1beta1ApiPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.patchPolicyV1beta1NamespacedPodDisruptionBudgetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PodSecurityPolicy
     * @param param the request object
     */
  public patchPolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiPatchPolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicy> {
    return this.api.patchPolicyV1beta1PodSecurityPolicy(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
  public readPolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.readPolicyV1beta1NamespacedPodDisruptionBudget(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
  public readPolicyV1beta1NamespacedPodDisruptionBudgetStatus(
    param:
      PolicyV1beta1ApiReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.readPolicyV1beta1NamespacedPodDisruptionBudgetStatus(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified PodSecurityPolicy
     * @param param the request object
     */
  public readPolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiReadPolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicy> {
    return this.api.readPolicyV1beta1PodSecurityPolicy(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
  public replacePolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiReplacePolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.replacePolicyV1beta1NamespacedPodDisruptionBudget(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
  public replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus(
    param:
      PolicyV1beta1ApiReplacePolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodDisruptionBudget> {
    return this.api.replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PodSecurityPolicy
     * @param param the request object
     */
  public replacePolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiReplacePolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApiPolicyV1beta1PodSecurityPolicy> {
    return this.api.replacePolicyV1beta1PodSecurityPolicy(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchPolicyV1beta1NamespacedPodDisruptionBudget(
    param:
      PolicyV1beta1ApiWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchPolicyV1beta1NamespacedPodDisruptionBudget(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchPolicyV1beta1NamespacedPodDisruptionBudgetList(
    param:
      PolicyV1beta1ApiWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchPolicyV1beta1NamespacedPodDisruptionBudgetList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(
    param:
      PolicyV1beta1ApiWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PodSecurityPolicy. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchPolicyV1beta1PodSecurityPolicy(
    param: PolicyV1beta1ApiWatchPolicyV1beta1PodSecurityPolicyRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchPolicyV1beta1PodSecurityPolicy(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodSecurityPolicy. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchPolicyV1beta1PodSecurityPolicyList(
    param: PolicyV1beta1ApiWatchPolicyV1beta1PodSecurityPolicyListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchPolicyV1beta1PodSecurityPolicyList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableRbacAuthorizationApi } from "./ObservableAPI.ts";
import {
  RbacAuthorizationApiRequestFactory,
  RbacAuthorizationApiResponseProcessor,
} from "../apis/RbacAuthorizationApi.ts";

export interface RbacAuthorizationApiGetRbacAuthorizationAPIGroupRequest {
}

export class ObjectRbacAuthorizationApi {
  private api: ObservableRbacAuthorizationApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: RbacAuthorizationApiRequestFactory,
    responseProcessor?: RbacAuthorizationApiResponseProcessor,
  ) {
    this.api = new ObservableRbacAuthorizationApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getRbacAuthorizationAPIGroup(
    param: RbacAuthorizationApiGetRbacAuthorizationAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getRbacAuthorizationAPIGroup(options).toPromise();
  }
}

import { ObservableRbacAuthorizationV1Api } from "./ObservableAPI.ts";
import {
  RbacAuthorizationV1ApiRequestFactory,
  RbacAuthorizationV1ApiResponseProcessor,
} from "../apis/RbacAuthorizationV1Api.ts";

export interface RbacAuthorizationV1ApiCreateRbacAuthorizationV1ClusterRoleRequest {
  /**
     * 
     * @type IoK8sApiRbacV1ClusterRole
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRole
     */
  body: IoK8sApiRbacV1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiCreateRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * 
     * @type IoK8sApiRbacV1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiCreateRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1Role
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRole
     */
  body: IoK8sApiRbacV1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiCreateRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1RoleBinding
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApicreateRbacAuthorizationV1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1ClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionNamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1CollectionNamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiDeleteRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteRbacAuthorizationV1NamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1ApiGetRbacAuthorizationV1APIResourcesRequest {
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1ClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1RoleBindingForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleBindingForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiListRbacAuthorizationV1RoleForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRbacAuthorizationV1RoleForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiPatchRbacAuthorizationV1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1ApiPatchRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1ClusterRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1ApiPatchRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1ApiPatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchRbacAuthorizationV1NamespacedRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1ApiReadRbacAuthorizationV1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1ApiReadRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1ApiReadRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1ApiReadRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireadRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1ApiReplaceRbacAuthorizationV1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRole
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1ClusterRole
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRole
     */
  body: IoK8sApiRbacV1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiReplaceRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiReplaceRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1Role
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  body: IoK8sApiRbacV1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiReplaceRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1RoleBinding
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceRbacAuthorizationV1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleBindingListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1ClusterRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleBindingListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1NamespacedRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleBindingListForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1ApiWatchRbacAuthorizationV1RoleListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1ApiwatchRbacAuthorizationV1RoleListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectRbacAuthorizationV1Api {
  private api: ObservableRbacAuthorizationV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: RbacAuthorizationV1ApiRequestFactory,
    responseProcessor?: RbacAuthorizationV1ApiResponseProcessor,
  ) {
    this.api = new ObservableRbacAuthorizationV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a ClusterRole
     * @param param the request object
     */
  public createRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiCreateRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRole> {
    return this.api.createRbacAuthorizationV1ClusterRole(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiCreateRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleBinding> {
    return this.api.createRbacAuthorizationV1ClusterRoleBinding(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Role
     * @param param the request object
     */
  public createRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiCreateRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1Role> {
    return this.api.createRbacAuthorizationV1NamespacedRole(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a RoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiCreateRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBinding> {
    return this.api.createRbacAuthorizationV1NamespacedRoleBinding(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiDeleteRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1ClusterRole(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1ClusterRoleBinding(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1CollectionClusterRole(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1CollectionClusterRole(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1CollectionClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1CollectionClusterRoleBinding(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1CollectionNamespacedRole(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionNamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1CollectionNamespacedRole(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1CollectionNamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1CollectionNamespacedRoleBinding(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiDeleteRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiDeleteRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getRbacAuthorizationV1APIResources(
    param: RbacAuthorizationV1ApiGetRbacAuthorizationV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getRbacAuthorizationV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
  public listRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiListRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleList> {
    return this.api.listRbacAuthorizationV1ClusterRole(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiListRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleBindingList> {
    return this.api.listRbacAuthorizationV1ClusterRoleBinding(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiListRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleList> {
    return this.api.listRbacAuthorizationV1NamespacedRole(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiListRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBindingList> {
    return this.api.listRbacAuthorizationV1NamespacedRoleBinding(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1RoleBindingForAllNamespaces(
    param:
      RbacAuthorizationV1ApiListRbacAuthorizationV1RoleBindingForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBindingList> {
    return this.api.listRbacAuthorizationV1RoleBindingForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1RoleForAllNamespaces(
    param:
      RbacAuthorizationV1ApiListRbacAuthorizationV1RoleForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleList> {
    return this.api.listRbacAuthorizationV1RoleForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
  public patchRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiPatchRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRole> {
    return this.api.patchRbacAuthorizationV1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiPatchRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleBinding> {
    return this.api.patchRbacAuthorizationV1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Role
     * @param param the request object
     */
  public patchRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiPatchRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1Role> {
    return this.api.patchRbacAuthorizationV1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiPatchRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBinding> {
    return this.api.patchRbacAuthorizationV1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRole
     * @param param the request object
     */
  public readRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiReadRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRole> {
    return this.api.readRbacAuthorizationV1ClusterRole(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiReadRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleBinding> {
    return this.api.readRbacAuthorizationV1ClusterRoleBinding(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Role
     * @param param the request object
     */
  public readRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiReadRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1Role> {
    return this.api.readRbacAuthorizationV1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified RoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiReadRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBinding> {
    return this.api.readRbacAuthorizationV1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRole
     * @param param the request object
     */
  public replaceRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiReplaceRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRole> {
    return this.api.replaceRbacAuthorizationV1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiReplaceRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1ClusterRoleBinding> {
    return this.api.replaceRbacAuthorizationV1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Role
     * @param param the request object
     */
  public replaceRbacAuthorizationV1NamespacedRole(
    param:
      RbacAuthorizationV1ApiReplaceRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1Role> {
    return this.api.replaceRbacAuthorizationV1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified RoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiReplaceRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1RoleBinding> {
    return this.api.replaceRbacAuthorizationV1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1ClusterRole(
    param: RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1ClusterRole(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1ClusterRoleBinding(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1ClusterRoleBinding(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1ClusterRoleBindingList(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1ClusterRoleBindingList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1ClusterRoleList(
    param: RbacAuthorizationV1ApiWatchRbacAuthorizationV1ClusterRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1ClusterRoleList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1NamespacedRole(
    param: RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1NamespacedRole(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1NamespacedRoleBindingList(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1NamespacedRoleBindingList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1NamespacedRoleList(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1NamespacedRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1NamespacedRoleList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1RoleBindingListForAllNamespaces(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1RoleBindingListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1RoleListForAllNamespaces(
    param:
      RbacAuthorizationV1ApiWatchRbacAuthorizationV1RoleListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1RoleListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableRbacAuthorizationV1alpha1Api } from "./ObservableAPI.ts";
import {
  RbacAuthorizationV1alpha1ApiRequestFactory,
  RbacAuthorizationV1alpha1ApiResponseProcessor,
} from "../apis/RbacAuthorizationV1alpha1Api.ts";

export interface RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * 
     * @type IoK8sApiRbacV1alpha1ClusterRole
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRole
     */
  body: IoK8sApiRbacV1alpha1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * 
     * @type IoK8sApiRbacV1alpha1ClusterRoleBinding
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1alpha1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1Role
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRole
     */
  body: IoK8sApiRbacV1alpha1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1RoleBinding
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1alpha1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApicreateRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionNamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1alpha1ApideleteRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1alpha1ApiGetRbacAuthorizationV1alpha1APIResourcesRequest {
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1RoleBindingForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleBindingForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1RoleForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApilistRbacAuthorizationV1alpha1RoleForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApipatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireadRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRole
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1ClusterRole
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRole
     */
  body: IoK8sApiRbacV1alpha1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1ClusterRoleBinding
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1alpha1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1Role
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  body: IoK8sApiRbacV1alpha1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1alpha1RoleBinding
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1alpha1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApireplaceRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleBindingListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1ClusterRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleBindingListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1NamespacedRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1RoleListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1alpha1ApiwatchRbacAuthorizationV1alpha1RoleListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectRbacAuthorizationV1alpha1Api {
  private api: ObservableRbacAuthorizationV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: RbacAuthorizationV1alpha1ApiRequestFactory,
    responseProcessor?: RbacAuthorizationV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableRbacAuthorizationV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a ClusterRole
     * @param param the request object
     */
  public createRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRole> {
    return this.api.createRbacAuthorizationV1alpha1ClusterRole(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleBinding> {
    return this.api.createRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Role
     * @param param the request object
     */
  public createRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1Role> {
    return this.api.createRbacAuthorizationV1alpha1NamespacedRole(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a RoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiCreateRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBinding> {
    return this.api.createRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1ClusterRole(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1CollectionClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1CollectionClusterRole(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1CollectionNamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionNamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1CollectionNamespacedRole(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding(
        param.namespace,
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiDeleteRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getRbacAuthorizationV1alpha1APIResources(
    param:
      RbacAuthorizationV1alpha1ApiGetRbacAuthorizationV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getRbacAuthorizationV1alpha1APIResources(options)
      .toPromise();
  }

  /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleList> {
    return this.api.listRbacAuthorizationV1alpha1ClusterRole(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleBindingList> {
    return this.api.listRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleList> {
    return this.api.listRbacAuthorizationV1alpha1NamespacedRole(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBindingList> {
    return this.api.listRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1RoleBindingForAllNamespaces(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1RoleBindingForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBindingList> {
    return this.api.listRbacAuthorizationV1alpha1RoleBindingForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1alpha1RoleForAllNamespaces(
    param:
      RbacAuthorizationV1alpha1ApiListRbacAuthorizationV1alpha1RoleForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleList> {
    return this.api.listRbacAuthorizationV1alpha1RoleForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
  public patchRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRole> {
    return this.api.patchRbacAuthorizationV1alpha1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleBinding> {
    return this.api.patchRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Role
     * @param param the request object
     */
  public patchRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1Role> {
    return this.api.patchRbacAuthorizationV1alpha1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiPatchRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBinding> {
    return this.api.patchRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRole
     * @param param the request object
     */
  public readRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRole> {
    return this.api.readRbacAuthorizationV1alpha1ClusterRole(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleBinding> {
    return this.api.readRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Role
     * @param param the request object
     */
  public readRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1Role> {
    return this.api.readRbacAuthorizationV1alpha1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified RoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiReadRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBinding> {
    return this.api.readRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRole
     * @param param the request object
     */
  public replaceRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRole> {
    return this.api.replaceRbacAuthorizationV1alpha1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1ClusterRoleBinding> {
    return this.api.replaceRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Role
     * @param param the request object
     */
  public replaceRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1Role> {
    return this.api.replaceRbacAuthorizationV1alpha1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified RoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiReplaceRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1alpha1RoleBinding> {
    return this.api.replaceRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1ClusterRole(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1ClusterRole(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1ClusterRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1ClusterRoleBinding(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1ClusterRoleBindingList(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1ClusterRoleBindingList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1ClusterRoleList(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1ClusterRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1ClusterRoleList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1NamespacedRole(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1NamespacedRole(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1NamespacedRoleBindingList(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1NamespacedRoleBindingList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1NamespacedRoleList(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1NamespacedRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1NamespacedRoleList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1RoleBindingListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchRbacAuthorizationV1alpha1RoleBindingListForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1alpha1RoleListForAllNamespaces(
    param:
      RbacAuthorizationV1alpha1ApiWatchRbacAuthorizationV1alpha1RoleListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1alpha1RoleListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableRbacAuthorizationV1beta1Api } from "./ObservableAPI.ts";
import {
  RbacAuthorizationV1beta1ApiRequestFactory,
  RbacAuthorizationV1beta1ApiResponseProcessor,
} from "../apis/RbacAuthorizationV1beta1Api.ts";

export interface RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * 
     * @type IoK8sApiRbacV1beta1ClusterRole
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRole
     */
  body: IoK8sApiRbacV1beta1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * 
     * @type IoK8sApiRbacV1beta1ClusterRoleBinding
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1beta1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1Role
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRole
     */
  body: IoK8sApiRbacV1beta1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1RoleBinding
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1beta1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApicreateRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1ClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionClusterRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionNamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionNamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRole
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof RbacAuthorizationV1beta1ApideleteRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface RbacAuthorizationV1beta1ApiGetRbacAuthorizationV1beta1APIResourcesRequest {
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1RoleBindingForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleBindingForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1RoleForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApilistRbacAuthorizationV1beta1RoleForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRole
     */
  force?: boolean;
}

export interface RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApipatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  force?: boolean;
}

export interface RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1ClusterRole
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1ClusterRoleBinding
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
}

export interface RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireadRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
}

export interface RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRole
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1ClusterRole
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRole
     */
  body: IoK8sApiRbacV1beta1ClusterRole;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRoleBinding
     */
  name: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1ClusterRoleBinding
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRoleBinding
     */
  body: IoK8sApiRbacV1beta1ClusterRoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1ClusterRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1Role
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  body: IoK8sApiRbacV1beta1Role;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRole
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiRbacV1beta1RoleBinding
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  body: IoK8sApiRbacV1beta1RoleBinding;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApireplaceRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  fieldManager?: string;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleRequest {
  /**
     * name of the ClusterRole
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleBindingRequest {
  /**
     * name of the ClusterRoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleBindingListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1ClusterRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleRequest {
  /**
     * name of the Role
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRole
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleBindingRequest {
  /**
     * name of the RoleBinding
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBinding
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleBindingListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleBindingList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1NamespacedRoleList
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1RoleBindingListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces
     */
  watch?: boolean;
}

export interface RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1RoleListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof RbacAuthorizationV1beta1ApiwatchRbacAuthorizationV1beta1RoleListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectRbacAuthorizationV1beta1Api {
  private api: ObservableRbacAuthorizationV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: RbacAuthorizationV1beta1ApiRequestFactory,
    responseProcessor?: RbacAuthorizationV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableRbacAuthorizationV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a ClusterRole
     * @param param the request object
     */
  public createRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRole> {
    return this.api.createRbacAuthorizationV1beta1ClusterRole(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleBinding> {
    return this.api.createRbacAuthorizationV1beta1ClusterRoleBinding(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a Role
     * @param param the request object
     */
  public createRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1Role> {
    return this.api.createRbacAuthorizationV1beta1NamespacedRole(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a RoleBinding
     * @param param the request object
     */
  public createRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiCreateRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBinding> {
    return this.api.createRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1ClusterRole(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1ClusterRoleBinding(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRole
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1CollectionClusterRole(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1CollectionClusterRole(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1CollectionClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1CollectionClusterRoleBinding(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1CollectionNamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionNamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1CollectionNamespacedRole(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1CollectionNamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api
      .deleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding(
        param.namespace,
        param.pretty,
        param._continue,
        param.dryRun,
        param.fieldSelector,
        param.gracePeriodSeconds,
        param.labelSelector,
        param.limit,
        param.orphanDependents,
        param.propagationPolicy,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.body,
        options,
      ).toPromise();
  }

  /**
     * delete a Role
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a RoleBinding
     * @param param the request object
     */
  public deleteRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiDeleteRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getRbacAuthorizationV1beta1APIResources(
    param:
      RbacAuthorizationV1beta1ApiGetRbacAuthorizationV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getRbacAuthorizationV1beta1APIResources(options)
      .toPromise();
  }

  /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleList> {
    return this.api.listRbacAuthorizationV1beta1ClusterRole(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleBindingList> {
    return this.api.listRbacAuthorizationV1beta1ClusterRoleBinding(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleList> {
    return this.api.listRbacAuthorizationV1beta1NamespacedRole(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBindingList> {
    return this.api.listRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1RoleBindingForAllNamespaces(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1RoleBindingForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBindingList> {
    return this.api.listRbacAuthorizationV1beta1RoleBindingForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind Role
     * @param param the request object
     */
  public listRbacAuthorizationV1beta1RoleForAllNamespaces(
    param:
      RbacAuthorizationV1beta1ApiListRbacAuthorizationV1beta1RoleForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleList> {
    return this.api.listRbacAuthorizationV1beta1RoleForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
  public patchRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRole> {
    return this.api.patchRbacAuthorizationV1beta1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleBinding> {
    return this.api.patchRbacAuthorizationV1beta1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified Role
     * @param param the request object
     */
  public patchRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1Role> {
    return this.api.patchRbacAuthorizationV1beta1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
  public patchRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiPatchRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBinding> {
    return this.api.patchRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRole
     * @param param the request object
     */
  public readRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRole> {
    return this.api.readRbacAuthorizationV1beta1ClusterRole(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleBinding> {
    return this.api.readRbacAuthorizationV1beta1ClusterRoleBinding(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified Role
     * @param param the request object
     */
  public readRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1Role> {
    return this.api.readRbacAuthorizationV1beta1NamespacedRole(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * read the specified RoleBinding
     * @param param the request object
     */
  public readRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiReadRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBinding> {
    return this.api.readRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRole
     * @param param the request object
     */
  public replaceRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRole> {
    return this.api.replaceRbacAuthorizationV1beta1ClusterRole(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1ClusterRoleBinding> {
    return this.api.replaceRbacAuthorizationV1beta1ClusterRoleBinding(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified Role
     * @param param the request object
     */
  public replaceRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1Role> {
    return this.api.replaceRbacAuthorizationV1beta1NamespacedRole(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified RoleBinding
     * @param param the request object
     */
  public replaceRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiReplaceRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApiRbacV1beta1RoleBinding> {
    return this.api.replaceRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1ClusterRole(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1ClusterRole(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1ClusterRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1ClusterRoleBinding(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1ClusterRoleBindingList(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1ClusterRoleBindingList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1ClusterRoleList(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1ClusterRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1ClusterRoleList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1NamespacedRole(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1NamespacedRole(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1NamespacedRoleBinding(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleBindingRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1NamespacedRoleBinding(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1NamespacedRoleBindingList(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleBindingListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1NamespacedRoleBindingList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1NamespacedRoleList(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1NamespacedRoleListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1NamespacedRoleList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1RoleBindingListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api
      .watchRbacAuthorizationV1beta1RoleBindingListForAllNamespaces(
        param.allowWatchBookmarks,
        param._continue,
        param.fieldSelector,
        param.labelSelector,
        param.limit,
        param.pretty,
        param.resourceVersion,
        param.resourceVersionMatch,
        param.timeoutSeconds,
        param.watch,
        options,
      ).toPromise();
  }

  /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchRbacAuthorizationV1beta1RoleListForAllNamespaces(
    param:
      RbacAuthorizationV1beta1ApiWatchRbacAuthorizationV1beta1RoleListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchRbacAuthorizationV1beta1RoleListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableSchedulingApi } from "./ObservableAPI.ts";
import {
  SchedulingApiRequestFactory,
  SchedulingApiResponseProcessor,
} from "../apis/SchedulingApi.ts";

export interface SchedulingApiGetSchedulingAPIGroupRequest {
}

export class ObjectSchedulingApi {
  private api: ObservableSchedulingApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: SchedulingApiRequestFactory,
    responseProcessor?: SchedulingApiResponseProcessor,
  ) {
    this.api = new ObservableSchedulingApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getSchedulingAPIGroup(
    param: SchedulingApiGetSchedulingAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getSchedulingAPIGroup(options).toPromise();
  }
}

import { ObservableSchedulingV1Api } from "./ObservableAPI.ts";
import {
  SchedulingV1ApiRequestFactory,
  SchedulingV1ApiResponseProcessor,
} from "../apis/SchedulingV1Api.ts";

export interface SchedulingV1ApiCreateSchedulingV1PriorityClassRequest {
  /**
     * 
     * @type IoK8sApiSchedulingV1PriorityClass
     * @memberof SchedulingV1ApicreateSchedulingV1PriorityClass
     */
  body: IoK8sApiSchedulingV1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApicreateSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApicreateSchedulingV1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1ApicreateSchedulingV1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1ApiDeleteSchedulingV1CollectionPriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1ApideleteSchedulingV1CollectionPriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1ApiDeleteSchedulingV1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1ApideleteSchedulingV1PriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1ApiGetSchedulingV1APIResourcesRequest {
}

export interface SchedulingV1ApiListSchedulingV1PriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1ApilistSchedulingV1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1ApiPatchSchedulingV1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SchedulingV1ApipatchSchedulingV1PriorityClass
     */
  force?: boolean;
}

export interface SchedulingV1ApiReadSchedulingV1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApireadSchedulingV1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApireadSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1ApireadSchedulingV1PriorityClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1ApireadSchedulingV1PriorityClass
     */
  _export?: boolean;
}

export interface SchedulingV1ApiReplaceSchedulingV1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApireplaceSchedulingV1PriorityClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiSchedulingV1PriorityClass
     * @memberof SchedulingV1ApireplaceSchedulingV1PriorityClass
     */
  body: IoK8sApiSchedulingV1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApireplaceSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1ApireplaceSchedulingV1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1ApireplaceSchedulingV1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1ApiWatchSchedulingV1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1ApiWatchSchedulingV1PriorityClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1ApiwatchSchedulingV1PriorityClassList
     */
  watch?: boolean;
}

export class ObjectSchedulingV1Api {
  private api: ObservableSchedulingV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: SchedulingV1ApiRequestFactory,
    responseProcessor?: SchedulingV1ApiResponseProcessor,
  ) {
    this.api = new ObservableSchedulingV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a PriorityClass
     * @param param the request object
     */
  public createSchedulingV1PriorityClass(
    param: SchedulingV1ApiCreateSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1PriorityClass> {
    return this.api.createSchedulingV1PriorityClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1CollectionPriorityClass(
    param: SchedulingV1ApiDeleteSchedulingV1CollectionPriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1CollectionPriorityClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1PriorityClass(
    param: SchedulingV1ApiDeleteSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1PriorityClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getSchedulingV1APIResources(
    param: SchedulingV1ApiGetSchedulingV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getSchedulingV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
  public listSchedulingV1PriorityClass(
    param: SchedulingV1ApiListSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1PriorityClassList> {
    return this.api.listSchedulingV1PriorityClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
  public patchSchedulingV1PriorityClass(
    param: SchedulingV1ApiPatchSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1PriorityClass> {
    return this.api.patchSchedulingV1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified PriorityClass
     * @param param the request object
     */
  public readSchedulingV1PriorityClass(
    param: SchedulingV1ApiReadSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1PriorityClass> {
    return this.api.readSchedulingV1PriorityClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PriorityClass
     * @param param the request object
     */
  public replaceSchedulingV1PriorityClass(
    param: SchedulingV1ApiReplaceSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1PriorityClass> {
    return this.api.replaceSchedulingV1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchSchedulingV1PriorityClass(
    param: SchedulingV1ApiWatchSchedulingV1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1PriorityClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchSchedulingV1PriorityClassList(
    param: SchedulingV1ApiWatchSchedulingV1PriorityClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1PriorityClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableSchedulingV1alpha1Api } from "./ObservableAPI.ts";
import {
  SchedulingV1alpha1ApiRequestFactory,
  SchedulingV1alpha1ApiResponseProcessor,
} from "../apis/SchedulingV1alpha1Api.ts";

export interface SchedulingV1alpha1ApiCreateSchedulingV1alpha1PriorityClassRequest {
  /**
     * 
     * @type IoK8sApiSchedulingV1alpha1PriorityClass
     * @memberof SchedulingV1alpha1ApicreateSchedulingV1alpha1PriorityClass
     */
  body: IoK8sApiSchedulingV1alpha1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApicreateSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApicreateSchedulingV1alpha1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1alpha1ApicreateSchedulingV1alpha1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1alpha1ApiDeleteSchedulingV1alpha1CollectionPriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1CollectionPriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1alpha1ApiDeleteSchedulingV1alpha1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1alpha1ApideleteSchedulingV1alpha1PriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1alpha1ApiGetSchedulingV1alpha1APIResourcesRequest {
}

export interface SchedulingV1alpha1ApiListSchedulingV1alpha1PriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1alpha1ApilistSchedulingV1alpha1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1alpha1ApiPatchSchedulingV1alpha1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SchedulingV1alpha1ApipatchSchedulingV1alpha1PriorityClass
     */
  force?: boolean;
}

export interface SchedulingV1alpha1ApiReadSchedulingV1alpha1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApireadSchedulingV1alpha1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApireadSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1alpha1ApireadSchedulingV1alpha1PriorityClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1alpha1ApireadSchedulingV1alpha1PriorityClass
     */
  _export?: boolean;
}

export interface SchedulingV1alpha1ApiReplaceSchedulingV1alpha1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApireplaceSchedulingV1alpha1PriorityClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiSchedulingV1alpha1PriorityClass
     * @memberof SchedulingV1alpha1ApireplaceSchedulingV1alpha1PriorityClass
     */
  body: IoK8sApiSchedulingV1alpha1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApireplaceSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1alpha1ApireplaceSchedulingV1alpha1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1alpha1ApireplaceSchedulingV1alpha1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1alpha1ApiWatchSchedulingV1alpha1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1alpha1ApiWatchSchedulingV1alpha1PriorityClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1alpha1ApiwatchSchedulingV1alpha1PriorityClassList
     */
  watch?: boolean;
}

export class ObjectSchedulingV1alpha1Api {
  private api: ObservableSchedulingV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: SchedulingV1alpha1ApiRequestFactory,
    responseProcessor?: SchedulingV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableSchedulingV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a PriorityClass
     * @param param the request object
     */
  public createSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiCreateSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1alpha1PriorityClass> {
    return this.api.createSchedulingV1alpha1PriorityClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1alpha1CollectionPriorityClass(
    param:
      SchedulingV1alpha1ApiDeleteSchedulingV1alpha1CollectionPriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1alpha1CollectionPriorityClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiDeleteSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1alpha1PriorityClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getSchedulingV1alpha1APIResources(
    param: SchedulingV1alpha1ApiGetSchedulingV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getSchedulingV1alpha1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
  public listSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiListSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1alpha1PriorityClassList> {
    return this.api.listSchedulingV1alpha1PriorityClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
  public patchSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiPatchSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1alpha1PriorityClass> {
    return this.api.patchSchedulingV1alpha1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified PriorityClass
     * @param param the request object
     */
  public readSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiReadSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1alpha1PriorityClass> {
    return this.api.readSchedulingV1alpha1PriorityClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PriorityClass
     * @param param the request object
     */
  public replaceSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiReplaceSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1alpha1PriorityClass> {
    return this.api.replaceSchedulingV1alpha1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchSchedulingV1alpha1PriorityClass(
    param: SchedulingV1alpha1ApiWatchSchedulingV1alpha1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1alpha1PriorityClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchSchedulingV1alpha1PriorityClassList(
    param: SchedulingV1alpha1ApiWatchSchedulingV1alpha1PriorityClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1alpha1PriorityClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableSchedulingV1beta1Api } from "./ObservableAPI.ts";
import {
  SchedulingV1beta1ApiRequestFactory,
  SchedulingV1beta1ApiResponseProcessor,
} from "../apis/SchedulingV1beta1Api.ts";

export interface SchedulingV1beta1ApiCreateSchedulingV1beta1PriorityClassRequest {
  /**
     * 
     * @type IoK8sApiSchedulingV1beta1PriorityClass
     * @memberof SchedulingV1beta1ApicreateSchedulingV1beta1PriorityClass
     */
  body: IoK8sApiSchedulingV1beta1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApicreateSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1beta1ApicreateSchedulingV1beta1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1beta1ApicreateSchedulingV1beta1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1beta1ApiDeleteSchedulingV1beta1CollectionPriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1CollectionPriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1beta1ApiDeleteSchedulingV1beta1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SchedulingV1beta1ApideleteSchedulingV1beta1PriorityClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SchedulingV1beta1ApiGetSchedulingV1beta1APIResourcesRequest {
}

export interface SchedulingV1beta1ApiListSchedulingV1beta1PriorityClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1beta1ApilistSchedulingV1beta1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1beta1ApiPatchSchedulingV1beta1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SchedulingV1beta1ApipatchSchedulingV1beta1PriorityClass
     */
  force?: boolean;
}

export interface SchedulingV1beta1ApiReadSchedulingV1beta1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1beta1ApireadSchedulingV1beta1PriorityClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApireadSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1beta1ApireadSchedulingV1beta1PriorityClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SchedulingV1beta1ApireadSchedulingV1beta1PriorityClass
     */
  _export?: boolean;
}

export interface SchedulingV1beta1ApiReplaceSchedulingV1beta1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1beta1ApireplaceSchedulingV1beta1PriorityClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiSchedulingV1beta1PriorityClass
     * @memberof SchedulingV1beta1ApireplaceSchedulingV1beta1PriorityClass
     */
  body: IoK8sApiSchedulingV1beta1PriorityClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApireplaceSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SchedulingV1beta1ApireplaceSchedulingV1beta1PriorityClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SchedulingV1beta1ApireplaceSchedulingV1beta1PriorityClass
     */
  fieldManager?: string;
}

export interface SchedulingV1beta1ApiWatchSchedulingV1beta1PriorityClassRequest {
  /**
     * name of the PriorityClass
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClass
     */
  watch?: boolean;
}

export interface SchedulingV1beta1ApiWatchSchedulingV1beta1PriorityClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SchedulingV1beta1ApiwatchSchedulingV1beta1PriorityClassList
     */
  watch?: boolean;
}

export class ObjectSchedulingV1beta1Api {
  private api: ObservableSchedulingV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: SchedulingV1beta1ApiRequestFactory,
    responseProcessor?: SchedulingV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableSchedulingV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a PriorityClass
     * @param param the request object
     */
  public createSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiCreateSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1beta1PriorityClass> {
    return this.api.createSchedulingV1beta1PriorityClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1beta1CollectionPriorityClass(
    param:
      SchedulingV1beta1ApiDeleteSchedulingV1beta1CollectionPriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1beta1CollectionPriorityClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PriorityClass
     * @param param the request object
     */
  public deleteSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiDeleteSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSchedulingV1beta1PriorityClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getSchedulingV1beta1APIResources(
    param: SchedulingV1beta1ApiGetSchedulingV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getSchedulingV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
  public listSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiListSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1beta1PriorityClassList> {
    return this.api.listSchedulingV1beta1PriorityClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
  public patchSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiPatchSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1beta1PriorityClass> {
    return this.api.patchSchedulingV1beta1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified PriorityClass
     * @param param the request object
     */
  public readSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiReadSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1beta1PriorityClass> {
    return this.api.readSchedulingV1beta1PriorityClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PriorityClass
     * @param param the request object
     */
  public replaceSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiReplaceSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSchedulingV1beta1PriorityClass> {
    return this.api.replaceSchedulingV1beta1PriorityClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchSchedulingV1beta1PriorityClass(
    param: SchedulingV1beta1ApiWatchSchedulingV1beta1PriorityClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1beta1PriorityClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchSchedulingV1beta1PriorityClassList(
    param: SchedulingV1beta1ApiWatchSchedulingV1beta1PriorityClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSchedulingV1beta1PriorityClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableSettingsApi } from "./ObservableAPI.ts";
import {
  SettingsApiRequestFactory,
  SettingsApiResponseProcessor,
} from "../apis/SettingsApi.ts";

export interface SettingsApiGetSettingsAPIGroupRequest {
}

export class ObjectSettingsApi {
  private api: ObservableSettingsApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: SettingsApiRequestFactory,
    responseProcessor?: SettingsApiResponseProcessor,
  ) {
    this.api = new ObservableSettingsApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getSettingsAPIGroup(
    param: SettingsApiGetSettingsAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getSettingsAPIGroup(options).toPromise();
  }
}

import { ObservableSettingsV1alpha1Api } from "./ObservableAPI.ts";
import {
  SettingsV1alpha1ApiRequestFactory,
  SettingsV1alpha1ApiResponseProcessor,
} from "../apis/SettingsV1alpha1Api.ts";

export interface SettingsV1alpha1ApiCreateSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApicreateSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiSettingsV1alpha1PodPreset
     * @memberof SettingsV1alpha1ApicreateSettingsV1alpha1NamespacedPodPreset
     */
  body: IoK8sApiSettingsV1alpha1PodPreset;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApicreateSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SettingsV1alpha1ApicreateSettingsV1alpha1NamespacedPodPreset
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SettingsV1alpha1ApicreateSettingsV1alpha1NamespacedPodPreset
     */
  fieldManager?: string;
}

export interface SettingsV1alpha1ApiDeleteSettingsV1alpha1CollectionNamespacedPodPresetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1CollectionNamespacedPodPreset
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SettingsV1alpha1ApiDeleteSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * name of the PodPreset
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof SettingsV1alpha1ApideleteSettingsV1alpha1NamespacedPodPreset
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface SettingsV1alpha1ApiGetSettingsV1alpha1APIResourcesRequest {
}

export interface SettingsV1alpha1ApiListSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1NamespacedPodPreset
     */
  watch?: boolean;
}

export interface SettingsV1alpha1ApiListSettingsV1alpha1PodPresetForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SettingsV1alpha1ApilistSettingsV1alpha1PodPresetForAllNamespaces
     */
  watch?: boolean;
}

export interface SettingsV1alpha1ApiPatchSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * name of the PodPreset
     * @type string
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * 
     * @type any
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof SettingsV1alpha1ApipatchSettingsV1alpha1NamespacedPodPreset
     */
  force?: boolean;
}

export interface SettingsV1alpha1ApiReadSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * name of the PodPreset
     * @type string
     * @memberof SettingsV1alpha1ApireadSettingsV1alpha1NamespacedPodPreset
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApireadSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApireadSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SettingsV1alpha1ApireadSettingsV1alpha1NamespacedPodPreset
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof SettingsV1alpha1ApireadSettingsV1alpha1NamespacedPodPreset
     */
  _export?: boolean;
}

export interface SettingsV1alpha1ApiReplaceSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * name of the PodPreset
     * @type string
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * 
     * @type IoK8sApiSettingsV1alpha1PodPreset
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  body: IoK8sApiSettingsV1alpha1PodPreset;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof SettingsV1alpha1ApireplaceSettingsV1alpha1NamespacedPodPreset
     */
  fieldManager?: string;
}

export interface SettingsV1alpha1ApiWatchSettingsV1alpha1NamespacedPodPresetRequest {
  /**
     * name of the PodPreset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  name: string;
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPreset
     */
  watch?: boolean;
}

export interface SettingsV1alpha1ApiWatchSettingsV1alpha1NamespacedPodPresetListRequest {
  /**
     * object name and auth scope, such as for teams and projects
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  namespace: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1NamespacedPodPresetList
     */
  watch?: boolean;
}

export interface SettingsV1alpha1ApiWatchSettingsV1alpha1PodPresetListForAllNamespacesRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof SettingsV1alpha1ApiwatchSettingsV1alpha1PodPresetListForAllNamespaces
     */
  watch?: boolean;
}

export class ObjectSettingsV1alpha1Api {
  private api: ObservableSettingsV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: SettingsV1alpha1ApiRequestFactory,
    responseProcessor?: SettingsV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableSettingsV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a PodPreset
     * @param param the request object
     */
  public createSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiCreateSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPreset> {
    return this.api.createSettingsV1alpha1NamespacedPodPreset(
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of PodPreset
     * @param param the request object
     */
  public deleteSettingsV1alpha1CollectionNamespacedPodPreset(
    param:
      SettingsV1alpha1ApiDeleteSettingsV1alpha1CollectionNamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSettingsV1alpha1CollectionNamespacedPodPreset(
      param.namespace,
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a PodPreset
     * @param param the request object
     */
  public deleteSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiDeleteSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteSettingsV1alpha1NamespacedPodPreset(
      param.name,
      param.namespace,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getSettingsV1alpha1APIResources(
    param: SettingsV1alpha1ApiGetSettingsV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getSettingsV1alpha1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind PodPreset
     * @param param the request object
     */
  public listSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiListSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPresetList> {
    return this.api.listSettingsV1alpha1NamespacedPodPreset(
      param.namespace,
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind PodPreset
     * @param param the request object
     */
  public listSettingsV1alpha1PodPresetForAllNamespaces(
    param:
      SettingsV1alpha1ApiListSettingsV1alpha1PodPresetForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPresetList> {
    return this.api.listSettingsV1alpha1PodPresetForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified PodPreset
     * @param param the request object
     */
  public patchSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiPatchSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPreset> {
    return this.api.patchSettingsV1alpha1NamespacedPodPreset(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified PodPreset
     * @param param the request object
     */
  public readSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiReadSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPreset> {
    return this.api.readSettingsV1alpha1NamespacedPodPreset(
      param.name,
      param.namespace,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified PodPreset
     * @param param the request object
     */
  public replaceSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiReplaceSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApiSettingsV1alpha1PodPreset> {
    return this.api.replaceSettingsV1alpha1NamespacedPodPreset(
      param.name,
      param.namespace,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind PodPreset. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchSettingsV1alpha1NamespacedPodPreset(
    param: SettingsV1alpha1ApiWatchSettingsV1alpha1NamespacedPodPresetRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSettingsV1alpha1NamespacedPodPreset(
      param.name,
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodPreset. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchSettingsV1alpha1NamespacedPodPresetList(
    param:
      SettingsV1alpha1ApiWatchSettingsV1alpha1NamespacedPodPresetListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSettingsV1alpha1NamespacedPodPresetList(
      param.namespace,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of PodPreset. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchSettingsV1alpha1PodPresetListForAllNamespaces(
    param:
      SettingsV1alpha1ApiWatchSettingsV1alpha1PodPresetListForAllNamespacesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchSettingsV1alpha1PodPresetListForAllNamespaces(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableStorageApi } from "./ObservableAPI.ts";
import {
  StorageApiRequestFactory,
  StorageApiResponseProcessor,
} from "../apis/StorageApi.ts";

export interface StorageApiGetStorageAPIGroupRequest {
}

export class ObjectStorageApi {
  private api: ObservableStorageApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: StorageApiRequestFactory,
    responseProcessor?: StorageApiResponseProcessor,
  ) {
    this.api = new ObservableStorageApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get information of a group
     * @param param the request object
     */
  public getStorageAPIGroup(
    param: StorageApiGetStorageAPIGroupRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIGroup> {
    return this.api.getStorageAPIGroup(options).toPromise();
  }
}

import { ObservableStorageV1Api } from "./ObservableAPI.ts";
import {
  StorageV1ApiRequestFactory,
  StorageV1ApiResponseProcessor,
} from "../apis/StorageV1Api.ts";

export interface StorageV1ApiCreateStorageV1CSIDriverRequest {
  /**
     * 
     * @type IoK8sApiStorageV1CSIDriver
     * @memberof StorageV1ApicreateStorageV1CSIDriver
     */
  body: IoK8sApiStorageV1CSIDriver;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSIDriver
     */
  fieldManager?: string;
}

export interface StorageV1ApiCreateStorageV1CSINodeRequest {
  /**
     * 
     * @type IoK8sApiStorageV1CSINode
     * @memberof StorageV1ApicreateStorageV1CSINode
     */
  body: IoK8sApiStorageV1CSINode;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateStorageV1CSINode
     */
  fieldManager?: string;
}

export interface StorageV1ApiCreateStorageV1StorageClassRequest {
  /**
     * 
     * @type IoK8sApiStorageV1StorageClass
     * @memberof StorageV1ApicreateStorageV1StorageClass
     */
  body: IoK8sApiStorageV1StorageClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateStorageV1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateStorageV1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateStorageV1StorageClass
     */
  fieldManager?: string;
}

export interface StorageV1ApiCreateStorageV1VolumeAttachmentRequest {
  /**
     * 
     * @type IoK8sApiStorageV1VolumeAttachment
     * @memberof StorageV1ApicreateStorageV1VolumeAttachment
     */
  body: IoK8sApiStorageV1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApicreateStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApicreateStorageV1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApicreateStorageV1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1ApiDeleteStorageV1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CSIDriver
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CSINode
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1CollectionCSIDriverRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CollectionCSIDriver
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1CollectionCSINodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CollectionCSINode
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1CollectionStorageClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CollectionStorageClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1CollectionVolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1CollectionVolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1StorageClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiDeleteStorageV1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1ApideleteStorageV1VolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1ApiGetStorageV1APIResourcesRequest {
}

export interface StorageV1ApiListStorageV1CSIDriverRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1CSIDriver
     */
  watch?: boolean;
}

export interface StorageV1ApiListStorageV1CSINodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1CSINode
     */
  watch?: boolean;
}

export interface StorageV1ApiListStorageV1StorageClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1StorageClass
     */
  watch?: boolean;
}

export interface StorageV1ApiListStorageV1VolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApilistStorageV1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1ApiPatchStorageV1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageV1CSIDriver
     */
  force?: boolean;
}

export interface StorageV1ApiPatchStorageV1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageV1CSINode
     */
  force?: boolean;
}

export interface StorageV1ApiPatchStorageV1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageV1StorageClass
     */
  force?: boolean;
}

export interface StorageV1ApiPatchStorageV1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageV1VolumeAttachment
     */
  force?: boolean;
}

export interface StorageV1ApiPatchStorageV1VolumeAttachmentStatusRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1ApipatchStorageV1VolumeAttachmentStatus
     */
  force?: boolean;
}

export interface StorageV1ApiReadStorageV1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApireadStorageV1CSIDriver
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1CSIDriver
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1CSIDriver
     */
  _export?: boolean;
}

export interface StorageV1ApiReadStorageV1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApireadStorageV1CSINode
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageV1CSINode
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1CSINode
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1CSINode
     */
  _export?: boolean;
}

export interface StorageV1ApiReadStorageV1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApireadStorageV1StorageClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageV1StorageClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1StorageClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1StorageClass
     */
  _export?: boolean;
}

export interface StorageV1ApiReadStorageV1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireadStorageV1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1VolumeAttachment
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1ApireadStorageV1VolumeAttachment
     */
  _export?: boolean;
}

export interface StorageV1ApiReadStorageV1VolumeAttachmentStatusRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireadStorageV1VolumeAttachmentStatus
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireadStorageV1VolumeAttachmentStatus
     */
  pretty?: string;
}

export interface StorageV1ApiReplaceStorageV1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSIDriver
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1CSIDriver
     * @memberof StorageV1ApireplaceStorageV1CSIDriver
     */
  body: IoK8sApiStorageV1CSIDriver;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSIDriver
     */
  fieldManager?: string;
}

export interface StorageV1ApiReplaceStorageV1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSINode
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1CSINode
     * @memberof StorageV1ApireplaceStorageV1CSINode
     */
  body: IoK8sApiStorageV1CSINode;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1CSINode
     */
  fieldManager?: string;
}

export interface StorageV1ApiReplaceStorageV1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApireplaceStorageV1StorageClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1StorageClass
     * @memberof StorageV1ApireplaceStorageV1StorageClass
     */
  body: IoK8sApiStorageV1StorageClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageV1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1StorageClass
     */
  fieldManager?: string;
}

export interface StorageV1ApiReplaceStorageV1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1VolumeAttachment
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachment
     */
  body: IoK8sApiStorageV1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1ApiReplaceStorageV1VolumeAttachmentStatusRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachmentStatus
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1VolumeAttachment
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachmentStatus
     */
  body: IoK8sApiStorageV1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachmentStatus
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachmentStatus
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1ApireplaceStorageV1VolumeAttachmentStatus
     */
  fieldManager?: string;
}

export interface StorageV1ApiWatchStorageV1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSIDriver
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1CSIDriverListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSIDriverList
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSINode
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1CSINodeListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1CSINodeList
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1StorageClass
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1StorageClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1StorageClassList
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1ApiWatchStorageV1VolumeAttachmentListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1ApiwatchStorageV1VolumeAttachmentList
     */
  watch?: boolean;
}

export class ObjectStorageV1Api {
  private api: ObservableStorageV1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: StorageV1ApiRequestFactory,
    responseProcessor?: StorageV1ApiResponseProcessor,
  ) {
    this.api = new ObservableStorageV1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CSIDriver
     * @param param the request object
     */
  public createStorageV1CSIDriver(
    param: StorageV1ApiCreateStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriver> {
    return this.api.createStorageV1CSIDriver(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a CSINode
     * @param param the request object
     */
  public createStorageV1CSINode(
    param: StorageV1ApiCreateStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINode> {
    return this.api.createStorageV1CSINode(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a StorageClass
     * @param param the request object
     */
  public createStorageV1StorageClass(
    param: StorageV1ApiCreateStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClass> {
    return this.api.createStorageV1StorageClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a VolumeAttachment
     * @param param the request object
     */
  public createStorageV1VolumeAttachment(
    param: StorageV1ApiCreateStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.createStorageV1VolumeAttachment(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a CSIDriver
     * @param param the request object
     */
  public deleteStorageV1CSIDriver(
    param: StorageV1ApiDeleteStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriver> {
    return this.api.deleteStorageV1CSIDriver(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a CSINode
     * @param param the request object
     */
  public deleteStorageV1CSINode(
    param: StorageV1ApiDeleteStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINode> {
    return this.api.deleteStorageV1CSINode(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CSIDriver
     * @param param the request object
     */
  public deleteStorageV1CollectionCSIDriver(
    param: StorageV1ApiDeleteStorageV1CollectionCSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1CollectionCSIDriver(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CSINode
     * @param param the request object
     */
  public deleteStorageV1CollectionCSINode(
    param: StorageV1ApiDeleteStorageV1CollectionCSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1CollectionCSINode(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of StorageClass
     * @param param the request object
     */
  public deleteStorageV1CollectionStorageClass(
    param: StorageV1ApiDeleteStorageV1CollectionStorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1CollectionStorageClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1CollectionVolumeAttachment(
    param: StorageV1ApiDeleteStorageV1CollectionVolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1CollectionVolumeAttachment(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a StorageClass
     * @param param the request object
     */
  public deleteStorageV1StorageClass(
    param: StorageV1ApiDeleteStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClass> {
    return this.api.deleteStorageV1StorageClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1VolumeAttachment(
    param: StorageV1ApiDeleteStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.deleteStorageV1VolumeAttachment(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getStorageV1APIResources(
    param: StorageV1ApiGetStorageV1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getStorageV1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
  public listStorageV1CSIDriver(
    param: StorageV1ApiListStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriverList> {
    return this.api.listStorageV1CSIDriver(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
  public listStorageV1CSINode(
    param: StorageV1ApiListStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINodeList> {
    return this.api.listStorageV1CSINode(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
  public listStorageV1StorageClass(
    param: StorageV1ApiListStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClassList> {
    return this.api.listStorageV1StorageClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
  public listStorageV1VolumeAttachment(
    param: StorageV1ApiListStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachmentList> {
    return this.api.listStorageV1VolumeAttachment(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
  public patchStorageV1CSIDriver(
    param: StorageV1ApiPatchStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriver> {
    return this.api.patchStorageV1CSIDriver(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CSINode
     * @param param the request object
     */
  public patchStorageV1CSINode(
    param: StorageV1ApiPatchStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINode> {
    return this.api.patchStorageV1CSINode(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified StorageClass
     * @param param the request object
     */
  public patchStorageV1StorageClass(
    param: StorageV1ApiPatchStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClass> {
    return this.api.patchStorageV1StorageClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
  public patchStorageV1VolumeAttachment(
    param: StorageV1ApiPatchStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.patchStorageV1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update status of the specified VolumeAttachment
     * @param param the request object
     */
  public patchStorageV1VolumeAttachmentStatus(
    param: StorageV1ApiPatchStorageV1VolumeAttachmentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.patchStorageV1VolumeAttachmentStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CSIDriver
     * @param param the request object
     */
  public readStorageV1CSIDriver(
    param: StorageV1ApiReadStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriver> {
    return this.api.readStorageV1CSIDriver(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified CSINode
     * @param param the request object
     */
  public readStorageV1CSINode(
    param: StorageV1ApiReadStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINode> {
    return this.api.readStorageV1CSINode(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified StorageClass
     * @param param the request object
     */
  public readStorageV1StorageClass(
    param: StorageV1ApiReadStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClass> {
    return this.api.readStorageV1StorageClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
  public readStorageV1VolumeAttachment(
    param: StorageV1ApiReadStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.readStorageV1VolumeAttachment(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read status of the specified VolumeAttachment
     * @param param the request object
     */
  public readStorageV1VolumeAttachmentStatus(
    param: StorageV1ApiReadStorageV1VolumeAttachmentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.readStorageV1VolumeAttachmentStatus(
      param.name,
      param.pretty,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CSIDriver
     * @param param the request object
     */
  public replaceStorageV1CSIDriver(
    param: StorageV1ApiReplaceStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSIDriver> {
    return this.api.replaceStorageV1CSIDriver(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CSINode
     * @param param the request object
     */
  public replaceStorageV1CSINode(
    param: StorageV1ApiReplaceStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1CSINode> {
    return this.api.replaceStorageV1CSINode(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified StorageClass
     * @param param the request object
     */
  public replaceStorageV1StorageClass(
    param: StorageV1ApiReplaceStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1StorageClass> {
    return this.api.replaceStorageV1StorageClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
  public replaceStorageV1VolumeAttachment(
    param: StorageV1ApiReplaceStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.replaceStorageV1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace status of the specified VolumeAttachment
     * @param param the request object
     */
  public replaceStorageV1VolumeAttachmentStatus(
    param: StorageV1ApiReplaceStorageV1VolumeAttachmentStatusRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1VolumeAttachment> {
    return this.api.replaceStorageV1VolumeAttachmentStatus(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CSIDriver. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1CSIDriver(
    param: StorageV1ApiWatchStorageV1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1CSIDriver(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CSIDriver. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1CSIDriverList(
    param: StorageV1ApiWatchStorageV1CSIDriverListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1CSIDriverList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CSINode. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1CSINode(
    param: StorageV1ApiWatchStorageV1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1CSINode(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CSINode. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1CSINodeList(
    param: StorageV1ApiWatchStorageV1CSINodeListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1CSINodeList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind StorageClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1StorageClass(
    param: StorageV1ApiWatchStorageV1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1StorageClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of StorageClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1StorageClassList(
    param: StorageV1ApiWatchStorageV1StorageClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1StorageClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1VolumeAttachment(
    param: StorageV1ApiWatchStorageV1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1VolumeAttachment(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1VolumeAttachmentList(
    param: StorageV1ApiWatchStorageV1VolumeAttachmentListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1VolumeAttachmentList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableStorageV1alpha1Api } from "./ObservableAPI.ts";
import {
  StorageV1alpha1ApiRequestFactory,
  StorageV1alpha1ApiResponseProcessor,
} from "../apis/StorageV1alpha1Api.ts";

export interface StorageV1alpha1ApiCreateStorageV1alpha1VolumeAttachmentRequest {
  /**
     * 
     * @type IoK8sApiStorageV1alpha1VolumeAttachment
     * @memberof StorageV1alpha1ApicreateStorageV1alpha1VolumeAttachment
     */
  body: IoK8sApiStorageV1alpha1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApicreateStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApicreateStorageV1alpha1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApicreateStorageV1alpha1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1alpha1ApiDeleteStorageV1alpha1CollectionVolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1CollectionVolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1alpha1ApiDeleteStorageV1alpha1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1alpha1ApideleteStorageV1alpha1VolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1alpha1ApiGetStorageV1alpha1APIResourcesRequest {
}

export interface StorageV1alpha1ApiListStorageV1alpha1VolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApilistStorageV1alpha1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1alpha1ApiPatchStorageV1alpha1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1alpha1ApipatchStorageV1alpha1VolumeAttachment
     */
  force?: boolean;
}

export interface StorageV1alpha1ApiReadStorageV1alpha1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApireadStorageV1alpha1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireadStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1alpha1ApireadStorageV1alpha1VolumeAttachment
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1alpha1ApireadStorageV1alpha1VolumeAttachment
     */
  _export?: boolean;
}

export interface StorageV1alpha1ApiReplaceStorageV1alpha1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApireplaceStorageV1alpha1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1alpha1VolumeAttachment
     * @memberof StorageV1alpha1ApireplaceStorageV1alpha1VolumeAttachment
     */
  body: IoK8sApiStorageV1alpha1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApireplaceStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1alpha1ApireplaceStorageV1alpha1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1alpha1ApireplaceStorageV1alpha1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1alpha1ApiWatchStorageV1alpha1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1alpha1ApiWatchStorageV1alpha1VolumeAttachmentListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1alpha1ApiwatchStorageV1alpha1VolumeAttachmentList
     */
  watch?: boolean;
}

export class ObjectStorageV1alpha1Api {
  private api: ObservableStorageV1alpha1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: StorageV1alpha1ApiRequestFactory,
    responseProcessor?: StorageV1alpha1ApiResponseProcessor,
  ) {
    this.api = new ObservableStorageV1alpha1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a VolumeAttachment
     * @param param the request object
     */
  public createStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiCreateStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachment> {
    return this.api.createStorageV1alpha1VolumeAttachment(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1alpha1CollectionVolumeAttachment(
    param:
      StorageV1alpha1ApiDeleteStorageV1alpha1CollectionVolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1alpha1CollectionVolumeAttachment(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiDeleteStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachment> {
    return this.api.deleteStorageV1alpha1VolumeAttachment(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getStorageV1alpha1APIResources(
    param: StorageV1alpha1ApiGetStorageV1alpha1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getStorageV1alpha1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
  public listStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiListStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachmentList> {
    return this.api.listStorageV1alpha1VolumeAttachment(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
  public patchStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiPatchStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachment> {
    return this.api.patchStorageV1alpha1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
  public readStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiReadStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachment> {
    return this.api.readStorageV1alpha1VolumeAttachment(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
  public replaceStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiReplaceStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1alpha1VolumeAttachment> {
    return this.api.replaceStorageV1alpha1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1alpha1VolumeAttachment(
    param: StorageV1alpha1ApiWatchStorageV1alpha1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1alpha1VolumeAttachment(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1alpha1VolumeAttachmentList(
    param: StorageV1alpha1ApiWatchStorageV1alpha1VolumeAttachmentListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1alpha1VolumeAttachmentList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableStorageV1beta1Api } from "./ObservableAPI.ts";
import {
  StorageV1beta1ApiRequestFactory,
  StorageV1beta1ApiResponseProcessor,
} from "../apis/StorageV1beta1Api.ts";

export interface StorageV1beta1ApiCreateStorageV1beta1CSIDriverRequest {
  /**
     * 
     * @type IoK8sApiStorageV1beta1CSIDriver
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSIDriver
     */
  body: IoK8sApiStorageV1beta1CSIDriver;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSIDriver
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiCreateStorageV1beta1CSINodeRequest {
  /**
     * 
     * @type IoK8sApiStorageV1beta1CSINode
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSINode
     */
  body: IoK8sApiStorageV1beta1CSINode;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1CSINode
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiCreateStorageV1beta1StorageClassRequest {
  /**
     * 
     * @type IoK8sApiStorageV1beta1StorageClass
     * @memberof StorageV1beta1ApicreateStorageV1beta1StorageClass
     */
  body: IoK8sApiStorageV1beta1StorageClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1StorageClass
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiCreateStorageV1beta1VolumeAttachmentRequest {
  /**
     * 
     * @type IoK8sApiStorageV1beta1VolumeAttachment
     * @memberof StorageV1beta1ApicreateStorageV1beta1VolumeAttachment
     */
  body: IoK8sApiStorageV1beta1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApicreateStorageV1beta1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSIDriver
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CSINode
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CollectionCSIDriverRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSIDriver
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CollectionCSINodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionCSINode
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CollectionStorageClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionStorageClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1CollectionVolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  pretty?: string;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  _continue?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  dryRun?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  fieldSelector?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  limit?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1CollectionVolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1StorageClass
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiDeleteStorageV1beta1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  dryRun?: string;
  /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @type number
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  gracePeriodSeconds?: number;
  /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @type boolean
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  orphanDependents?: boolean;
  /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     * @type string
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  propagationPolicy?: string;
  /**
     * 
     * @type IoK8sApimachineryPkgApisMetaV1DeleteOptions
     * @memberof StorageV1beta1ApideleteStorageV1beta1VolumeAttachment
     */
  body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface StorageV1beta1ApiGetStorageV1beta1APIResourcesRequest {
}

export interface StorageV1beta1ApiListStorageV1beta1CSIDriverRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1CSIDriver
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiListStorageV1beta1CSINodeRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1CSINode
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiListStorageV1beta1StorageClassRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1StorageClass
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiListStorageV1beta1VolumeAttachmentRequest {
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  limit?: number;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApilistStorageV1beta1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiPatchStorageV1beta1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSIDriver
     */
  force?: boolean;
}

export interface StorageV1beta1ApiPatchStorageV1beta1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1beta1ApipatchStorageV1beta1CSINode
     */
  force?: boolean;
}

export interface StorageV1beta1ApiPatchStorageV1beta1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1beta1ApipatchStorageV1beta1StorageClass
     */
  force?: boolean;
}

export interface StorageV1beta1ApiPatchStorageV1beta1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  body: any;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * @type string
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  fieldManager?: string;
  /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @type boolean
     * @memberof StorageV1beta1ApipatchStorageV1beta1VolumeAttachment
     */
  force?: boolean;
}

export interface StorageV1beta1ApiReadStorageV1beta1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1CSIDriver
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1CSIDriver
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1CSIDriver
     */
  _export?: boolean;
}

export interface StorageV1beta1ApiReadStorageV1beta1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1CSINode
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1CSINode
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1CSINode
     */
  _export?: boolean;
}

export interface StorageV1beta1ApiReadStorageV1beta1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1StorageClass
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1StorageClass
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1StorageClass
     */
  _export?: boolean;
}

export interface StorageV1beta1ApiReadStorageV1beta1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1VolumeAttachment
     */
  name: string;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireadStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1VolumeAttachment
     */
  exact?: boolean;
  /**
     * Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.
     * @type boolean
     * @memberof StorageV1beta1ApireadStorageV1beta1VolumeAttachment
     */
  _export?: boolean;
}

export interface StorageV1beta1ApiReplaceStorageV1beta1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSIDriver
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1beta1CSIDriver
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSIDriver
     */
  body: IoK8sApiStorageV1beta1CSIDriver;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSIDriver
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSIDriver
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiReplaceStorageV1beta1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSINode
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1beta1CSINode
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSINode
     */
  body: IoK8sApiStorageV1beta1CSINode;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSINode
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1CSINode
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiReplaceStorageV1beta1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1StorageClass
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1beta1StorageClass
     * @memberof StorageV1beta1ApireplaceStorageV1beta1StorageClass
     */
  body: IoK8sApiStorageV1beta1StorageClass;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1StorageClass
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1StorageClass
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiReplaceStorageV1beta1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1VolumeAttachment
     */
  name: string;
  /**
     * 
     * @type IoK8sApiStorageV1beta1VolumeAttachment
     * @memberof StorageV1beta1ApireplaceStorageV1beta1VolumeAttachment
     */
  body: IoK8sApiStorageV1beta1VolumeAttachment;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1VolumeAttachment
     */
  dryRun?: string;
  /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * @type string
     * @memberof StorageV1beta1ApireplaceStorageV1beta1VolumeAttachment
     */
  fieldManager?: string;
}

export interface StorageV1beta1ApiWatchStorageV1beta1CSIDriverRequest {
  /**
     * name of the CSIDriver
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriver
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1CSIDriverListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSIDriverList
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1CSINodeRequest {
  /**
     * name of the CSINode
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINode
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1CSINodeListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1CSINodeList
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1StorageClassRequest {
  /**
     * name of the StorageClass
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClass
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1StorageClassListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1StorageClassList
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1VolumeAttachmentRequest {
  /**
     * name of the VolumeAttachment
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  name: string;
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachment
     */
  watch?: boolean;
}

export interface StorageV1beta1ApiWatchStorageV1beta1VolumeAttachmentListRequest {
  /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  allowWatchBookmarks?: boolean;
  /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  _continue?: string;
  /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  fieldSelector?: string;
  /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  labelSelector?: string;
  /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  limit?: number;
  /**
     * If &#39;true&#39;, then the output is pretty printed.
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  pretty?: string;
  /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  resourceVersion?: string;
  /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * @type string
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  resourceVersionMatch?: string;
  /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @type number
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  timeoutSeconds?: number;
  /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * @type boolean
     * @memberof StorageV1beta1ApiwatchStorageV1beta1VolumeAttachmentList
     */
  watch?: boolean;
}

export class ObjectStorageV1beta1Api {
  private api: ObservableStorageV1beta1Api;

  public constructor(
    configuration: Configuration,
    requestFactory?: StorageV1beta1ApiRequestFactory,
    responseProcessor?: StorageV1beta1ApiResponseProcessor,
  ) {
    this.api = new ObservableStorageV1beta1Api(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * create a CSIDriver
     * @param param the request object
     */
  public createStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiCreateStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriver> {
    return this.api.createStorageV1beta1CSIDriver(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a CSINode
     * @param param the request object
     */
  public createStorageV1beta1CSINode(
    param: StorageV1beta1ApiCreateStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINode> {
    return this.api.createStorageV1beta1CSINode(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a StorageClass
     * @param param the request object
     */
  public createStorageV1beta1StorageClass(
    param: StorageV1beta1ApiCreateStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClass> {
    return this.api.createStorageV1beta1StorageClass(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * create a VolumeAttachment
     * @param param the request object
     */
  public createStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiCreateStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachment> {
    return this.api.createStorageV1beta1VolumeAttachment(
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * delete a CSIDriver
     * @param param the request object
     */
  public deleteStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiDeleteStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriver> {
    return this.api.deleteStorageV1beta1CSIDriver(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a CSINode
     * @param param the request object
     */
  public deleteStorageV1beta1CSINode(
    param: StorageV1beta1ApiDeleteStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINode> {
    return this.api.deleteStorageV1beta1CSINode(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CSIDriver
     * @param param the request object
     */
  public deleteStorageV1beta1CollectionCSIDriver(
    param: StorageV1beta1ApiDeleteStorageV1beta1CollectionCSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1beta1CollectionCSIDriver(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of CSINode
     * @param param the request object
     */
  public deleteStorageV1beta1CollectionCSINode(
    param: StorageV1beta1ApiDeleteStorageV1beta1CollectionCSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1beta1CollectionCSINode(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of StorageClass
     * @param param the request object
     */
  public deleteStorageV1beta1CollectionStorageClass(
    param: StorageV1beta1ApiDeleteStorageV1beta1CollectionStorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1beta1CollectionStorageClass(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1beta1CollectionVolumeAttachment(
    param:
      StorageV1beta1ApiDeleteStorageV1beta1CollectionVolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
    return this.api.deleteStorageV1beta1CollectionVolumeAttachment(
      param.pretty,
      param._continue,
      param.dryRun,
      param.fieldSelector,
      param.gracePeriodSeconds,
      param.labelSelector,
      param.limit,
      param.orphanDependents,
      param.propagationPolicy,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a StorageClass
     * @param param the request object
     */
  public deleteStorageV1beta1StorageClass(
    param: StorageV1beta1ApiDeleteStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClass> {
    return this.api.deleteStorageV1beta1StorageClass(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * delete a VolumeAttachment
     * @param param the request object
     */
  public deleteStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiDeleteStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachment> {
    return this.api.deleteStorageV1beta1VolumeAttachment(
      param.name,
      param.pretty,
      param.dryRun,
      param.gracePeriodSeconds,
      param.orphanDependents,
      param.propagationPolicy,
      param.body,
      options,
    ).toPromise();
  }

  /**
     * get available resources
     * @param param the request object
     */
  public getStorageV1beta1APIResources(
    param: StorageV1beta1ApiGetStorageV1beta1APIResourcesRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
    return this.api.getStorageV1beta1APIResources(options).toPromise();
  }

  /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
  public listStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiListStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriverList> {
    return this.api.listStorageV1beta1CSIDriver(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
  public listStorageV1beta1CSINode(
    param: StorageV1beta1ApiListStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINodeList> {
    return this.api.listStorageV1beta1CSINode(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
  public listStorageV1beta1StorageClass(
    param: StorageV1beta1ApiListStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClassList> {
    return this.api.listStorageV1beta1StorageClass(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
  public listStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiListStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachmentList> {
    return this.api.listStorageV1beta1VolumeAttachment(
      param.pretty,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
  public patchStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiPatchStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriver> {
    return this.api.patchStorageV1beta1CSIDriver(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified CSINode
     * @param param the request object
     */
  public patchStorageV1beta1CSINode(
    param: StorageV1beta1ApiPatchStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINode> {
    return this.api.patchStorageV1beta1CSINode(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified StorageClass
     * @param param the request object
     */
  public patchStorageV1beta1StorageClass(
    param: StorageV1beta1ApiPatchStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClass> {
    return this.api.patchStorageV1beta1StorageClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
  public patchStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiPatchStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachment> {
    return this.api.patchStorageV1beta1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      param.force,
      options,
    ).toPromise();
  }

  /**
     * read the specified CSIDriver
     * @param param the request object
     */
  public readStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiReadStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriver> {
    return this.api.readStorageV1beta1CSIDriver(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified CSINode
     * @param param the request object
     */
  public readStorageV1beta1CSINode(
    param: StorageV1beta1ApiReadStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINode> {
    return this.api.readStorageV1beta1CSINode(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified StorageClass
     * @param param the request object
     */
  public readStorageV1beta1StorageClass(
    param: StorageV1beta1ApiReadStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClass> {
    return this.api.readStorageV1beta1StorageClass(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
  public readStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiReadStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachment> {
    return this.api.readStorageV1beta1VolumeAttachment(
      param.name,
      param.pretty,
      param.exact,
      param._export,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CSIDriver
     * @param param the request object
     */
  public replaceStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiReplaceStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSIDriver> {
    return this.api.replaceStorageV1beta1CSIDriver(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified CSINode
     * @param param the request object
     */
  public replaceStorageV1beta1CSINode(
    param: StorageV1beta1ApiReplaceStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1CSINode> {
    return this.api.replaceStorageV1beta1CSINode(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified StorageClass
     * @param param the request object
     */
  public replaceStorageV1beta1StorageClass(
    param: StorageV1beta1ApiReplaceStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1StorageClass> {
    return this.api.replaceStorageV1beta1StorageClass(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
  public replaceStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiReplaceStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApiStorageV1beta1VolumeAttachment> {
    return this.api.replaceStorageV1beta1VolumeAttachment(
      param.name,
      param.body,
      param.pretty,
      param.dryRun,
      param.fieldManager,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CSIDriver. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1beta1CSIDriver(
    param: StorageV1beta1ApiWatchStorageV1beta1CSIDriverRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1CSIDriver(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CSIDriver. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1beta1CSIDriverList(
    param: StorageV1beta1ApiWatchStorageV1beta1CSIDriverListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1CSIDriverList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind CSINode. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1beta1CSINode(
    param: StorageV1beta1ApiWatchStorageV1beta1CSINodeRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1CSINode(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of CSINode. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1beta1CSINodeList(
    param: StorageV1beta1ApiWatchStorageV1beta1CSINodeListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1CSINodeList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind StorageClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1beta1StorageClass(
    param: StorageV1beta1ApiWatchStorageV1beta1StorageClassRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1StorageClass(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of StorageClass. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1beta1StorageClassList(
    param: StorageV1beta1ApiWatchStorageV1beta1StorageClassListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1StorageClassList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * @param param the request object
     */
  public watchStorageV1beta1VolumeAttachment(
    param: StorageV1beta1ApiWatchStorageV1beta1VolumeAttachmentRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1VolumeAttachment(
      param.name,
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }

  /**
     * watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead.
     * @param param the request object
     */
  public watchStorageV1beta1VolumeAttachmentList(
    param: StorageV1beta1ApiWatchStorageV1beta1VolumeAttachmentListRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
    return this.api.watchStorageV1beta1VolumeAttachmentList(
      param.allowWatchBookmarks,
      param._continue,
      param.fieldSelector,
      param.labelSelector,
      param.limit,
      param.pretty,
      param.resourceVersion,
      param.resourceVersionMatch,
      param.timeoutSeconds,
      param.watch,
      options,
    ).toPromise();
  }
}

import { ObservableVersionApi } from "./ObservableAPI.ts";
import {
  VersionApiRequestFactory,
  VersionApiResponseProcessor,
} from "../apis/VersionApi.ts";

export interface VersionApiGetCodeVersionRequest {
}

export class ObjectVersionApi {
  private api: ObservableVersionApi;

  public constructor(
    configuration: Configuration,
    requestFactory?: VersionApiRequestFactory,
    responseProcessor?: VersionApiResponseProcessor,
  ) {
    this.api = new ObservableVersionApi(
      configuration,
      requestFactory,
      responseProcessor,
    );
  }

  /**
     * get the code version
     * @param param the request object
     */
  public getCodeVersion(
    param: VersionApiGetCodeVersionRequest,
    options?: Configuration,
  ): Promise<IoK8sApimachineryPkgVersionInfo> {
    return this.api.getCodeVersion(options).toPromise();
  }
}
